// CourtLens Security Framework Tests
// Comprehensive test suite for security services

import { AuthenticationService } from '../src/services/authentication.service';
import { AuthorizationService } from '../src/services/authorization.service';
import { EncryptionService } from '../src/services/encryption.service';
import { SecurityValidator } from '../src/utils/validator';
import { SecurityFramework, createSecurityFramework } from '../src/index';
import {
  User,
  UserRole,
  EncryptionLevel,
  SecurityEventType,
  RiskLevel
} from '../src/types';

// Mock Supabase client
jest.mock('@supabase/supabase-js', () => ({
  createClient: jest.fn(() => ({
    auth: {
      signInWithPassword: jest.fn(),
      signOut: jest.fn(),
      refreshSession: jest.fn(),
      admin: {
        createUser: jest.fn(),
        deleteUser: jest.fn()
      }
    },
    from: jest.fn(() => ({
      select: jest.fn().mockReturnThis(),
      insert: jest.fn().mockReturnThis(),
      update: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      single: jest.fn()
    }))
  }))
}));

describe('Security Framework', () => {
  let securityFramework: SecurityFramework;
  let authService: AuthenticationService;
  let authzService: AuthorizationService;
  let encryptionService: EncryptionService;
  let validator: SecurityValidator;

  beforeEach(() => {
    securityFramework = createSecurityFramework({
      supabase: {
        url: 'https://test.supabase.co',
        serviceRoleKey: 'test-service-key',
        anonKey: 'test-anon-key'
      },
      jwt: {
        secret: 'test-jwt-secret',
        expiresIn: '1h'
      }
    });

    authService = securityFramework.authentication;
    authzService = securityFramework.authorization;
    encryptionService = securityFramework.encryption;
    validator = new SecurityValidator();
  });

  describe('Authentication Service', () => {
    const mockUser: User = {
      id: 'test-user-id',
      email: 'test@example.com',
      firstName: 'John',
      lastName: 'Doe',
      role: UserRole.ASSOCIATE,
      organizationId: 'test-org-id',
      isActive: true,
      emailVerified: true,
      mfaEnabled: false,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    describe('login', () => {
      it('should successfully authenticate valid credentials', async () => {
        // Mock successful authentication
        const mockAuthData = {
          user: { id: 'test-user-id', email: 'test@example.com' },
          session: { access_token: 'test-token' }
        };

        // Mock Supabase auth response
        (authService as any).supabase.auth.signInWithPassword.mockResolvedValue({
          data: mockAuthData,
          error: null
        });

        // Mock user profile fetch
        (authService as any).getUserProfile = jest.fn().mockResolvedValue(mockUser);
        (authService as any).updateLastLogin = jest.fn().mockResolvedValue(void 0);
        (authService as any).createSession = jest.fn().mockResolvedValue({
          sessionId: 'test-session-id',
          userId: mockUser.id,
          organizationId: mockUser.organizationId,
          ipAddress: '127.0.0.1',
          userAgent: 'test-agent',
          issuedAt: new Date(),
          expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
          lastActivity: new Date(),
          isActive: true
        });

        const result = await authService.login(
          {
            email: 'test@example.com',
            password: 'validPassword123!'
          },
          {
            ipAddress: '127.0.0.1',
            userAgent: 'test-agent'
          }
        );

        expect(result).toHaveProperty('accessToken');
        expect(result).toHaveProperty('refreshToken');
        expect(result.tokenType).toBe('Bearer');
      });

      it('should reject invalid credentials', async () => {
        // Mock failed authentication
        (authService as any).supabase.auth.signInWithPassword.mockResolvedValue({
          data: null,
          error: { message: 'Invalid credentials' }
        });

        await expect(
          authService.login(
            {
              email: 'test@example.com',
              password: 'wrongPassword'
            },
            {
              ipAddress: '127.0.0.1',
              userAgent: 'test-agent'
            }
          )
        ).rejects.toThrow('Invalid password');
      });

      it('should require MFA when enabled', async () => {
        const mfaUser = { ...mockUser, mfaEnabled: true };

        (authService as any).supabase.auth.signInWithPassword.mockResolvedValue({
          data: { user: { id: 'test-user-id' } },
          error: null
        });

        (authService as any).getUserProfile = jest.fn().mockResolvedValue(mfaUser);

        await expect(
          authService.login(
            {
              email: 'test@example.com',
              password: 'validPassword123!'
            },
            {
              ipAddress: '127.0.0.1',
              userAgent: 'test-agent'
            }
          )
        ).rejects.toThrow('MFA token required');
      });
    });

    describe('register', () => {
      it('should successfully register new user', async () => {
        // Mock Supabase responses
        (authService as any).findUserByEmail = jest.fn().mockResolvedValue(null);
        (authService as any).getOrganization = jest.fn().mockResolvedValue({
          id: 'test-org-id',
          isActive: true
        });
        (authService as any).supabase.auth.admin.createUser.mockResolvedValue({
          data: { user: { id: 'new-user-id', email: 'new@example.com' } },
          error: null
        });
        
        // Mock the from().insert().select() chain
        const mockSelect = jest.fn().mockReturnValue({
          single: jest.fn().mockResolvedValue({
            data: { ...mockUser, id: 'new-user-id', email: 'new@example.com' },
            error: null
          })
        });
        const mockInsert = jest.fn().mockReturnValue({
          select: mockSelect
        });
        (authService as any).supabase.from.mockReturnValue({
          insert: mockInsert
        });
        
        (authService as any).sendVerificationEmail = jest.fn().mockResolvedValue(void 0);

        const result = await authService.register(
          {
            email: 'new@example.com',
            password: 'validPassword123!',
            firstName: 'Jane',
            lastName: 'Smith',
            organizationId: 'test-org-id'
          },
          {
            ipAddress: '127.0.0.1',
            userAgent: 'test-agent'
          }
        );

        expect(result).toHaveProperty('id');
        expect(result.email).toBe('new@example.com');
      });

      it('should reject registration with existing email', async () => {
        (authService as any).findUserByEmail = jest.fn().mockResolvedValue(mockUser);

        await expect(
          authService.register(
            {
              email: 'test@example.com',
              password: 'validPassword123!',
              firstName: 'Jane',
              lastName: 'Smith',
              organizationId: 'test-org-id'
            },
            {
              ipAddress: '127.0.0.1',
              userAgent: 'test-agent'
            }
          )
        ).rejects.toThrow('User already exists');
      });
    });
  });

  describe('Authorization Service', () => {
    const mockContext = {
      user: {
        id: 'test-user-id',
        email: 'test@example.com',
        role: UserRole.ASSOCIATE,
        organizationId: 'test-org-id'
      } as User,
      permissions: [],
      ipAddress: '127.0.0.1',
      userAgent: 'test-agent',
      requestId: 'test-request-id',
      timestamp: new Date()
    };

    describe('hasPermission', () => {
      it('should allow access for super admin', async () => {
        const adminContext = {
          ...mockContext,
          user: { ...mockContext.user, role: UserRole.SUPER_ADMIN }
        };

        const hasAccess = await authzService.hasPermission(adminContext, {
          resource: 'document',
          action: 'delete'
        });

        expect(hasAccess).toBe(true);
      });

      it('should deny access for insufficient permissions', async () => {
        (authzService as any).getUserPermissions = jest.fn().mockResolvedValue([]);

        const hasAccess = await authzService.hasPermission(mockContext, {
          resource: 'admin',
          action: 'delete'
        });

        expect(hasAccess).toBe(false);
      });

      it('should allow role-based permissions', async () => {
        (authzService as any).getUserPermissions = jest.fn().mockResolvedValue([]);

        const hasAccess = await authzService.hasPermission(mockContext, {
          resource: 'document',
          action: 'read'
        });

        expect(hasAccess).toBe(true);
      });
    });

    describe('canAccessOrganization', () => {
      it('should allow access to own organization', async () => {
        const canAccess = await authzService.canAccessOrganization(
          mockContext,
          'test-org-id'
        );

        expect(canAccess).toBe(true);
      });

      it('should deny access to different organization', async () => {
        (authzService as any).hasPermission = jest.fn().mockResolvedValue(false);

        const canAccess = await authzService.canAccessOrganization(
          mockContext,
          'different-org-id'
        );

        expect(canAccess).toBe(false);
      });
    });
  });

  describe('Encryption Service', () => {
    describe('encrypt/decrypt', () => {
      it('should encrypt and decrypt data successfully', async () => {
        const originalData = 'Sensitive legal document content';

        const encrypted = await encryptionService.encrypt(originalData, EncryptionLevel.ENHANCED);
        expect(encrypted).toHaveProperty('data');
        expect(encrypted).toHaveProperty('iv');
        expect(encrypted).toHaveProperty('salt');
        expect(encrypted).toHaveProperty('keyId');

        const decrypted = await encryptionService.decrypt(encrypted);
        expect(decrypted).toBe(originalData);
      });

      it('should encrypt files successfully', async () => {
        const fileBuffer = Buffer.from('Legal document file content', 'utf8');

        const encrypted = await encryptionService.encryptFile(fileBuffer);
        expect(encrypted).toHaveProperty('data');

        const decryptedBuffer = await encryptionService.decryptFile(encrypted);
        expect(decryptedBuffer.toString('utf8')).toBe('Legal document file content');
      });
    });

    describe('hash/verify', () => {
      it('should hash and verify data correctly', () => {
        const data = 'sensitive-client-information';
        const hashed = encryptionService.hash(data);

        expect(hashed).toContain(':'); // Should contain salt separator
        expect(encryptionService.verifyHash(data, hashed)).toBe(true);
        expect(encryptionService.verifyHash('wrong-data', hashed)).toBe(false);
      });
    });

    describe('token generation', () => {
      it('should generate secure random tokens', () => {
        const token1 = encryptionService.generateToken(32);
        const token2 = encryptionService.generateToken(32);

        expect(token1).toHaveLength(64); // 32 bytes = 64 hex chars
        expect(token2).toHaveLength(64);
        expect(token1).not.toBe(token2);
      });

      it('should generate secure passwords', () => {
        const password = encryptionService.generateSecurePassword(16);

        expect(password).toHaveLength(16);
        expect(/[A-Z]/.test(password)).toBe(true); // Contains uppercase
        expect(/[a-z]/.test(password)).toBe(true); // Contains lowercase
        expect(/[0-9]/.test(password)).toBe(true); // Contains numbers
        expect(/[!@#$%^&*]/.test(password)).toBe(true); // Contains special chars
      });
    });
  });

  describe('Security Validator', () => {
    describe('email validation', () => {
      it('should validate correct email addresses', () => {
        expect(() => validator.validateEmail('test@example.com')).not.toThrow();
        expect(() => validator.validateEmail('user.name+tag@domain.co.uk')).not.toThrow();
      });

      it('should reject invalid email addresses', () => {
        expect(() => validator.validateEmail('invalid-email')).toThrow();
        expect(() => validator.validateEmail('test@')).toThrow();
        expect(() => validator.validateEmail('@example.com')).toThrow();
      });
    });

    describe('password validation', () => {
      it('should validate strong passwords', () => {
        expect(() => validator.validatePassword('StrongPass123!')).not.toThrow();
        expect(() => validator.validatePassword('Myp@ssw0rd')).not.toThrow();
      });

      it('should reject weak passwords', () => {
        expect(() => validator.validatePassword('weak')).toThrow();
        expect(() => validator.validatePassword('onlylowercase')).toThrow();
        expect(() => validator.validatePassword('ONLYUPPERCASE')).toThrow();
        expect(() => validator.validatePassword('NoSpecialChars123')).toThrow();
      });
    });

    describe('input sanitization', () => {
      it('should sanitize potentially dangerous input', () => {
        const maliciousInput = '<script>alert("xss")</script>';
        const sanitized = validator.sanitizeInput(maliciousInput);
        
        expect(sanitized).not.toContain('<script>');
        expect(sanitized).not.toContain('</script>');
      });

      it('should remove quotes from input', () => {
        const input = 'O\'Reilly "Law Firm"';
        const sanitized = validator.sanitizeInput(input);
        
        expect(sanitized).not.toContain('"');
        expect(sanitized).not.toContain("'");
      });
    });

    describe('IP address validation', () => {
      it('should validate IPv4 addresses', () => {
        expect(validator.validateIpAddress('192.168.1.1')).toBe(true);
        expect(validator.validateIpAddress('127.0.0.1')).toBe(true);
        expect(validator.validateIpAddress('10.0.0.1')).toBe(true);
      });

      it('should reject invalid IPv4 addresses', () => {
        expect(validator.validateIpAddress('256.1.1.1')).toBe(false);
        expect(validator.validateIpAddress('192.168.1')).toBe(false);
        expect(validator.validateIpAddress('not-an-ip')).toBe(false);
      });
    });

    describe('UUID validation', () => {
      it('should validate correct UUIDs', () => {
        expect(validator.validateUuid('550e8400-e29b-41d4-a716-446655440000')).toBe(true);
        expect(validator.validateUuid('6ba7b810-9dad-11d1-80b4-00c04fd430c8')).toBe(true);
      });

      it('should reject invalid UUIDs', () => {
        expect(validator.validateUuid('not-a-uuid')).toBe(false);
        expect(validator.validateUuid('550e8400-e29b-41d4-a716')).toBe(false);
        expect(validator.validateUuid('550e8400-e29b-41d4-a716-446655440000-extra')).toBe(false);
      });
    });
  });

  describe('Security Framework Integration', () => {
    it('should initialize all services correctly', () => {
      expect(securityFramework.authentication).toBeInstanceOf(AuthenticationService);
      expect(securityFramework.authorization).toBeInstanceOf(AuthorizationService);
      expect(securityFramework.encryption).toBeInstanceOf(EncryptionService);
      expect(securityFramework.middleware).toBeDefined();
      expect(securityFramework.eventService).toBeDefined();
    });

    it('should provide Express configuration', () => {
      const expressConfig = securityFramework.getExpressConfig();

      expect(expressConfig).toHaveProperty('securityHeaders');
      expect(expressConfig).toHaveProperty('rateLimit');
      expect(expressConfig).toHaveProperty('authenticate');
      expect(expressConfig).toHaveProperty('authorize');
      expect(expressConfig).toHaveProperty('errorHandler');
    });
  });

  describe('Security Events', () => {
    it('should log security events correctly', async () => {
      const mockEvent = {
        id: 'test-event-id',
        type: SecurityEventType.LOGIN_SUCCESS,
        userId: 'test-user-id',
        organizationId: 'test-org-id',
        ipAddress: '127.0.0.1',
        userAgent: 'test-agent',
        resource: 'authentication',
        action: 'login',
        details: { sessionId: 'test-session-id' },
        riskLevel: RiskLevel.LOW,
        timestamp: new Date()
      };

      // Mock Supabase insert
      const mockInsert = jest.fn().mockResolvedValue({ error: null });
      (securityFramework.eventService as any).supabase.from = jest.fn(() => ({
        insert: mockInsert
      }));

      await securityFramework.eventService.logEvent(mockEvent);

      expect(mockInsert).toHaveBeenCalledWith([mockEvent]);
    });
  });

  describe('Performance and Security', () => {
    const mockUser: User = {
      id: 'test-user-id',
      email: 'test@example.com',
      firstName: 'John',
      lastName: 'Doe',
      role: UserRole.ASSOCIATE,
      organizationId: 'test-org-id',
      isActive: true,
      emailVerified: true,
      mfaEnabled: false,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    it('should handle concurrent authentication requests', async () => {
      const credentials = {
        email: 'test@example.com',
        password: 'validPassword123!'
      };
      const context = {
        ipAddress: '127.0.0.1',
        userAgent: 'test-agent'
      };

      // Mock successful authentication
      (authService as any).supabase.auth.signInWithPassword.mockResolvedValue({
        data: { user: { id: 'test-user-id' } },
        error: null
      });
      (authService as any).getUserProfile = jest.fn().mockResolvedValue({
        ...mockUser,
        mfaEnabled: false
      });
      (authService as any).updateLastLogin = jest.fn().mockResolvedValue(void 0);
      (authService as any).createSession = jest.fn().mockResolvedValue({
        sessionId: 'test-session-id'
      });

      // Test concurrent requests
      const promises = Array.from({ length: 10 }, () =>
        authService.login(credentials, context)
      );

      const results = await Promise.allSettled(promises);
      
      // All should either succeed or fail gracefully
      results.forEach(result => {
        expect(['fulfilled', 'rejected']).toContain(result.status);
      });
    });

    it('should encrypt large amounts of data efficiently', async () => {
      const largeData = 'A'.repeat(1000000); // 1MB of data
      const startTime = Date.now();

      const encrypted = await encryptionService.encrypt(largeData);
      const decrypted = await encryptionService.decrypt(encrypted);

      const endTime = Date.now();
      const duration = endTime - startTime;

      expect(decrypted).toBe(largeData);
      expect(duration).toBeLessThan(5000); // Should complete within 5 seconds
    });
  });
});
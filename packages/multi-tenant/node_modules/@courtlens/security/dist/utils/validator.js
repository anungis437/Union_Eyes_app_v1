"use strict";
// CourtLens Security Validator
// Input validation and sanitization for security-critical operations
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecurityValidator = void 0;
const joi_1 = __importDefault(require("joi"));
const types_1 = require("../types");
class SecurityValidator {
    constructor() {
        this.emailSchema = joi_1.default.string().email().required();
        this.passwordSchema = joi_1.default.string()
            .min(8)
            .max(128)
            .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
            .required()
            .messages({
            'string.pattern.base': 'Password must contain at least one lowercase letter, one uppercase letter, one number, and one special character'
        });
    }
    validateEmail(email) {
        const { error } = this.emailSchema.validate(email);
        if (error) {
            throw new types_1.ValidationError(`Invalid email: ${error.details[0].message}`);
        }
    }
    validatePassword(password) {
        const { error } = this.passwordSchema.validate(password);
        if (error) {
            throw new types_1.ValidationError(`Invalid password: ${error.details[0].message}`);
        }
    }
    validateRequired(value, fieldName) {
        if (!value || (typeof value === 'string' && value.trim().length === 0)) {
            throw new types_1.ValidationError(`${fieldName} is required`);
        }
    }
    sanitizeInput(input) {
        return input
            .replace(/[<>]/g, '') // Remove potential HTML tags
            .replace(/['"]/g, '') // Remove quotes
            .trim();
    }
    validateIpAddress(ip) {
        const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
        const ipv6Regex = /^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/;
        return ipv4Regex.test(ip) || ipv6Regex.test(ip);
    }
    validateUuid(uuid) {
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
        return uuidRegex.test(uuid);
    }
}
exports.SecurityValidator = SecurityValidator;
//# sourceMappingURL=validator.js.map
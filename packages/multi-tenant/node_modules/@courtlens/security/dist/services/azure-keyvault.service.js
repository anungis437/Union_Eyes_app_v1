"use strict";
/**
 * Azure Key Vault Integration Service
 * Secure key retrieval for production environments
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.secureConfig = exports.SecureConfigService = exports.AzureKeyVaultService = void 0;
const identity_1 = require("@azure/identity");
const keyvault_secrets_1 = require("@azure/keyvault-secrets");
class AzureKeyVaultService {
    constructor(config) {
        this.cache = new Map();
        this.CACHE_TTL = 5 * 60 * 1000; // 5 minutes
        const credential = config.clientSecret
            ? new identity_1.DefaultAzureCredential({
                tenantId: config.tenantId,
                managedIdentityClientId: config.clientId,
            })
            : new identity_1.DefaultAzureCredential();
        this.client = new keyvault_secrets_1.SecretClient(config.vaultUrl, credential);
    }
    /**
     * Get secret value from Azure Key Vault with caching
     */
    async getSecret(secretName) {
        // Check cache first
        const cached = this.cache.get(secretName);
        if (cached && cached.expiresAt > Date.now()) {
            return cached.value;
        }
        try {
            const response = await this.client.getSecret(secretName);
            if (!response.value) {
                throw new Error(`Secret '${secretName}' has no value`);
            }
            // Cache the result
            this.cache.set(secretName, {
                value: response.value,
                expiresAt: Date.now() + this.CACHE_TTL
            });
            return response.value;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            console.error(`Failed to retrieve secret '${secretName}':`, error);
            throw new Error(`Failed to retrieve secret '${secretName}': ${errorMessage}`);
        }
    }
    /**
     * Get multiple secrets in parallel
     */
    async getSecrets(secretNames) {
        const promises = secretNames.map(async (name) => {
            const value = await this.getSecret(name);
            return { name, value };
        });
        const results = await Promise.all(promises);
        return results.reduce((acc, { name, value }) => {
            acc[name] = value;
            return acc;
        }, {});
    }
    /**
     * Clear cache for specific secret or all secrets
     */
    clearCache(secretName) {
        if (secretName) {
            this.cache.delete(secretName);
        }
        else {
            this.cache.clear();
        }
    }
    /**
     * Check if Key Vault is accessible
     */
    async healthCheck() {
        try {
            // Try to list secrets (without values) to test connectivity
            const iterator = this.client.listPropertiesOfSecrets();
            await iterator.next();
            return true;
        }
        catch (error) {
            console.error('Key Vault health check failed:', error);
            return false;
        }
    }
}
exports.AzureKeyVaultService = AzureKeyVaultService;
/**
 * Environment-aware secret retrieval
 * Falls back to environment variables in development
 */
class SecureConfigService {
    constructor() {
        this.isProduction = process.env.NODE_ENV === 'production';
        if (this.isProduction && process.env.AZURE_KEY_VAULT_URL) {
            this.keyVaultService = new AzureKeyVaultService({
                vaultUrl: process.env.AZURE_KEY_VAULT_URL,
                tenantId: process.env.AZURE_TENANT_ID,
                clientId: process.env.AZURE_CLIENT_ID,
                clientSecret: process.env.AZURE_CLIENT_SECRET
            });
        }
    }
    /**
     * Get configuration value from Key Vault (production) or environment (development)
     */
    async getConfig(key, fallbackEnvVar) {
        // In production, try Key Vault first
        if (this.isProduction && this.keyVaultService) {
            try {
                return await this.keyVaultService.getSecret(key);
            }
            catch (error) {
                console.warn(`Failed to get ${key} from Key Vault, trying environment variable`);
            }
        }
        // Fallback to environment variable
        const envVar = fallbackEnvVar || key;
        const value = process.env[envVar];
        if (!value) {
            throw new Error(`Configuration '${key}' not found in Key Vault or environment variables`);
        }
        return value;
    }
    /**
     * Get Azure AI Services configuration
     */
    async getAzureAIConfig() {
        return {
            endpoint: await this.getConfig('azure-ai-services-endpoint', 'AZURE_AI_SERVICES_ENDPOINT'),
            apiKey: await this.getConfig('azure-ai-services-key', 'AZURE_AI_SERVICES_API_KEY'),
            location: await this.getConfig('azure-ai-services-location', 'AZURE_AI_SERVICES_LOCATION')
        };
    }
    /**
     * Get Azure OpenAI configuration
     */
    async getAzureOpenAIConfig() {
        return {
            endpoint: await this.getConfig('azure-openai-endpoint', 'AZURE_OPENAI_ENDPOINT'),
            apiKey: await this.getConfig('azure-openai-key', 'AZURE_OPENAI_API_KEY'),
            apiVersion: await this.getConfig('azure-openai-api-version', 'AZURE_OPENAI_API_VERSION')
        };
    }
    /**
     * Health check for the configuration service
     */
    async healthCheck() {
        const results = {
            keyVault: false,
            environment: true // Environment variables are always available
        };
        if (this.keyVaultService) {
            results.keyVault = await this.keyVaultService.healthCheck();
        }
        return results;
    }
}
exports.SecureConfigService = SecureConfigService;
// Singleton instance
exports.secureConfig = new SecureConfigService();
//# sourceMappingURL=azure-keyvault.service.js.map
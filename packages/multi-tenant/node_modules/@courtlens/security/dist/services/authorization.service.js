"use strict";
// CourtLens Authorization Service
// Role-based access control (RBAC) and permission management
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthorizationService = void 0;
const supabase_js_1 = require("@supabase/supabase-js");
const types_1 = require("../types");
const logger_1 = require("../utils/logger");
const security_event_service_1 = require("./security-event.service");
class AuthorizationService {
    constructor(supabaseUrl, supabaseServiceKey) {
        this.permissionCache = new Map();
        this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
        this.supabase = (0, supabase_js_1.createClient)(supabaseUrl, supabaseServiceKey);
        this.logger = new logger_1.SecurityLogger('AuthorizationService');
        this.eventService = new security_event_service_1.SecurityEventService(supabaseUrl, supabaseServiceKey);
    }
    /**
     * Check if user has permission for a specific action on a resource
     */
    async hasPermission(context, permissionCheck) {
        try {
            if (!context.user) {
                this.logger.warn('Authorization check without user context');
                return false;
            }
            // Get user permissions (cached)
            const permissions = await this.getUserPermissions(context.user.id);
            // Check for exact permission match
            const hasExactPermission = permissions.some(permission => permission.resource === permissionCheck.resource &&
                permission.action === permissionCheck.action &&
                this.matchesConditions(permission.conditions, permissionCheck.conditions));
            if (hasExactPermission) {
                return true;
            }
            // Check for wildcard permissions
            const hasWildcardPermission = permissions.some(permission => (permission.resource === '*' || permission.resource === permissionCheck.resource) &&
                (permission.action === '*' || permission.action === permissionCheck.action));
            if (hasWildcardPermission) {
                return true;
            }
            // Check role-based permissions
            const hasRolePermission = await this.checkRolePermission(context.user.role, permissionCheck);
            const hasAccess = hasRolePermission;
            // Log permission check
            if (!hasAccess) {
                await this.logPermissionDenied(context, permissionCheck);
            }
            return hasAccess;
        }
        catch (error) {
            this.logger.error('Permission check failed', {
                userId: context.user?.id,
                resource: permissionCheck.resource,
                action: permissionCheck.action,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
            return false;
        }
    }
    /**
     * Require permission or throw authorization error
     */
    async requirePermission(context, permissionCheck) {
        const hasAccess = await this.hasPermission(context, permissionCheck);
        if (!hasAccess) {
            throw new types_1.AuthorizationError(`Access denied: insufficient permissions for ${permissionCheck.action} on ${permissionCheck.resource}`, {
                resource: permissionCheck.resource,
                action: permissionCheck.action,
                userId: context.user?.id
            });
        }
    }
    /**
     * Get all permissions for a user
     */
    async getUserPermissions(userId) {
        const cacheKey = `user_permissions_${userId}`;
        // Check cache first
        const cached = this.permissionCache.get(cacheKey);
        if (cached) {
            return cached;
        }
        try {
            // Get user's direct permissions
            const { data: directPermissions } = await this.supabase
                .from('user_permissions')
                .select(`
          permission:permissions(*)
        `)
                .eq('user_id', userId);
            // Get user's role permissions
            const { data: rolePermissions } = await this.supabase
                .from('user_profiles')
                .select(`
          role,
          role_permissions:roles!role(
            permissions:role_permissions(
              permission:permissions(*)
            )
          )
        `)
                .eq('id', userId)
                .single();
            // Combine permissions
            const allPermissions = [
                ...(directPermissions?.map((dp) => dp.permission) || []),
                ...(rolePermissions?.role_permissions?.map((rp) => rp.permission) || [])
            ];
            // Remove duplicates
            const uniquePermissions = allPermissions.filter((permission, index, self) => index === self.findIndex(p => p.id === permission.id));
            // Cache permissions
            this.permissionCache.set(cacheKey, uniquePermissions);
            setTimeout(() => {
                this.permissionCache.delete(cacheKey);
            }, this.cacheTimeout);
            return uniquePermissions;
        }
        catch (error) {
            this.logger.error('Failed to get user permissions', {
                userId,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
            return [];
        }
    }
    /**
     * Check if user can access organization data
     */
    async canAccessOrganization(context, organizationId) {
        if (!context.user) {
            return false;
        }
        // Super admin can access any organization
        if (context.user.role === types_1.UserRole.SUPER_ADMIN) {
            return true;
        }
        // User can access their own organization
        if (context.user.organizationId === organizationId) {
            return true;
        }
        // Check for cross-organization permissions
        return await this.hasPermission(context, {
            resource: 'organization',
            action: 'read',
            conditions: { organizationId }
        });
    }
    /**
     * Check if user can access user data
     */
    async canAccessUser(context, targetUserId) {
        if (!context.user) {
            return false;
        }
        // User can access their own data
        if (context.user.id === targetUserId) {
            return true;
        }
        // Check for user management permissions
        return await this.hasPermission(context, {
            resource: 'user',
            action: 'read',
            conditions: { userId: targetUserId }
        });
    }
    /**
     * Create a new role
     */
    async createRole(context, roleData) {
        await this.requirePermission(context, {
            resource: 'role',
            action: 'create'
        });
        try {
            const { data, error } = await this.supabase
                .from('roles')
                .insert([roleData])
                .select()
                .single();
            if (error || !data) {
                throw new Error('Failed to create role');
            }
            this.logger.info('Role created', {
                roleId: data.id,
                roleName: data.name,
                createdBy: context.user?.id
            });
            return data;
        }
        catch (error) {
            this.logger.error('Role creation failed', {
                roleName: roleData.name,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
            throw error;
        }
    }
    /**
     * Assign role to user
     */
    async assignRole(context, userId, roleId) {
        await this.requirePermission(context, {
            resource: 'user',
            action: 'update',
            conditions: { userId }
        });
        try {
            const { error } = await this.supabase
                .from('user_profiles')
                .update({ role: roleId })
                .eq('id', userId);
            if (error) {
                throw new Error('Failed to assign role');
            }
            // Clear permission cache
            this.permissionCache.delete(`user_permissions_${userId}`);
            this.logger.info('Role assigned', {
                userId,
                roleId,
                assignedBy: context.user?.id
            });
        }
        catch (error) {
            this.logger.error('Role assignment failed', {
                userId,
                roleId,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
            throw error;
        }
    }
    /**
     * Get role hierarchy for organization
     */
    async getRoleHierarchy(organizationId) {
        try {
            const { data, error } = await this.supabase
                .from('roles')
                .select(`
          *,
          permissions:role_permissions(
            permission:permissions(*)
          )
        `)
                .eq('organization_id', organizationId)
                .order('name');
            if (error) {
                throw new Error('Failed to get role hierarchy');
            }
            return (data || []);
        }
        catch (error) {
            this.logger.error('Failed to get role hierarchy', {
                organizationId,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
            throw error;
        }
    }
    // Private helper methods
    matchesConditions(permissionConditions, checkConditions) {
        if (!permissionConditions && !checkConditions) {
            return true;
        }
        if (!permissionConditions || !checkConditions) {
            return false;
        }
        // Simple condition matching - can be extended for complex conditions
        return Object.keys(checkConditions).every(key => permissionConditions[key] === checkConditions[key]);
    }
    async checkRolePermission(role, permissionCheck) {
        // Define default role permissions
        const rolePermissions = {
            [types_1.UserRole.SUPER_ADMIN]: [
                { resource: '*', action: '*' }
            ],
            [types_1.UserRole.ORG_ADMIN]: [
                { resource: 'organization', action: '*' },
                { resource: 'user', action: '*' },
                { resource: 'role', action: '*' },
                { resource: 'document', action: '*' }
            ],
            [types_1.UserRole.PARTNER]: [
                { resource: 'document', action: '*' },
                { resource: 'matter', action: '*' },
                { resource: 'client', action: '*' }
            ],
            [types_1.UserRole.SENIOR_ASSOCIATE]: [
                { resource: 'document', action: 'read' },
                { resource: 'document', action: 'write' },
                { resource: 'matter', action: 'read' },
                { resource: 'matter', action: 'write' }
            ],
            [types_1.UserRole.ASSOCIATE]: [
                { resource: 'document', action: 'read' },
                { resource: 'matter', action: 'read' }
            ],
            [types_1.UserRole.PARALEGAL]: [
                { resource: 'document', action: 'read' },
                { resource: 'matter', action: 'read' }
            ],
            [types_1.UserRole.CLIENT]: [
                { resource: 'document', action: 'read', conditions: { owner: true } },
                { resource: 'matter', action: 'read', conditions: { client: true } }
            ],
            [types_1.UserRole.GUEST]: []
        };
        const permissions = rolePermissions[role] || [];
        return permissions.some(permission => (permission.resource === '*' || permission.resource === permissionCheck.resource) &&
            (permission.action === '*' || permission.action === permissionCheck.action) &&
            this.matchesConditions(permission.conditions, permissionCheck.conditions));
    }
    async logPermissionDenied(context, permissionCheck) {
        await this.eventService.logEvent({
            id: '',
            type: types_1.SecurityEventType.PERMISSION_DENIED,
            userId: context.user?.id,
            organizationId: context.user?.organizationId || '',
            ipAddress: context.ipAddress,
            userAgent: context.userAgent,
            resource: permissionCheck.resource,
            action: permissionCheck.action,
            details: {
                resource: permissionCheck.resource,
                action: permissionCheck.action,
                conditions: permissionCheck.conditions
            },
            riskLevel: types_1.RiskLevel.MEDIUM,
            timestamp: new Date()
        });
    }
}
exports.AuthorizationService = AuthorizationService;
//# sourceMappingURL=authorization.service.js.map
"use strict";
// CourtLens Enterprise Audit Service
// Comprehensive audit logging for compliance and security monitoring with SOC 2 support
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnterpriseAuditService = void 0;
const logger_1 = require("../utils/logger");
const crypto_1 = __importDefault(require("crypto"));
const events_1 = require("events");
class EnterpriseAuditService extends events_1.EventEmitter {
    constructor() {
        super(); // Call EventEmitter constructor
        this.auditStore = new Map();
        this.retentionPolicies = new Map();
        this.alerts = new Map();
        this.violations = new Map();
        this.lastHash = '';
        this.logger = new logger_1.SecurityLogger('EnterpriseAuditService');
        this.config = this.getDefaultConfiguration();
        this.initializeRetentionPolicies();
        this.startRealTimeMonitoring();
    }
    /**
     * Initialize retention policies for different event types
     */
    initializeRetentionPolicies() {
        this.retentionPolicies.set('authentication', 2555); // 7 years for SOX
        this.retentionPolicies.set('authorization', 2555);
        this.retentionPolicies.set('data_access', 2555);
        this.retentionPolicies.set('configuration_change', 2555);
        this.retentionPolicies.set('user_management', 2555);
        this.retentionPolicies.set('system_event', 365); // 1 year
        this.retentionPolicies.set('security_incident', 3650); // 10 years
    }
    /**
     * Get default audit configuration
     */
    getDefaultConfiguration() {
        return {
            enableRealTimeMonitoring: true,
            enableTamperDetection: true,
            enableEncryption: true,
            retentionPolicies: {
                'authentication': 2555,
                'authorization': 2555,
                'data_access': 2555,
                'system_event': 365,
            },
            alertThresholds: {
                'failed_login_attempts': 5,
                'privilege_escalation': 1,
                'data_export': 1,
            },
            complianceStandards: ['soc2', 'gdpr', 'hipaa'],
            customRules: [],
        };
    }
    /**
     * Start real-time monitoring for audit events
     */
    startRealTimeMonitoring() {
        if (this.config.enableRealTimeMonitoring) {
            this.on('audit_event', (event) => {
                this.processRealTimeAlert(event);
            });
        }
    }
    /**
     * Process real-time alerts for audit events
     */
    async processRealTimeAlert(event) {
        // Check alert thresholds and generate alerts if needed
        const ruleViolations = this.checkRuleViolations(event);
        for (const violation of ruleViolations) {
            const alert = {
                id: crypto_1.default.randomUUID(),
                triggeredAt: new Date(),
                eventId: event.id,
                ruleId: violation.ruleId,
                severity: violation.severity,
                message: violation.message,
                details: { event, violation },
                status: 'new',
            };
            this.alerts.set(alert.id, alert);
            this.emit('security_alert', alert);
        }
    }
    /**
     * Check for rule violations in an audit event
     */
    checkRuleViolations(event) {
        const violations = [];
        // Example: Multiple failed login attempts
        if (event.action === 'login' && event.outcome === 'failure') {
            const recentFailures = Array.from(this.auditStore.values())
                .filter(e => e.userId === event.userId &&
                e.action === 'login' &&
                e.outcome === 'failure' &&
                (Date.now() - e.timestamp.getTime()) < 300000 // 5 minutes
            ).length;
            if (recentFailures >= 5) {
                violations.push({
                    ruleId: 'multiple_failed_logins',
                    severity: 'high',
                    message: `Multiple failed login attempts detected for user ${event.userId}`,
                });
            }
        }
        return violations;
    }
    /**
     * Log an audit event
     */
    async logEvent(event) {
        try {
            const auditEvent = {
                id: this.generateEventId(),
                timestamp: new Date(),
                retentionPeriod: this.getRetentionPeriod(event.action),
                ...event
            };
            // Store event
            this.auditStore.set(auditEvent.id, auditEvent);
            // Log for monitoring systems
            this.logger.info('Audit event logged', {
                eventId: auditEvent.id,
                action: auditEvent.action,
                outcome: auditEvent.outcome,
                severity: auditEvent.severity,
                userId: auditEvent.userId,
                organizationId: auditEvent.organizationId
            });
            // Check for critical events that need immediate attention
            if (auditEvent.severity === 'critical') {
                await this.handleCriticalEvent(auditEvent);
            }
            // Archive if needed
            await this.checkAndArchiveEvent(auditEvent);
        }
        catch (error) {
            this.logger.error('Failed to log audit event', {
                error: error instanceof Error ? error.message : 'Unknown error',
                action: event.action
            });
            throw error;
        }
    }
    /**
     * Generate compliance report
     */
    async generateComplianceReport(startDate, endDate, organizationId) {
        try {
            const events = Array.from(this.auditStore.values())
                .filter(event => {
                const inDateRange = event.timestamp >= startDate && event.timestamp <= endDate;
                const inOrg = !organizationId || event.organizationId === organizationId;
                return inDateRange && inOrg;
            });
            const summary = {
                totalEvents: events.length,
                criticalEvents: events.filter(e => e.severity === 'critical').length,
                failedAttempts: events.filter(e => e.outcome === 'failure').length,
                uniqueUsers: new Set(events.map(e => e.userId).filter(Boolean)).size,
                securityIncidents: events.filter(e => e.action.includes('security_incident')).length,
                dataAccess: events.filter(e => e.action.includes('data_access')).length,
                privilegedAccess: events.filter(e => e.action.includes('admin_') || e.action.includes('privileged_')).length
            };
            const violations = Array.from(this.violations.values()).filter(v => v.detectedAt >= startDate && v.detectedAt <= endDate);
            const compliance = {
                soc2Compliant: this.checkSOC2Compliance(events),
                gdprCompliant: this.checkGDPRCompliance(events),
                hipaaCompliant: this.checkHIPAACompliance(events),
                customChecks: await this.runCustomComplianceChecks(events),
                violations
            };
            const report = {
                reportId: this.generateReportId(),
                generatedAt: new Date(),
                generatedBy: 'system', // Could be passed as parameter
                reportType: 'soc2', // Could be passed as parameter
                period: { start: startDate, end: endDate },
                summary,
                compliance,
                events,
                digitalSignature: await this.generateDigitalSignature(events)
            };
            this.logger.info('Compliance report generated', {
                reportId: report.reportId,
                period: report.period,
                eventCount: events.length,
                organizationId
            });
            return report;
        }
        catch (error) {
            this.logger.error('Failed to generate compliance report', {
                error: error instanceof Error ? error.message : 'Unknown error',
                startDate,
                endDate,
                organizationId
            });
            throw error;
        }
    }
    /**
     * Search audit events with filtering
     */
    async searchEvents(criteria) {
        try {
            let events = Array.from(this.auditStore.values());
            // Apply filters
            if (criteria.userId) {
                events = events.filter(e => e.userId === criteria.userId);
            }
            if (criteria.organizationId) {
                events = events.filter(e => e.organizationId === criteria.organizationId);
            }
            if (criteria.action) {
                events = events.filter(e => e.action.includes(criteria.action));
            }
            if (criteria.resource) {
                events = events.filter(e => e.resource === criteria.resource);
            }
            if (criteria.outcome) {
                events = events.filter(e => e.outcome === criteria.outcome);
            }
            if (criteria.severity) {
                events = events.filter(e => e.severity === criteria.severity);
            }
            if (criteria.startDate) {
                events = events.filter(e => e.timestamp >= criteria.startDate);
            }
            if (criteria.endDate) {
                events = events.filter(e => e.timestamp <= criteria.endDate);
            }
            // Sort by timestamp (newest first)
            events.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
            // Apply pagination
            const offset = criteria.offset || 0;
            const limit = criteria.limit || 100;
            events = events.slice(offset, offset + limit);
            this.logger.info('Audit events searched', {
                criteria,
                resultCount: events.length
            });
            return events;
        }
        catch (error) {
            this.logger.error('Failed to search audit events', {
                error: error instanceof Error ? error.message : 'Unknown error',
                criteria
            });
            throw error;
        }
    }
    /**
     * Handle critical security events
     */
    async handleCriticalEvent(event) {
        // Alert security team
        this.logger.error('CRITICAL SECURITY EVENT', {
            eventId: event.id,
            action: event.action,
            userId: event.userId,
            details: event.details
        });
        // Here you would integrate with alerting systems
        // - Send to security team
        // - Trigger incident response
        // - Block suspicious IPs if needed
    }
    /**
     * Check and archive old events based on retention policy
     */
    async checkAndArchiveEvent(event) {
        // This would typically involve moving old events to long-term storage
        // For now, we'll just log when events should be archived
        const expiryDate = new Date(event.timestamp);
        expiryDate.setDate(expiryDate.getDate() + event.retentionPeriod);
        if (expiryDate < new Date()) {
            this.logger.info('Event ready for archival', {
                eventId: event.id,
                expiryDate
            });
        }
    }
    /**
     * Check access control compliance
     */
    checkAccessControl(events) {
        const accessEvents = events.filter(e => e.action.includes('access'));
        return accessEvents.every(e => e.outcome === 'success' || e.details.reasonForFailure);
    }
    checkIncidentResponse(events) {
        const securityEvents = events.filter(e => e.severity === 'critical');
        return securityEvents.every(e => e.details.responseTime && e.details.responseTime < 900); // 15 minutes
    }
    /**
     * Get retention period for event type
     */
    getRetentionPeriod(action) {
        for (const [type, period] of this.retentionPolicies) {
            if (action.includes(type)) {
                return period;
            }
        }
        return 365; // Default 1 year
    }
    /**
     * Generate unique event ID
     */
    generateEventId() {
        return `audit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    /**
     * Generate unique report ID
     */
    generateReportId() {
        return `report_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    /**
     * Check SOC 2 compliance
     */
    checkSOC2Compliance(events) {
        // Check for proper access controls, audit trails, and monitoring
        const hasAccessControls = events.some(e => e.action.includes('authorization'));
        const hasAuditTrails = events.length > 0;
        const hasSecurityMonitoring = events.some(e => e.action.includes('security'));
        return hasAccessControls && hasAuditTrails && hasSecurityMonitoring;
    }
    /**
     * Check GDPR compliance
     */
    checkGDPRCompliance(events) {
        // Check for data processing consent and data access controls
        const hasDataProcessingControls = events.some(e => e.complianceFlags.includes('gdpr'));
        const hasDataAccessLogs = events.some(e => e.action.includes('data_access'));
        return hasDataProcessingControls && hasDataAccessLogs;
    }
    /**
     * Check SOX compliance
     */
    checkSOXCompliance(events) {
        // Check for financial data access controls
        const hasFinancialControls = events.some(e => e.complianceFlags.includes('sox'));
        const hasChangeManagement = events.some(e => e.action.includes('configuration_change'));
        return hasFinancialControls && hasChangeManagement;
    }
    /**
     * Check HIPAA compliance
     */
    checkHIPAACompliance(events) {
        // Check for healthcare data protection measures
        const hasHealthcareControls = events.some(e => e.complianceFlags.includes('hipaa'));
        const hasDataEncryption = events.some(e => e.encrypted === true);
        return hasHealthcareControls && hasDataEncryption;
    }
    /**
     * Run custom compliance checks
     */
    async runCustomComplianceChecks(events) {
        const checks = {};
        // Example custom checks
        checks.allCriticalEventsLogged = events.filter(e => e.severity === 'critical').length > 0;
        checks.noUnauthorizedAccess = !events.some(e => e.outcome === 'denied' && e.severity === 'high');
        checks.properRetentionPeriods = events.every(e => e.retentionPeriod > 0);
        return checks;
    }
    /**
     * Generate digital signature for report integrity
     */
    async generateDigitalSignature(events) {
        const reportData = JSON.stringify(events.map(e => ({
            id: e.id,
            timestamp: e.timestamp,
            action: e.action,
            outcome: e.outcome,
        })));
        const hash = crypto_1.default.createHash('sha256').update(reportData).digest('hex');
        // In production, this would use proper digital signing with private keys
        return `sig_${hash.substring(0, 32)}`;
    }
    /**
     * Clean up expired events
     */
    async cleanupExpiredEvents() {
        const now = new Date();
        let cleanedCount = 0;
        for (const [eventId, event] of this.auditStore) {
            const expiryDate = new Date(event.timestamp);
            expiryDate.setDate(expiryDate.getDate() + event.retentionPeriod);
            if (expiryDate < now) {
                this.auditStore.delete(eventId);
                cleanedCount++;
            }
        }
        this.logger.info('Expired audit events cleaned up', {
            cleanedCount,
            remainingCount: this.auditStore.size
        });
        return cleanedCount;
    }
}
exports.EnterpriseAuditService = EnterpriseAuditService;
//# sourceMappingURL=enterprise-audit.service.js.map
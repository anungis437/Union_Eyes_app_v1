"use strict";
// CourtLens Authentication Service
// Comprehensive authentication with Supabase integration, MFA, and security hardening
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthenticationService = void 0;
const supabase_js_1 = require("@supabase/supabase-js");
const bcryptjs_1 = __importDefault(require("bcryptjs"));
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const speakeasy_1 = __importDefault(require("speakeasy"));
const qrcode_1 = __importDefault(require("qrcode"));
const uuid_1 = require("uuid");
const crypto_1 = __importDefault(require("crypto"));
const types_1 = require("../types");
const utils_1 = require("../utils");
const security_event_service_1 = require("./security-event.service");
class AuthenticationService {
    constructor(supabaseUrl, supabaseServiceKey, jwtSecret) {
        this.sessionStore = new Map();
        this.supabase = (0, supabase_js_1.createClient)(supabaseUrl, supabaseServiceKey);
        this.logger = new utils_1.SecurityLogger('AuthenticationService');
        this.validator = new utils_1.SecurityValidator();
        this.eventService = new security_event_service_1.SecurityEventService();
        this.jwtSecret = jwtSecret;
    }
    /**
     * Authenticate user with email and password
     */
    async login(credentials, context) {
        this.logger.info('Login attempt', { email: credentials.email });
        try {
            // Validate input
            this.validator.validateEmail(credentials.email);
            this.validator.validatePassword(credentials.password);
            // Check for suspicious activity
            await this.checkSuspiciousActivity(credentials.email, context.ipAddress);
            // Authenticate with Supabase
            const { data: authData, error: authError } = await this.supabase.auth.signInWithPassword({
                email: credentials.email,
                password: credentials.password
            });
            if (authError || !authData.user) {
                await this.logSecurityEvent({
                    type: types_1.SecurityEventType.LOGIN_FAILURE,
                    organizationId: '', // Will be filled if user exists
                    ipAddress: context.ipAddress || '',
                    userAgent: context.userAgent || '',
                    details: { email: credentials.email, reason: 'invalid_credentials' },
                    riskLevel: types_1.RiskLevel.MEDIUM
                });
                throw new types_1.AuthenticationError('Invalid credentials');
            }
            // Get user profile
            const user = await this.getUserProfile(authData.user.id);
            if (!user.isActive) {
                throw new types_1.AuthenticationError('Account is deactivated');
            }
            // Check MFA requirement
            if (user.mfaEnabled && !credentials.mfaToken) {
                throw new types_1.AuthenticationError('MFA token required', { requiresMfa: true });
            }
            if (user.mfaEnabled && credentials.mfaToken) {
                const mfaValid = await this.verifyMfaToken(user.id, credentials.mfaToken);
                if (!mfaValid) {
                    await this.logSecurityEvent({
                        type: types_1.SecurityEventType.LOGIN_FAILURE,
                        userId: user.id,
                        organizationId: user.organizationId,
                        ipAddress: context.ipAddress || '',
                        userAgent: context.userAgent || '',
                        details: { email: credentials.email, reason: 'invalid_mfa' },
                        riskLevel: types_1.RiskLevel.HIGH
                    });
                    throw new types_1.AuthenticationError('Invalid MFA token');
                }
            }
            // Generate JWT tokens
            const tokens = await this.generateTokens(user);
            // Create session
            const session = await this.createSession(user, context);
            // Update last login
            await this.updateLastLogin(user.id);
            // Log successful login
            await this.logSecurityEvent({
                type: types_1.SecurityEventType.LOGIN_SUCCESS,
                userId: user.id,
                organizationId: user.organizationId,
                ipAddress: context.ipAddress || '',
                userAgent: context.userAgent || '',
                details: { sessionId: session.sessionId },
                riskLevel: types_1.RiskLevel.LOW
            });
            this.logger.info('Login successful', { userId: user.id, email: user.email });
            return tokens;
        }
        catch (error) {
            this.logger.error('Login failed', {
                email: credentials.email,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
            throw error;
        }
    }
    /**
     * Register new user
     */
    async register(data, context) {
        this.logger.info('Registration attempt', { email: data.email });
        try {
            // Validate input
            this.validator.validateEmail(data.email);
            this.validator.validatePassword(data.password);
            this.validator.validateRequired(data.firstName, 'firstName');
            this.validator.validateRequired(data.lastName, 'lastName');
            this.validator.validateRequired(data.organizationId, 'organizationId');
            // Check if user already exists
            const existingUser = await this.findUserByEmail(data.email);
            if (existingUser) {
                throw new types_1.ValidationError('User already exists');
            }
            // Validate organization
            const organization = await this.getOrganization(data.organizationId);
            if (!organization || !organization.isActive) {
                throw new types_1.ValidationError('Invalid organization');
            }
            // Hash password
            const hashedPassword = await bcryptjs_1.default.hash(data.password, 12);
            // Create user in Supabase Auth
            const { data: authData, error: authError } = await this.supabase.auth.admin.createUser({
                email: data.email,
                password: data.password,
                email_confirm: false // We'll handle email confirmation separately
            });
            if (authError || !authData.user) {
                throw new types_1.AuthenticationError('Failed to create user account');
            }
            // Create user profile
            const userProfile = {
                email: data.email,
                firstName: data.firstName,
                lastName: data.lastName,
                role: data.role || types_1.UserRole.ASSOCIATE,
                organizationId: data.organizationId,
                isActive: true,
                emailVerified: false,
                mfaEnabled: false
            };
            const { data: profile, error: profileError } = await this.supabase
                .from('user_profiles')
                .insert([{ ...userProfile, id: authData.user.id }])
                .select()
                .single();
            if (profileError) {
                // Cleanup auth user if profile creation fails
                await this.supabase.auth.admin.deleteUser(authData.user.id);
                throw new types_1.AuthenticationError('Failed to create user profile');
            }
            // Send verification email
            await this.sendVerificationEmail(data.email);
            this.logger.info('User registered successfully', {
                userId: authData.user.id,
                email: data.email
            });
            return profile;
        }
        catch (error) {
            this.logger.error('Registration failed', {
                email: data.email,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
            throw error;
        }
    }
    /**
     * Setup Multi-Factor Authentication
     */
    async setupMfa(userId) {
        this.logger.info('MFA setup initiated', { userId });
        try {
            const user = await this.getUserProfile(userId);
            if (!user) {
                throw new types_1.AuthenticationError('User not found');
            }
            // Generate secret
            const secret = speakeasy_1.default.generateSecret({
                name: `CourtLens (${user.email})`,
                issuer: 'CourtLens',
                length: 32
            });
            // Generate QR code
            const qrCodeUrl = await qrcode_1.default.toDataURL(secret.otpauth_url);
            // Generate backup codes
            const backupCodes = Array.from({ length: 10 }, () => crypto_1.default.randomBytes(4).toString('hex').toUpperCase());
            // Store MFA secret (encrypted)
            await this.storeMfaSecret(userId, secret.base32, backupCodes);
            this.logger.info('MFA setup completed', { userId });
            return {
                secret: secret.base32,
                qrCodeUrl,
                backupCodes
            };
        }
        catch (error) {
            this.logger.error('MFA setup failed', {
                userId,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
            throw error;
        }
    }
    /**
     * Verify MFA token
     */
    async verifyMfaToken(userId, token) {
        try {
            const mfaSecret = await this.getMfaSecret(userId);
            if (!mfaSecret) {
                return false;
            }
            // Verify TOTP token
            const verified = speakeasy_1.default.totp.verify({
                secret: mfaSecret,
                encoding: 'base32',
                token: token,
                window: 2 // Allow 2 time steps before/after
            });
            if (verified) {
                this.logger.info('MFA token verified', { userId });
                return true;
            }
            // Check backup codes if TOTP fails
            const backupCodeValid = await this.verifyBackupCode(userId, token);
            if (backupCodeValid) {
                this.logger.info('MFA backup code verified', { userId });
                return true;
            }
            this.logger.warn('MFA token verification failed', { userId });
            return false;
        }
        catch (error) {
            this.logger.error('MFA verification error', {
                userId,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
            return false;
        }
    }
    /**
     * Refresh access token
     */
    async refreshToken(refreshToken) {
        try {
            const { data, error } = await this.supabase.auth.refreshSession({
                refresh_token: refreshToken
            });
            if (error || !data.session) {
                throw new types_1.AuthenticationError('Invalid refresh token');
            }
            const user = await this.getUserProfile(data.user.id);
            return await this.generateTokens(user);
        }
        catch (error) {
            this.logger.error('Token refresh failed', {
                error: error instanceof Error ? error.message : 'Unknown error'
            });
            throw error;
        }
    }
    /**
     * Logout user
     */
    async logout(sessionId, context) {
        try {
            const session = this.sessionStore.get(sessionId);
            if (session) {
                // Invalidate session
                session.isActive = false;
                this.sessionStore.set(sessionId, session);
                // Log logout event
                await this.logSecurityEvent({
                    type: types_1.SecurityEventType.LOGOUT,
                    userId: session.userId,
                    organizationId: session.organizationId,
                    ipAddress: context.ipAddress || '',
                    userAgent: context.userAgent || '',
                    details: { sessionId },
                    riskLevel: types_1.RiskLevel.LOW
                });
            }
            // Sign out from Supabase
            await this.supabase.auth.signOut();
            this.logger.info('User logged out', { sessionId });
        }
        catch (error) {
            this.logger.error('Logout failed', {
                sessionId,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
            throw error;
        }
    }
    /**
     * Validate JWT token and return user context
     */
    async validateToken(token) {
        try {
            const decoded = jsonwebtoken_1.default.verify(token, this.jwtSecret);
            const user = await this.getUserProfile(decoded.sub);
            if (!user || !user.isActive) {
                throw new types_1.AuthenticationError('Invalid token');
            }
            const session = this.sessionStore.get(decoded.sessionId);
            if (!session || !session.isActive || session.expiresAt < new Date()) {
                throw new types_1.AuthenticationError('Session expired');
            }
            // Update session activity
            session.lastActivity = new Date();
            this.sessionStore.set(decoded.sessionId, session);
            // Get user permissions
            const permissions = await this.getUserPermissions(user.id);
            return {
                user,
                session,
                permissions,
                ipAddress: session.ipAddress,
                userAgent: session.userAgent,
                requestId: (0, uuid_1.v4)(),
                timestamp: new Date()
            };
        }
        catch (error) {
            if (error instanceof jsonwebtoken_1.default.JsonWebTokenError) {
                throw new types_1.AuthenticationError('Invalid token');
            }
            throw error;
        }
    }
    // Private helper methods
    async getUserProfile(userId) {
        const { data, error } = await this.supabase
            .from('user_profiles')
            .select('*')
            .eq('id', userId)
            .single();
        if (error || !data) {
            throw new types_1.AuthenticationError('User not found');
        }
        return data;
    }
    async findUserByEmail(email) {
        const { data } = await this.supabase
            .from('user_profiles')
            .select('*')
            .eq('email', email)
            .single();
        return data;
    }
    async getOrganization(organizationId) {
        const { data } = await this.supabase
            .from('organizations')
            .select('*')
            .eq('id', organizationId)
            .single();
        return data;
    }
    async generateTokens(user) {
        const sessionId = (0, uuid_1.v4)();
        const now = Date.now();
        const expiresIn = 3600; // 1 hour
        const accessToken = jsonwebtoken_1.default.sign({
            sub: user.id,
            email: user.email,
            role: user.role,
            organizationId: user.organizationId,
            sessionId,
            iat: Math.floor(now / 1000),
            exp: Math.floor(now / 1000) + expiresIn
        }, this.jwtSecret);
        const refreshToken = jsonwebtoken_1.default.sign({
            sub: user.id,
            sessionId,
            type: 'refresh',
            iat: Math.floor(now / 1000),
            exp: Math.floor(now / 1000) + (30 * 24 * 3600) // 30 days
        }, this.jwtSecret);
        return {
            accessToken,
            refreshToken,
            tokenType: 'Bearer',
            expiresIn,
            scope: ['read', 'write']
        };
    }
    async createSession(user, context) {
        const session = {
            sessionId: (0, uuid_1.v4)(),
            userId: user.id,
            organizationId: user.organizationId,
            ipAddress: context.ipAddress || '',
            userAgent: context.userAgent || '',
            issuedAt: new Date(),
            expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours
            lastActivity: new Date(),
            isActive: true
        };
        this.sessionStore.set(session.sessionId, session);
        return session;
    }
    async updateLastLogin(userId) {
        await this.supabase
            .from('user_profiles')
            .update({ lastLogin: new Date().toISOString() })
            .eq('id', userId);
    }
    async storeMfaSecret(userId, secret, backupCodes) {
        // TODO: Implement encrypted storage of MFA secrets
        // This should use the encryption service to encrypt the secret before storage
    }
    async getMfaSecret(userId) {
        // TODO: Implement retrieval and decryption of MFA secrets
        return null;
    }
    async verifyBackupCode(userId, code) {
        // TODO: Implement backup code verification
        return false;
    }
    async getUserPermissions(userId) {
        // TODO: Implement permission retrieval
        return [];
    }
    async checkSuspiciousActivity(email, ipAddress) {
        // TODO: Implement suspicious activity detection
    }
    async sendVerificationEmail(email) {
        // TODO: Implement email verification
    }
    async logSecurityEvent(event) {
        await this.eventService.logEvent({
            ...event,
            id: (0, uuid_1.v4)(),
            timestamp: new Date()
        });
    }
}
exports.AuthenticationService = AuthenticationService;
//# sourceMappingURL=authentication.service.js.map
"use strict";
/**
 * Enterprise SSO Service
 * Single Sign-On integration with Azure AD, Okta, Google Workspace, and SAML providers
 * Note: In production, install: npm install passport passport-saml passport-oauth2 passport-openidconnect
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnterpriseSSOService = void 0;
// Mock passport dependencies for demo
class MockSamlStrategy {
    constructor(config, verify) { }
}
class MockOAuthStrategy {
    constructor(config, verify) { }
}
class MockOpenIDStrategy {
    constructor(config, verify) { }
}
const mockPassport = {
    use: (name, strategy) => { },
    authenticate: (strategy, options) => (req, res, next) => next(),
};
// Use mocks instead of real passport imports
const SamlStrategy = MockSamlStrategy;
const OAuthStrategy = MockOAuthStrategy;
const OpenIDStrategy = MockOpenIDStrategy;
const passport = mockPassport;
const crypto_1 = __importDefault(require("crypto"));
const logger_1 = require("../utils/logger");
class EnterpriseSSOService {
    constructor(auditService) {
        this.providers = new Map();
        this.activeSessions = new Map();
        this.metrics = new Map();
        this.logger = new logger_1.SecurityLogger('EnterpriseSSOService');
        this.auditService = auditService;
        this.initializePassportStrategies();
    }
    /**
     * Configure SSO provider
     */
    async configureProvider(provider) {
        const existingProvider = this.providers.get(provider.id);
        const ssoProvider = {
            ...provider,
            createdAt: existingProvider?.createdAt || new Date(),
            updatedAt: new Date(),
        };
        // Validate configuration
        await this.validateProviderConfig(ssoProvider);
        // Store provider configuration (encrypt sensitive data)
        const encryptedProvider = await this.encryptProviderSecrets(ssoProvider);
        this.providers.set(provider.id, encryptedProvider);
        // Configure Passport strategy
        await this.configurePassportStrategy(ssoProvider);
        // Initialize metrics
        if (!this.metrics.has(provider.id)) {
            this.metrics.set(provider.id, {
                providerId: provider.id,
                totalLogins: 0,
                successfulLogins: 0,
                failedLogins: 0,
                averageLoginTime: 0,
                lastUsed: new Date(),
                activeUsers: 0,
            });
        }
        await this.auditService.logEvent({
            action: 'sso_provider_configured',
            resource: 'sso_provider',
            resourceId: provider.id,
            userId: 'system',
            outcome: 'success',
            severity: 'medium',
            source: {
                ip: 'system',
                userAgent: 'system',
            },
            details: {
                providerId: provider.id,
                providerName: provider.name,
                providerType: provider.type,
                organizationId: provider.organizationId,
            },
            complianceFlags: ['security', 'sso'],
            searchableFields: ['action', 'resource', 'providerId'],
        });
        this.logger.info('SSO provider configured', { providerId: provider.id, type: provider.type });
    }
    /**
     * Initiate SSO login
     */
    async initiateLogin(request) {
        const provider = this.providers.get(request.providerId);
        if (!provider || !provider.isActive) {
            throw new Error(`SSO provider not found or inactive: ${request.providerId}`);
        }
        // Generate state parameter for security
        const state = this.generateStateParameter();
        // Store login request for callback validation
        await this.storeLoginRequest(state, request);
        // Generate authorization URL based on provider type
        const authUrl = await this.generateAuthorizationUrl(provider, state, request.returnUrl);
        await this.auditService.logEvent({
            action: 'sso_login_initiated',
            resource: 'sso_login',
            resourceId: request.providerId,
            userId: request.organizationId,
            outcome: 'success',
            severity: 'low',
            source: {
                ip: 'system',
                userAgent: 'system',
            },
            details: {
                providerId: request.providerId,
                force: request.force,
                organizationId: request.organizationId,
            },
            complianceFlags: ['security', 'sso'],
            searchableFields: ['action', 'resource', 'providerId'],
        });
        return authUrl;
    }
    /**
     * Handle SSO callback and complete authentication
     */
    async handleCallback(providerId, userProfile, state) {
        const startTime = Date.now();
        try {
            const provider = this.providers.get(providerId);
            if (!provider) {
                throw new Error(`SSO provider not found: ${providerId}`);
            }
            // Validate state parameter
            const loginRequest = await this.validateState(state);
            if (!loginRequest) {
                throw new Error('Invalid or expired state parameter');
            }
            // Map user attributes from provider response
            const mappedUser = await this.mapUserAttributes(userProfile, provider.userMapping);
            // Create or update user in local system
            const user = await this.createOrUpdateUser(mappedUser, provider.organizationId);
            // Create SSO session
            const session = await this.createSSOSession(user, provider, userProfile);
            // Update metrics
            await this.updateLoginMetrics(providerId, true, Date.now() - startTime);
            await this.auditService.logEvent({
                action: 'sso_login_success',
                resource: 'sso_login',
                resourceId: session.sessionId,
                userId: user.id,
                outcome: 'success',
                severity: 'low',
                source: {
                    ip: 'system',
                    userAgent: 'system',
                },
                details: {
                    providerId,
                    sessionId: session.sessionId,
                    loginTime: session.loginTime,
                    organizationId: provider.organizationId,
                },
                complianceFlags: ['security', 'sso'],
                searchableFields: ['action', 'resource', 'providerId'],
            });
            return {
                success: true,
                sessionId: session.sessionId,
                user,
                redirectUrl: loginRequest.returnUrl || '/dashboard',
            };
        }
        catch (error) {
            await this.updateLoginMetrics(providerId, false, Date.now() - startTime);
            await this.auditService.logEvent({
                action: 'sso_login_failed',
                resource: 'sso_login',
                resourceId: providerId,
                userId: 'unknown',
                outcome: 'failure',
                severity: 'medium',
                source: {
                    ip: 'system',
                    userAgent: 'system',
                },
                details: {
                    providerId,
                    error: error instanceof Error ? error.message : 'Unknown error',
                    organizationId: this.providers.get(providerId)?.organizationId,
                },
                complianceFlags: ['security', 'sso'],
                searchableFields: ['action', 'resource', 'providerId'],
            });
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Authentication failed',
            };
        }
    }
    /**
     * Logout from SSO session
     */
    async logout(sessionId) {
        const session = this.activeSessions.get(sessionId);
        if (session) {
            const provider = this.providers.get(session.providerId);
            // Mark session as inactive
            session.isActive = false;
            // Perform provider-specific logout if supported
            if (provider?.config.samlConfig?.logoutUrl) {
                // Generate SAML logout request
                await this.initiateSAMLLogout(session, provider);
            }
            this.activeSessions.delete(sessionId);
            await this.auditService.logEvent({
                action: 'sso_logout',
                resource: 'sso_session',
                resourceId: sessionId,
                userId: session.userId,
                outcome: 'success',
                severity: 'low',
                source: {
                    ip: 'system',
                    userAgent: 'system',
                },
                details: {
                    sessionId,
                    providerId: session.providerId,
                    duration: Date.now() - session.loginTime.getTime(),
                    organizationId: session.organizationId,
                },
                complianceFlags: ['security', 'sso'],
                searchableFields: ['action', 'resource', 'providerId'],
            });
        }
    }
    /**
     * Get active SSO sessions for organization
     */
    async getActiveSessions(organizationId) {
        return Array.from(this.activeSessions.values())
            .filter(session => session.organizationId === organizationId && session.isActive);
    }
    /**
     * Validate SSO token/session and return user info
     */
    async validateToken(authHeader) {
        // Extract session ID from Authorization header (Bearer token)
        const sessionId = authHeader.replace('Bearer ', '');
        const session = this.activeSessions.get(sessionId);
        if (!session || !session.isActive) {
            throw new Error('Invalid or expired SSO session');
        }
        // Check if session hasn't expired (default 8 hours)
        const sessionTimeout = 8 * 60 * 60 * 1000; // 8 hours in milliseconds
        const sessionAge = Date.now() - session.loginTime.getTime();
        if (sessionAge > sessionTimeout) {
            session.isActive = false;
            throw new Error('SSO session expired');
        }
        // Return user information from session
        return {
            id: session.userId,
            organizationId: session.organizationId,
            sessionId: session.sessionId,
            provider: session.providerId,
        };
    }
    /**
     * Get SSO provider metrics
     */
    async getProviderMetrics(providerId) {
        if (providerId) {
            const metrics = this.metrics.get(providerId);
            return metrics ? [metrics] : [];
        }
        return Array.from(this.metrics.values());
    }
    /**
     * Test SSO provider connection
     */
    async testProviderConnection(providerId) {
        const provider = this.providers.get(providerId);
        if (!provider) {
            throw new Error(`SSO provider not found: ${providerId}`);
        }
        try {
            // Perform connection test based on provider type
            switch (provider.type) {
                case 'saml':
                    return await this.testSAMLConnection(provider);
                case 'oauth2':
                    return await this.testOAuth2Connection(provider);
                case 'openid':
                    return await this.testOpenIDConnection(provider);
                default:
                    return false;
            }
        }
        catch (error) {
            this.logger.error('SSO provider connection test failed', {
                providerId,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
            return false;
        }
    }
    // Private helper methods
    initializePassportStrategies() {
        // Initialize base passport strategies
        // Specific strategies are configured per provider
    }
    async validateProviderConfig(provider) {
        switch (provider.type) {
            case 'saml':
                if (!provider.config.samlConfig?.entryPoint || !provider.config.samlConfig?.cert) {
                    throw new Error('SAML configuration missing required fields');
                }
                break;
            case 'oauth2':
                if (!provider.config.oauth2Config?.clientID || !provider.config.oauth2Config?.clientSecret) {
                    throw new Error('OAuth2 configuration missing required fields');
                }
                break;
            case 'openid':
                if (!provider.config.openidConfig?.issuer || !provider.config.openidConfig?.clientID) {
                    throw new Error('OpenID Connect configuration missing required fields');
                }
                break;
        }
    }
    async encryptProviderSecrets(provider) {
        // Encrypt sensitive configuration data
        const encryptedProvider = { ...provider };
        if (provider.config.oauth2Config?.clientSecret) {
            encryptedProvider.config.oauth2Config.clientSecret =
                this.encryptSecret(provider.config.oauth2Config.clientSecret);
        }
        if (provider.config.openidConfig?.clientSecret) {
            encryptedProvider.config.openidConfig.clientSecret =
                this.encryptSecret(provider.config.openidConfig.clientSecret);
        }
        return encryptedProvider;
    }
    encryptSecret(secret) {
        const key = process.env.SSO_ENCRYPTION_KEY || 'default-key';
        const cipher = crypto_1.default.createCipher('aes-256-cbc', key);
        let encrypted = cipher.update(secret, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        return encrypted;
    }
    async configurePassportStrategy(provider) {
        const strategyName = `sso-${provider.id}`;
        switch (provider.type) {
            case 'saml':
                if (provider.config.samlConfig) {
                    passport.use(strategyName, new SamlStrategy(provider.config.samlConfig, async (profile, done) => {
                        try {
                            const result = await this.handleCallback(provider.id, profile, '');
                            done(null, result.user);
                        }
                        catch (error) {
                            done(error);
                        }
                    }));
                }
                break;
            case 'oauth2':
                if (provider.config.oauth2Config) {
                    passport.use(strategyName, new OAuthStrategy(provider.config.oauth2Config, async (accessToken, refreshToken, profile, done) => {
                        try {
                            const result = await this.handleCallback(provider.id, profile, '');
                            done(null, result.user);
                        }
                        catch (error) {
                            done(error);
                        }
                    }));
                }
                break;
        }
    }
    generateStateParameter() {
        return crypto_1.default.randomBytes(32).toString('hex');
    }
    async storeLoginRequest(state, request) {
        // Store in Redis or memory with expiration
        // Implementation depends on storage choice
    }
    async generateAuthorizationUrl(provider, state, returnUrl) {
        switch (provider.type) {
            case 'saml':
                return `/auth/sso/${provider.id}/login`;
            case 'oauth2':
                const oauth2Config = provider.config.oauth2Config;
                const params = new URLSearchParams({
                    client_id: oauth2Config.clientID,
                    response_type: 'code',
                    scope: oauth2Config.scope.join(' '),
                    redirect_uri: oauth2Config.callbackURL,
                    state,
                });
                return `${oauth2Config.authorizationURL}?${params.toString()}`;
            default:
                throw new Error(`Unsupported provider type: ${provider.type}`);
        }
    }
    async validateState(state) {
        // Validate and retrieve stored login request
        // Implementation depends on storage choice
        return null; // Placeholder
    }
    async mapUserAttributes(userProfile, mapping) {
        return {
            email: this.getAttributeValue(userProfile, mapping.email),
            firstName: this.getAttributeValue(userProfile, mapping.firstName),
            lastName: this.getAttributeValue(userProfile, mapping.lastName),
            // Map additional attributes as needed
        };
    }
    getAttributeValue(profile, attributePath) {
        const keys = attributePath.split('.');
        let value = profile;
        for (const key of keys) {
            value = value?.[key];
        }
        return value || '';
    }
    async createOrUpdateUser(mappedUser, organizationId) {
        // Create or update user in local database
        // This would integrate with your user management system
        return mappedUser; // Placeholder
    }
    async createSSOSession(user, provider, userProfile) {
        const session = {
            sessionId: crypto_1.default.randomUUID(),
            userId: user.id,
            providerId: provider.id,
            providerType: provider.type,
            organizationId: provider.organizationId,
            loginTime: new Date(),
            lastActivity: new Date(),
            isActive: true,
            userAgent: 'unknown', // Get from request context
            ipAddress: 'unknown', // Get from request context
            attributes: userProfile,
        };
        this.activeSessions.set(session.sessionId, session);
        return session;
    }
    async updateLoginMetrics(providerId, success, duration) {
        const metrics = this.metrics.get(providerId);
        if (metrics) {
            metrics.totalLogins++;
            if (success) {
                metrics.successfulLogins++;
            }
            else {
                metrics.failedLogins++;
            }
            metrics.averageLoginTime =
                ((metrics.averageLoginTime * (metrics.totalLogins - 1)) + duration) / metrics.totalLogins;
            metrics.lastUsed = new Date();
        }
    }
    async initiateSAMLLogout(session, provider) {
        // Generate SAML logout request
        this.logger.info('Initiating SAML logout', { sessionId: session.sessionId });
    }
    async testSAMLConnection(provider) {
        // Test SAML metadata endpoint
        return true; // Placeholder
    }
    async testOAuth2Connection(provider) {
        // Test OAuth2 endpoints
        return true; // Placeholder
    }
    async testOpenIDConnection(provider) {
        // Test OpenID Connect discovery endpoint
        return true; // Placeholder
    }
}
exports.EnterpriseSSOService = EnterpriseSSOService;
//# sourceMappingURL=enterprise-sso.service.js.map
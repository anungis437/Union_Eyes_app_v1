"use strict";
// CourtLens Encryption Service
// Advanced encryption for sensitive legal data with key management
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EncryptionService = void 0;
const crypto_1 = __importDefault(require("crypto"));
const types_1 = require("../types");
const logger_1 = require("../utils/logger");
class EncryptionService {
    constructor() {
        this.keys = new Map();
        this.logger = new logger_1.SecurityLogger('EncryptionService');
        this.defaultConfig = {
            algorithm: 'aes-256-gcm',
            keySize: 32,
            ivSize: 16,
            saltSize: 32,
            iterations: 100000
        };
    }
    /**
     * Encrypt sensitive data
     */
    async encrypt(data, level = types_1.EncryptionLevel.STANDARD, keyId) {
        try {
            const config = this.getConfigForLevel(level);
            const key = keyId ? await this.getKey(keyId) : await this.generateKey(config);
            if (!key) {
                throw new types_1.EncryptionError('Encryption key not available');
            }
            const iv = crypto_1.default.randomBytes(config.ivSize);
            const salt = crypto_1.default.randomBytes(config.saltSize);
            // Derive key using PBKDF2
            const derivedKey = crypto_1.default.pbkdf2Sync(key.key, salt, config.iterations, config.keySize, 'sha256');
            // Encrypt data
            const cipher = crypto_1.default.createCipheriv(config.algorithm, derivedKey, iv);
            cipher.setAutoPadding(true);
            let encrypted = cipher.update(data, 'utf8', 'hex');
            encrypted += cipher.final('hex');
            // Get authentication tag for GCM mode
            let authTag = '';
            if (config.algorithm.includes('gcm') && cipher.getAuthTag) {
                authTag = cipher.getAuthTag().toString('hex');
            }
            const result = {
                data: encrypted + (authTag ? ':' + authTag : ''),
                iv: iv.toString('hex'),
                salt: salt.toString('hex'),
                algorithm: config.algorithm,
                keyId: key.id,
                level: level
            };
            this.logger.info('Data encrypted', {
                keyId: key.id,
                algorithm: config.algorithm,
                level
            });
            return result;
        }
        catch (error) {
            this.logger.error('Encryption failed', {
                error: error instanceof Error ? error.message : 'Unknown error',
                level
            });
            throw new types_1.EncryptionError('Failed to encrypt data');
        }
    }
    /**
     * Decrypt encrypted data
     */
    async decrypt(encryptedData) {
        try {
            const key = await this.getKey(encryptedData.keyId);
            if (!key) {
                throw new types_1.EncryptionError('Decryption key not found');
            }
            const config = encryptedData.level
                ? this.getConfigForLevel(encryptedData.level)
                : this.getConfigForAlgorithm(encryptedData.algorithm);
            const iv = Buffer.from(encryptedData.iv, 'hex');
            const salt = Buffer.from(encryptedData.salt, 'hex');
            // Derive the same key used for encryption
            const derivedKey = crypto_1.default.pbkdf2Sync(key.key, salt, config.iterations, config.keySize, 'sha256');
            // Split data and auth tag for GCM mode
            const parts = encryptedData.data.split(':');
            const encrypted = parts[0];
            const authTag = parts[1] ? Buffer.from(parts[1], 'hex') : null;
            // Decrypt data
            const decipher = crypto_1.default.createDecipheriv(encryptedData.algorithm, derivedKey, iv);
            if (authTag && encryptedData.algorithm.includes('gcm') && decipher.setAuthTag) {
                decipher.setAuthTag(authTag);
            }
            let decrypted = decipher.update(encrypted, 'hex', 'utf8');
            decrypted += decipher.final('utf8');
            this.logger.info('Data decrypted', {
                keyId: encryptedData.keyId,
                algorithm: encryptedData.algorithm
            });
            return decrypted;
        }
        catch (error) {
            this.logger.error('Decryption failed', {
                error: error instanceof Error ? error.message : 'Unknown error',
                keyId: encryptedData.keyId,
                algorithm: encryptedData.algorithm,
                stack: error instanceof Error ? error.stack : undefined
            });
            throw new types_1.EncryptionError('Failed to decrypt data');
        }
    }
    /**
     * Encrypt file data
     */
    async encryptFile(fileBuffer, level = types_1.EncryptionLevel.STANDARD) {
        const base64Data = fileBuffer.toString('base64');
        return await this.encrypt(base64Data, level);
    }
    /**
     * Decrypt file data
     */
    async decryptFile(encryptedData) {
        const decryptedBase64 = await this.decrypt(encryptedData);
        return Buffer.from(decryptedBase64, 'base64');
    }
    /**
     * Hash sensitive data (one-way)
     */
    hash(data, salt) {
        const actualSalt = salt || crypto_1.default.randomBytes(16).toString('hex');
        const hash = crypto_1.default.createHash('sha256');
        hash.update(data + actualSalt);
        return hash.digest('hex') + ':' + actualSalt;
    }
    /**
     * Verify hashed data
     */
    verifyHash(data, hashedData) {
        const [hash, salt] = hashedData.split(':');
        const newHash = this.hash(data, salt);
        return newHash === hashedData;
    }
    /**
     * Generate secure random token
     */
    generateToken(length = 32) {
        return crypto_1.default.randomBytes(length).toString('hex');
    }
    /**
     * Generate secure password
     */
    generateSecurePassword(length = 16) {
        // Ensure minimum length for complexity requirements
        if (length < 8)
            length = 8;
        const lowercase = 'abcdefghijklmnopqrstuvwxyz';
        const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const numbers = '0123456789';
        const special = '!@#$%^&*';
        const allChars = lowercase + uppercase + numbers + special;
        let password = '';
        // Ensure at least one character from each required category
        password += lowercase[crypto_1.default.randomInt(0, lowercase.length)];
        password += uppercase[crypto_1.default.randomInt(0, uppercase.length)];
        password += numbers[crypto_1.default.randomInt(0, numbers.length)];
        password += special[crypto_1.default.randomInt(0, special.length)];
        // Fill the rest with random characters from all categories
        for (let i = 4; i < length; i++) {
            password += allChars[crypto_1.default.randomInt(0, allChars.length)];
        }
        // Shuffle the password to avoid predictable patterns
        const passwordArray = password.split('');
        for (let i = passwordArray.length - 1; i > 0; i--) {
            const j = crypto_1.default.randomInt(0, i + 1);
            [passwordArray[i], passwordArray[j]] = [passwordArray[j], passwordArray[i]];
        }
        return passwordArray.join('');
    }
    /**
     * Generate encryption key
     */
    async generateKey(config) {
        const keyId = crypto_1.default.randomUUID();
        const key = crypto_1.default.randomBytes(config.keySize).toString('hex');
        const encryptionKey = {
            id: keyId,
            algorithm: config.algorithm,
            key,
            createdAt: new Date(),
            isActive: true
        };
        // Store key (in production, use secure key management service)
        this.keys.set(keyId, encryptionKey);
        this.logger.info('Encryption key generated', {
            keyId,
            algorithm: config.algorithm
        });
        return encryptionKey;
    }
    /**
     * Get encryption key by ID
     */
    async getKey(keyId) {
        const key = this.keys.get(keyId);
        if (!key) {
            this.logger.warn('Encryption key not found', { keyId });
            return null;
        }
        if (!key.isActive) {
            this.logger.warn('Encryption key is inactive', { keyId });
            return null;
        }
        if (key.expiresAt && key.expiresAt < new Date()) {
            this.logger.warn('Encryption key has expired', { keyId });
            return null;
        }
        return key;
    }
    /**
     * Get encryption configuration for security level
     */
    getConfigForLevel(level) {
        switch (level) {
            case types_1.EncryptionLevel.STANDARD:
                return {
                    algorithm: 'aes-256-cbc',
                    keySize: 32,
                    ivSize: 16,
                    saltSize: 16,
                    iterations: 10000
                };
            case types_1.EncryptionLevel.ENHANCED:
                return {
                    algorithm: 'aes-256-gcm',
                    keySize: 32,
                    ivSize: 16,
                    saltSize: 32,
                    iterations: 50000
                };
            case types_1.EncryptionLevel.MAXIMUM:
                return {
                    algorithm: 'aes-256-gcm',
                    keySize: 32,
                    ivSize: 16,
                    saltSize: 64,
                    iterations: 100000
                };
            default:
                return this.defaultConfig;
        }
    }
    /**
     * Get configuration for specific algorithm
     */
    getConfigForAlgorithm(algorithm) {
        // Find the correct configuration based on algorithm
        if (algorithm === 'aes-256-cbc') {
            return this.getConfigForLevel(types_1.EncryptionLevel.STANDARD);
        }
        else if (algorithm === 'aes-256-gcm') {
            // Try to determine if it's enhanced or maximum based on context
            // For now, return enhanced as it's more commonly used
            return this.getConfigForLevel(types_1.EncryptionLevel.ENHANCED);
        }
        return this.defaultConfig;
    }
    /**
     * Rotate encryption keys
     */
    async rotateKeys() {
        this.logger.info('Starting key rotation');
        // Mark old keys as inactive
        for (const [keyId, key] of this.keys.entries()) {
            if (key.isActive) {
                key.isActive = false;
                key.expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days
                this.keys.set(keyId, key);
            }
        }
        this.logger.info('Key rotation completed');
    }
    /**
     * Clean up expired keys
     */
    async cleanupExpiredKeys() {
        const now = new Date();
        let cleanedCount = 0;
        for (const [keyId, key] of this.keys.entries()) {
            if (key.expiresAt && key.expiresAt < now) {
                this.keys.delete(keyId);
                cleanedCount++;
            }
        }
        this.logger.info('Cleaned up expired keys', { count: cleanedCount });
    }
}
exports.EncryptionService = EncryptionService;
//# sourceMappingURL=encryption.service.js.map
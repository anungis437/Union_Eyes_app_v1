"use strict";
/**
 * Enterprise Multi-Factor Authentication Service
 * Advanced MFA with multiple authentication factors and risk-based authentication
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnterpriseMFAService = void 0;
const speakeasy_1 = __importDefault(require("speakeasy"));
const qrcode_1 = __importDefault(require("qrcode"));
const crypto_1 = __importDefault(require("crypto"));
const logger_1 = require("../utils/logger");
class EnterpriseMFAService {
    constructor(auditService) {
        this.providers = new Map();
        this.activeChallenges = new Map();
        this.userSettings = new Map();
        this.logger = new logger_1.SecurityLogger('EnterpriseMFAService');
        this.auditService = auditService;
        this.initializeDefaultProviders();
        this.startCleanupTimer();
    }
    /**
     * Configure MFA provider
     */
    async configureProvider(provider) {
        // Encrypt sensitive configuration
        const encryptedProvider = await this.encryptProviderConfig(provider);
        this.providers.set(provider.id, encryptedProvider);
        await this.auditService.logEvent({
            action: 'mfa_provider_configured',
            resource: 'mfa_provider',
            resourceId: provider.id,
            outcome: 'success',
            severity: 'medium',
            source: {
                ip: '127.0.0.1', // Would be actual IP in real implementation
                userAgent: 'system',
            },
            details: {
                providerId: provider.id,
                providerType: provider.type,
                isActive: provider.isActive,
            },
            complianceFlags: ['security', 'soc2'],
            searchableFields: ['action', 'resource', 'providerId'],
        });
        this.logger.info('MFA provider configured', {
            providerId: provider.id,
            type: provider.type
        });
    }
    /**
     * Enroll user in MFA provider
     */
    async enrollUser(userId, providerId, enrollmentData) {
        const provider = this.providers.get(providerId);
        if (!provider || !provider.isActive) {
            throw new Error(`MFA provider not found or inactive: ${providerId}`);
        }
        let userSettings = this.userSettings.get(userId);
        if (!userSettings) {
            userSettings = {
                userId,
                primaryProviderId: providerId,
                backupProviderIds: [],
                isEnabled: false,
                enrolledProviders: [],
                riskLevel: 'low',
                lastUsed: new Date(),
                trustedDevices: [],
            };
        }
        const result = {};
        switch (provider.type) {
            case 'totp':
                const totpResult = await this.enrollTOTP(userId, provider);
                result.secret = totpResult.secret;
                result.qrCode = totpResult.qrCode;
                result.backupCodes = totpResult.backupCodes;
                break;
            case 'sms':
                await this.enrollSMS(userId, provider, enrollmentData.phoneNumber);
                break;
            case 'email':
                await this.enrollEmail(userId, provider, enrollmentData.email);
                break;
            case 'push':
                await this.enrollPush(userId, provider, enrollmentData.deviceId);
                break;
            case 'hardware_token':
                await this.enrollHardwareToken(userId, provider, enrollmentData);
                break;
            case 'biometric':
                await this.enrollBiometric(userId, provider, enrollmentData);
                break;
        }
        // Add enrollment to user settings
        const enrollment = {
            providerId,
            enrolledAt: new Date(),
            isActive: true,
            metadata: enrollmentData,
            ...result,
        };
        userSettings.enrolledProviders.push(enrollment);
        if (!userSettings.isEnabled) {
            userSettings.isEnabled = true;
        }
        this.userSettings.set(userId, userSettings);
        await this.auditService.logEvent({
            action: 'mfa_user_enrolled',
            resource: 'user_mfa',
            resourceId: userId,
            userId,
            outcome: 'success',
            severity: 'medium',
            source: {
                ip: '127.0.0.1', // Would be actual IP in real implementation
                userAgent: 'system',
            },
            details: {
                providerId,
                providerType: provider.type,
                enrollmentMethod: provider.type,
            },
            complianceFlags: ['security', 'authentication'],
            searchableFields: ['action', 'resource', 'userId', 'providerId'],
        });
        return result;
    }
    /**
     * Initiate MFA challenge with risk assessment
     */
    async initiateChallenge(userId, sessionId, context) {
        const userSettings = this.userSettings.get(userId);
        if (!userSettings || !userSettings.isEnabled) {
            throw new Error('MFA not enabled for user');
        }
        // Perform risk assessment
        const riskAssessment = await this.assessRisk(userId, sessionId, context);
        // Determine required MFA providers based on risk
        const requiredProviders = this.selectProvidersForRisk(userSettings, riskAssessment);
        // Check for trusted device
        const isTrustedDevice = this.isTrustedDevice(userId, context.deviceFingerprint);
        if (isTrustedDevice && riskAssessment.riskLevel === 'low') {
            // Skip MFA for trusted device with low risk
            return {
                challengeId: 'trusted_device',
                providers: [],
                riskAssessment,
            };
        }
        // Create challenge
        const challengeId = this.generateChallengeId();
        const challenge = {
            challengeId,
            userId,
            providerId: requiredProviders[0], // Primary provider
            providerType: this.providers.get(requiredProviders[0])?.type || 'unknown',
            createdAt: new Date(),
            expiresAt: new Date(Date.now() + 300000), // 5 minutes
            attempts: 0,
            maxAttempts: 3,
            isActive: true,
            metadata: { context, riskAssessment, requiredProviders },
        };
        this.activeChallenges.set(challengeId, challenge);
        // Send challenge to user
        await this.sendChallenge(challenge, requiredProviders[0]);
        await this.auditService.logEvent({
            action: 'mfa_challenge_initiated',
            resource: 'mfa_challenge',
            resourceId: challengeId,
            userId,
            outcome: 'success',
            severity: 'low',
            source: {
                ip: '127.0.0.1', // Would be actual IP in real implementation
                userAgent: 'system',
            },
            details: {
                challengeId,
                providers: requiredProviders,
                riskLevel: riskAssessment.riskLevel,
                riskScore: riskAssessment.riskScore,
            },
            complianceFlags: ['security', 'authentication'],
            searchableFields: ['action', 'resource', 'userId', 'challengeId'],
        });
        return {
            challengeId,
            providers: requiredProviders,
            riskAssessment,
        };
    }
    /**
     * Verify MFA challenge response
     */
    async verifyChallenge(challengeId, code, additionalData) {
        const challenge = this.activeChallenges.get(challengeId);
        if (!challenge || !challenge.isActive) {
            return {
                success: false,
                challengeId,
                providerId: '',
                error: 'Invalid or expired challenge',
            };
        }
        if (challenge.expiresAt < new Date()) {
            challenge.isActive = false;
            return {
                success: false,
                challengeId,
                providerId: challenge.providerId,
                error: 'Challenge expired',
            };
        }
        if (challenge.attempts >= challenge.maxAttempts) {
            challenge.isActive = false;
            return {
                success: false,
                challengeId,
                providerId: challenge.providerId,
                error: 'Maximum attempts exceeded',
            };
        }
        challenge.attempts++;
        const provider = this.providers.get(challenge.providerId);
        if (!provider) {
            return {
                success: false,
                challengeId,
                providerId: challenge.providerId,
                error: 'Provider not found',
            };
        }
        // Verify code based on provider type
        const verified = await this.verifyChallengeCode(challenge, provider, code, additionalData);
        const result = {
            success: verified,
            challengeId,
            providerId: challenge.providerId,
            remainingAttempts: challenge.maxAttempts - challenge.attempts,
        };
        if (verified) {
            challenge.isActive = false;
            // Update user's last used time
            const userSettings = this.userSettings.get(challenge.userId);
            if (userSettings) {
                userSettings.lastUsed = new Date();
            }
            await this.auditService.logEvent({
                action: 'mfa_challenge_verified',
                resource: 'mfa_challenge',
                resourceId: challengeId,
                userId: challenge.userId,
                outcome: 'success',
                severity: 'low',
                source: {
                    ip: '127.0.0.1', // Would be actual IP in real implementation
                    userAgent: 'system',
                },
                details: {
                    challengeId,
                    providerId: challenge.providerId,
                    attempts: challenge.attempts,
                },
                complianceFlags: ['security', 'authentication'],
                searchableFields: ['action', 'resource', 'userId', 'challengeId', 'providerId'],
            });
        }
        else {
            await this.auditService.logEvent({
                action: 'mfa_challenge_failed',
                resource: 'mfa_challenge',
                resourceId: challengeId,
                userId: challenge.userId,
                outcome: 'failure',
                severity: 'medium',
                source: {
                    ip: '127.0.0.1', // Would be actual IP in real implementation
                    userAgent: 'system',
                },
                details: {
                    challengeId,
                    providerId: challenge.providerId,
                    attempts: challenge.attempts,
                    remainingAttempts: result.remainingAttempts,
                },
                complianceFlags: ['security', 'authentication'],
                searchableFields: ['action', 'resource', 'userId', 'challengeId'],
            });
        }
        return result;
    }
    /**
     * Add trusted device
     */
    async addTrustedDevice(userId, deviceData) {
        const userSettings = this.userSettings.get(userId);
        if (!userSettings) {
            throw new Error('User MFA settings not found');
        }
        const trustedDevice = {
            deviceId: crypto_1.default.randomUUID(),
            deviceName: deviceData.deviceName,
            fingerprint: deviceData.fingerprint,
            trustedAt: new Date(),
            expiresAt: new Date(Date.now() + (deviceData.expiryDays || 30) * 24 * 60 * 60 * 1000),
            lastUsed: new Date(),
            ipAddress: deviceData.ipAddress,
            userAgent: deviceData.userAgent,
        };
        userSettings.trustedDevices.push(trustedDevice);
        this.userSettings.set(userId, userSettings);
        await this.auditService.logEvent({
            action: 'mfa_trusted_device_added',
            resource: 'trusted_device',
            resourceId: trustedDevice.deviceId,
            userId,
            outcome: 'success',
            severity: 'medium',
            source: {
                ip: '127.0.0.1', // Would be actual IP in real implementation
                userAgent: 'system',
            },
            details: {
                deviceId: trustedDevice.deviceId,
                deviceName: trustedDevice.deviceName,
                expiresAt: trustedDevice.expiresAt,
            },
            complianceFlags: ['security', 'authentication'],
            searchableFields: ['action', 'resource', 'userId', 'deviceId'],
        });
    }
    // Private helper methods
    initializeDefaultProviders() {
        // TOTP Provider
        this.providers.set('totp-default', {
            id: 'totp-default',
            name: 'Authenticator App',
            type: 'totp',
            isActive: true,
            priority: 1,
            config: {
                totpConfig: {
                    issuer: 'CourtLens',
                    algorithm: 'sha256',
                    digits: 6,
                    period: 30,
                    window: 1,
                },
            },
        });
        // SMS Provider
        this.providers.set('sms-default', {
            id: 'sms-default',
            name: 'SMS Code',
            type: 'sms',
            isActive: true,
            priority: 2,
            config: {
                smsConfig: {
                    provider: 'twilio',
                    codeLength: 6,
                    expiryMinutes: 5,
                    template: 'Your CourtLens verification code is: {code}',
                },
            },
        });
    }
    async encryptProviderConfig(provider) {
        // Encrypt sensitive configuration data
        return { ...provider }; // Simplified for now
    }
    async enrollTOTP(userId, provider) {
        const totpConfig = provider.config.totpConfig;
        const secret = speakeasy_1.default.generateSecret({
            name: `CourtLens (${userId})`,
            issuer: totpConfig.issuer,
            length: 32,
        });
        const qrCode = await qrcode_1.default.toDataURL(secret.otpauth_url);
        // Generate backup codes
        const backupCodes = Array.from({ length: 10 }, () => Math.random().toString(36).substring(2, 8).toUpperCase());
        return {
            secret: secret.base32,
            qrCode,
            backupCodes,
        };
    }
    async enrollSMS(userId, provider, phoneNumber) {
        // Validate phone number and send test SMS
        this.logger.info('SMS MFA enrolled', { userId, phoneNumber });
    }
    async enrollEmail(userId, provider, email) {
        // Validate email and send test email
        this.logger.info('Email MFA enrolled', { userId, email });
    }
    async enrollPush(userId, provider, deviceId) {
        // Register device for push notifications
        this.logger.info('Push MFA enrolled', { userId, deviceId });
    }
    async enrollHardwareToken(userId, provider, enrollmentData) {
        // Register hardware token
        this.logger.info('Hardware token MFA enrolled', { userId, enrollmentData });
    }
    async enrollBiometric(userId, provider, enrollmentData) {
        // Register biometric data
        this.logger.info('Biometric MFA enrolled', { userId, enrollmentData });
    }
    async assessRisk(userId, sessionId, context) {
        const factors = [];
        let riskScore = 0;
        // Location-based risk
        if (context.location) {
            const isNewLocation = true; // Check against user's typical locations
            if (isNewLocation) {
                factors.push({
                    type: 'location',
                    severity: 'medium',
                    description: 'Login from new location',
                    value: context.location,
                    weight: 20,
                });
                riskScore += 20;
            }
        }
        // Device-based risk
        if (context.deviceFingerprint) {
            const isNewDevice = !this.isTrustedDevice(userId, context.deviceFingerprint);
            if (isNewDevice) {
                factors.push({
                    type: 'device',
                    severity: 'high',
                    description: 'Login from new device',
                    value: context.deviceFingerprint,
                    weight: 30,
                });
                riskScore += 30;
            }
        }
        // Time-based risk
        const currentHour = new Date().getHours();
        if (currentHour < 6 || currentHour > 22) {
            factors.push({
                type: 'time',
                severity: 'low',
                description: 'Login outside normal hours',
                value: currentHour,
                weight: 10,
            });
            riskScore += 10;
        }
        const riskLevel = riskScore < 20 ? 'low' :
            riskScore < 50 ? 'medium' :
                riskScore < 80 ? 'high' : 'critical';
        return {
            userId,
            sessionId,
            riskScore,
            riskLevel,
            factors,
            recommendedMFA: this.getRecommendedMFAForRisk(riskLevel),
            requireAdditionalVerification: riskLevel === 'high' || riskLevel === 'critical',
            calculatedAt: new Date(),
        };
    }
    selectProvidersForRisk(userSettings, riskAssessment) {
        const activeProviders = userSettings.enrolledProviders
            .filter(e => e.isActive)
            .map(e => e.providerId);
        switch (riskAssessment.riskLevel) {
            case 'low':
                return [userSettings.primaryProviderId].filter(id => activeProviders.includes(id));
            case 'medium':
                return [userSettings.primaryProviderId, ...userSettings.backupProviderIds.slice(0, 1)]
                    .filter(id => activeProviders.includes(id));
            case 'high':
            case 'critical':
                return [userSettings.primaryProviderId, ...userSettings.backupProviderIds]
                    .filter(id => activeProviders.includes(id));
            default:
                return [userSettings.primaryProviderId];
        }
    }
    getRecommendedMFAForRisk(riskLevel) {
        switch (riskLevel) {
            case 'low':
                return ['totp-default'];
            case 'medium':
                return ['totp-default', 'sms-default'];
            case 'high':
                return ['totp-default', 'sms-default', 'push-default'];
            case 'critical':
                return ['hardware_token', 'biometric', 'totp-default'];
            default:
                return ['totp-default'];
        }
    }
    isTrustedDevice(userId, deviceFingerprint) {
        if (!deviceFingerprint)
            return false;
        const userSettings = this.userSettings.get(userId);
        if (!userSettings)
            return false;
        return userSettings.trustedDevices.some(device => device.fingerprint === deviceFingerprint &&
            device.expiresAt > new Date());
    }
    generateChallengeId() {
        return `mfa_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    async sendChallenge(challenge, providerId) {
        const provider = this.providers.get(providerId);
        if (!provider)
            return;
        switch (provider.type) {
            case 'totp':
                // TOTP doesn't require sending, user uses their app
                break;
            case 'sms':
                await this.sendSMSCode(challenge);
                break;
            case 'email':
                await this.sendEmailCode(challenge);
                break;
            case 'push':
                await this.sendPushNotification(challenge);
                break;
        }
    }
    async sendSMSCode(challenge) {
        // Generate and send SMS code
        const code = Math.floor(100000 + Math.random() * 900000).toString();
        challenge.metadata.code = code;
        this.logger.info('SMS code sent', { challengeId: challenge.challengeId });
    }
    async sendEmailCode(challenge) {
        // Generate and send email code
        const code = Math.floor(100000 + Math.random() * 900000).toString();
        challenge.metadata.code = code;
        this.logger.info('Email code sent', { challengeId: challenge.challengeId });
    }
    async sendPushNotification(challenge) {
        // Send push notification
        this.logger.info('Push notification sent', { challengeId: challenge.challengeId });
    }
    async verifyChallengeCode(challenge, provider, code, additionalData) {
        switch (provider.type) {
            case 'totp':
                return this.verifyTOTPCode(challenge, provider, code);
            case 'sms':
            case 'email':
                return challenge.metadata.code === code;
            case 'push':
                return additionalData?.approved === true;
            case 'hardware_token':
                return this.verifyHardwareToken(challenge, provider, code);
            case 'biometric':
                return this.verifyBiometric(challenge, provider, additionalData);
            default:
                return false;
        }
    }
    verifyTOTPCode(challenge, provider, code) {
        const userSettings = this.userSettings.get(challenge.userId);
        if (!userSettings)
            return false;
        const enrollment = userSettings.enrolledProviders.find(e => e.providerId === provider.id);
        if (!enrollment?.secret)
            return false;
        const totpConfig = provider.config.totpConfig;
        return speakeasy_1.default.totp.verify({
            secret: enrollment.secret,
            encoding: 'base32',
            token: code,
            window: totpConfig.window,
            step: totpConfig.period,
        });
    }
    verifyHardwareToken(challenge, provider, code) {
        // Verify hardware token code
        return true; // Simplified
    }
    verifyBiometric(challenge, provider, additionalData) {
        // Verify biometric data
        return additionalData?.biometricVerified === true;
    }
    startCleanupTimer() {
        setInterval(() => {
            const now = new Date();
            // Clean up expired challenges
            for (const [challengeId, challenge] of this.activeChallenges) {
                if (challenge.expiresAt < now) {
                    this.activeChallenges.delete(challengeId);
                }
            }
            // Clean up expired trusted devices
            for (const [userId, userSettings] of this.userSettings) {
                userSettings.trustedDevices = userSettings.trustedDevices.filter(device => device.expiresAt > now);
            }
        }, 60000); // Every minute
    }
}
exports.EnterpriseMFAService = EnterpriseMFAService;
//# sourceMappingURL=enterprise-mfa.service.js.map
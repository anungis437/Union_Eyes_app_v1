"use strict";
// CourtLens Security Middleware
// Express middleware for authentication, authorization, and security headers
// Enhanced with enterprise SSO, MFA, RBAC, and comprehensive audit logging
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidationSchemas = exports.SecurityMiddleware = void 0;
const helmet_1 = __importDefault(require("helmet"));
const express_rate_limit_1 = __importDefault(require("express-rate-limit"));
const express_validator_1 = require("express-validator");
const index_1 = require("../types/index");
const enterprise_security_middleware_1 = require("./enterprise-security.middleware");
const logger_1 = require("../utils/logger");
class SecurityMiddleware {
    constructor(config) {
        this.config = config;
        this.authService = config.authenticationService;
        this.authzService = config.authorizationService;
        this.ssoService = config.ssoService;
        this.rbacService = config.rbacService;
        this.mfaService = config.mfaService;
        this.auditService = config.auditService;
        this.logger = new logger_1.SecurityLogger('SecurityMiddleware');
        // Initialize enterprise middleware if enabled and all services available
        if (this.isEnterpriseEnabled()) {
            this.initializeEnterpriseMiddleware();
        }
    }
    /**
     * Initialize enterprise security middleware
     */
    initializeEnterpriseMiddleware() {
        if (!this.ssoService || !this.rbacService || !this.mfaService || !this.auditService) {
            this.logger.warn('Enterprise mode enabled but some services missing. Falling back to standard security.');
            return;
        }
        const securityConfig = {
            ...enterprise_security_middleware_1.defaultSecurityConfig,
            ...this.config.securityConfig,
        };
        this.enterpriseMiddleware = (0, enterprise_security_middleware_1.createSecurityMiddleware)(securityConfig, {
            ssoService: this.ssoService,
            rbacService: this.rbacService,
            mfaService: this.mfaService,
            auditService: this.auditService,
        });
        this.logger.info('Enterprise security middleware initialized');
    }
    /**
     * Check if enterprise features are enabled
     */
    isEnterpriseEnabled() {
        return this.config.enableEnterprise === true;
    }
    /**
     * Get the complete middleware stack
     */
    getMiddlewareStack() {
        if (this.isEnterpriseEnabled() && this.enterpriseMiddleware) {
            // Return enterprise middleware stack
            return this.enterpriseMiddleware.initializeMiddleware();
        }
        // Return standard middleware stack
        return [
            this.securityHeaders(),
            this.rateLimit(),
            this.requestLogger(),
            this.authenticate(),
            this.errorHandler(),
        ];
    }
    /**
     * Security headers middleware using Helmet
     */
    securityHeaders() {
        return (0, helmet_1.default)({
            contentSecurityPolicy: {
                directives: {
                    defaultSrc: ["'self'"],
                    styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
                    fontSrc: ["'self'", "https://fonts.gstatic.com"],
                    imgSrc: ["'self'", "data:", "https:"],
                    scriptSrc: ["'self'"],
                    connectSrc: ["'self'", "https://api.courtlens.com"],
                    frameSrc: ["'none'"],
                    objectSrc: ["'none'"],
                    baseUri: ["'self'"],
                    formAction: ["'self'"],
                    frameAncestors: ["'none'"],
                    upgradeInsecureRequests: []
                }
            },
            hsts: {
                maxAge: 31536000,
                includeSubDomains: true,
                preload: true
            },
            noSniff: true,
            xssFilter: true,
            referrerPolicy: { policy: "strict-origin-when-cross-origin" }
        });
    }
    /**
     * Rate limiting middleware
     */
    rateLimit(options) {
        const defaultOptions = {
            windowMs: 15 * 60 * 1000, // 15 minutes
            max: 100, // limit each IP to 100 requests per windowMs
            message: 'Too many requests from this IP, please try again later',
            standardHeaders: true,
            legacyHeaders: false,
            keyGenerator: (req) => {
                return req.ip || req.connection.remoteAddress || 'unknown';
            }
        };
        return (0, express_rate_limit_1.default)({ ...defaultOptions, ...options });
    }
    /**
     * Strict rate limiting for authentication endpoints
     */
    authRateLimit() {
        return (0, express_rate_limit_1.default)({
            windowMs: 15 * 60 * 1000, // 15 minutes
            max: 5, // limit each IP to 5 login attempts per window
            message: 'Too many login attempts, please try again later',
            standardHeaders: true,
            legacyHeaders: false,
            skipSuccessfulRequests: true
        });
    }
    /**
     * Authentication middleware
     */
    authenticate(options = {}) {
        return async (req, res, next) => {
            try {
                const authHeader = req.headers.authorization;
                if (!authHeader && options.optional) {
                    return next();
                }
                if (!authHeader || !authHeader.startsWith('Bearer ')) {
                    throw new index_1.AuthenticationError('Missing or invalid authorization header');
                }
                const token = authHeader.substring(7);
                const context = await this.authService.validateToken(token);
                // Add security context to request
                req.security = {
                    ...context,
                    ipAddress: req.ip || req.connection.remoteAddress || 'unknown',
                    userAgent: req.headers['user-agent'] || 'unknown',
                    requestId: req.headers['x-request-id'] || '',
                    timestamp: new Date()
                };
                next();
            }
            catch (error) {
                this.logger.warn('Authentication failed', {
                    ip: req.ip,
                    userAgent: req.headers['user-agent'],
                    path: req.path,
                    error: error instanceof Error ? error.message : 'Unknown error'
                });
                if (options.optional) {
                    return next();
                }
                if (error instanceof index_1.AuthenticationError) {
                    return res.status(401).json({
                        error: 'Unauthorized',
                        message: error.message
                    });
                }
                return res.status(500).json({
                    error: 'Internal Server Error',
                    message: 'Authentication service error'
                });
            }
        };
    }
    /**
     * Authorization middleware
     */
    authorize(permissionCheck) {
        return async (req, res, next) => {
            try {
                if (!req.security) {
                    throw new index_1.AuthorizationError('No security context available');
                }
                await this.authzService.requirePermission(req.security, permissionCheck);
                next();
            }
            catch (error) {
                this.logger.warn('Authorization failed', {
                    userId: req.security?.user?.id,
                    resource: permissionCheck.resource,
                    action: permissionCheck.action,
                    ip: req.ip,
                    path: req.path,
                    error: error instanceof Error ? error.message : 'Unknown error'
                });
                if (error instanceof index_1.AuthorizationError) {
                    return res.status(403).json({
                        error: 'Forbidden',
                        message: error.message
                    });
                }
                return res.status(500).json({
                    error: 'Internal Server Error',
                    message: 'Authorization service error'
                });
            }
        };
    }
    /**
     * Organization access middleware
     */
    requireOrganizationAccess(organizationIdParam = 'organizationId') {
        return async (req, res, next) => {
            try {
                if (!req.security) {
                    throw new index_1.AuthorizationError('No security context available');
                }
                const organizationId = req.params[organizationIdParam];
                if (!organizationId) {
                    throw new index_1.ValidationError('Organization ID is required');
                }
                const canAccess = await this.authzService.canAccessOrganization(req.security, organizationId);
                if (!canAccess) {
                    throw new index_1.AuthorizationError('Access denied to organization');
                }
                next();
            }
            catch (error) {
                this.logger.warn('Organization access denied', {
                    userId: req.security?.user?.id,
                    organizationId: req.params[organizationIdParam],
                    error: error instanceof Error ? error.message : 'Unknown error'
                });
                if (error instanceof index_1.AuthorizationError || error instanceof index_1.ValidationError) {
                    return res.status(403).json({
                        error: 'Forbidden',
                        message: error.message
                    });
                }
                return res.status(500).json({
                    error: 'Internal Server Error',
                    message: 'Access control service error'
                });
            }
        };
    }
    /**
     * Input validation middleware
     */
    validateInput(validations) {
        return [
            ...validations,
            (req, res, next) => {
                const errors = (0, express_validator_1.validationResult)(req);
                if (!errors.isEmpty()) {
                    this.logger.warn('Input validation failed', {
                        errors: errors.array(),
                        ip: req.ip,
                        path: req.path
                    });
                    return res.status(400).json({
                        error: 'Validation Error',
                        message: 'Invalid input data',
                        details: errors.array()
                    });
                }
                next();
            }
        ];
    }
    /**
     * CORS middleware with security considerations
     */
    cors(options = {}) {
        const defaultOptions = {
            origin: (origin, callback) => {
                // In production, maintain a whitelist of allowed origins
                const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'];
                if (!origin || allowedOrigins.includes(origin)) {
                    callback(null, true);
                }
                else {
                    callback(new Error('Not allowed by CORS'));
                }
            },
            credentials: true,
            optionsSuccessStatus: 200,
            methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
            allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID']
        };
        return (req, res, next) => {
            const config = { ...defaultOptions, ...options };
            // Apply CORS headers
            if (config.origin) {
                const origin = req.headers.origin;
                if (typeof config.origin === 'function') {
                    config.origin(origin, (err, allowed) => {
                        if (err) {
                            return res.status(403).json({ error: 'CORS policy violation' });
                        }
                        if (allowed) {
                            res.header('Access-Control-Allow-Origin', origin);
                        }
                    });
                }
                else {
                    res.header('Access-Control-Allow-Origin', config.origin);
                }
            }
            res.header('Access-Control-Allow-Methods', config.methods.join(','));
            res.header('Access-Control-Allow-Headers', config.allowedHeaders.join(','));
            res.header('Access-Control-Allow-Credentials', config.credentials.toString());
            if (req.method === 'OPTIONS') {
                return res.status(config.optionsSuccessStatus).end();
            }
            next();
        };
    }
    /**
     * Error handling middleware
     */
    errorHandler() {
        return (error, req, res, next) => {
            this.logger.error('Unhandled error', {
                error: error.message,
                stack: error.stack,
                ip: req.ip,
                path: req.path,
                method: req.method,
                userId: req.security?.user?.id
            });
            // Don't expose internal errors in production
            const isDevelopment = process.env.NODE_ENV === 'development';
            if (error instanceof index_1.AuthenticationError) {
                return res.status(401).json({
                    error: 'Unauthorized',
                    message: error.message
                });
            }
            if (error instanceof index_1.AuthorizationError) {
                return res.status(403).json({
                    error: 'Forbidden',
                    message: error.message
                });
            }
            if (error instanceof index_1.ValidationError) {
                return res.status(400).json({
                    error: 'Validation Error',
                    message: error.message,
                    details: error.details
                });
            }
            // Generic error response
            res.status(500).json({
                error: 'Internal Server Error',
                message: isDevelopment ? error.message : 'An unexpected error occurred',
                ...(isDevelopment && { stack: error.stack })
            });
        };
    }
    /**
     * Request logging middleware
     */
    requestLogger() {
        return (req, res, next) => {
            const startTime = Date.now();
            // Log request
            this.logger.info('Request started', {
                method: req.method,
                path: req.path,
                ip: req.ip,
                userAgent: req.headers['user-agent'],
                userId: req.security?.user?.id
            });
            // Log response when finished
            res.on('finish', () => {
                const duration = Date.now() - startTime;
                this.logger.info('Request completed', {
                    method: req.method,
                    path: req.path,
                    statusCode: res.statusCode,
                    duration,
                    ip: req.ip,
                    userId: req.security?.user?.id
                });
            });
            next();
        };
    }
}
exports.SecurityMiddleware = SecurityMiddleware;
// Common validation schemas
exports.ValidationSchemas = {
    email: (0, express_validator_1.body)('email').isEmail().normalizeEmail(),
    password: (0, express_validator_1.body)('password')
        .isLength({ min: 8, max: 128 })
        .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
        .withMessage('Password must contain at least one lowercase letter, one uppercase letter, one number, and one special character'),
    uuid: (field) => (0, express_validator_1.body)(field).isUUID(),
    requiredString: (field) => (0, express_validator_1.body)(field).isString().trim().isLength({ min: 1 })
};
//# sourceMappingURL=security.middleware.js.map
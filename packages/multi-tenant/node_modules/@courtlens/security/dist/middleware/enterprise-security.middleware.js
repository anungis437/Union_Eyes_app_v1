"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultSecurityConfig = exports.EnterpriseSecurityMiddleware = void 0;
exports.createSecurityMiddleware = createSecurityMiddleware;
const events_1 = require("events");
const helmet_1 = __importDefault(require("helmet"));
const express_rate_limit_1 = __importDefault(require("express-rate-limit"));
/**
 * Enterprise Security Middleware
 * Provides comprehensive security features including SSO, MFA, RBAC, and audit logging
 */
class EnterpriseSecurityMiddleware extends events_1.EventEmitter {
    constructor(config, ssoService, rbacService, mfaService, auditService) {
        super();
        this.activeSessions = new Map();
        this.rateLimiters = new Map();
        this.config = config;
        this.ssoService = ssoService;
        this.rbacService = rbacService;
        this.mfaService = mfaService;
        this.auditService = auditService;
        this.setupRateLimiters();
        this.setupSecurityHeaders();
    }
    /**
     * Initialize security middleware stack
     */
    initializeMiddleware() {
        return [
            this.securityHeaders(),
            this.rateLimiting(),
            this.sessionValidation(),
            this.authentication(),
            this.mfaValidation(),
            this.authorization(),
            this.auditLogging(),
        ];
    }
    /**
     * Security headers middleware
     */
    securityHeaders() {
        const options = {};
        if (this.config.headers.contentSecurityPolicy) {
            options.contentSecurityPolicy = {
                directives: {
                    defaultSrc: ["'self'"],
                    styleSrc: ["'self'", "'unsafe-inline'", "https:"],
                    scriptSrc: ["'self'", "https:"],
                    imgSrc: ["'self'", "data:", "https:"],
                    connectSrc: ["'self'", "https:"],
                    fontSrc: ["'self'", "https:"],
                    objectSrc: ["'none'"],
                    mediaSrc: ["'self'"],
                    frameSrc: ["'none'"],
                },
            };
        }
        if (this.config.headers.hsts) {
            options.hsts = {
                maxAge: 31536000, // 1 year
                includeSubDomains: true,
                preload: true,
            };
        }
        options.xssFilter = this.config.headers.xssFilter;
        options.noSniff = this.config.headers.noSniff;
        return (0, helmet_1.default)(options);
    }
    /**
     * Rate limiting middleware
     */
    rateLimiting() {
        return (0, express_rate_limit_1.default)({
            windowMs: this.config.rateLimit.windowMs,
            max: this.config.rateLimit.max,
            skipSuccessfulRequests: this.config.rateLimit.skipSuccessfulRequests,
            keyGenerator: (req) => {
                const authReq = req;
                // Use user ID if authenticated, otherwise IP
                return authReq.user?.id || req.ip || 'unknown';
            },
            handler: async (req, res) => {
                const context = this.buildSecurityContext(req);
                await this.auditService.logEvent({
                    action: 'rate_limit_exceeded',
                    resource: 'security',
                    resourceId: `${req.method}:${req.path}`,
                    userId: req.user?.id || 'anonymous',
                    outcome: 'failure',
                    severity: 'medium',
                    source: {
                        ip: context.ipAddress,
                        userAgent: context.userAgent,
                    },
                    details: {
                        method: req.method,
                        path: req.path,
                        headers: this.sanitizeHeaders(req.headers),
                    },
                    complianceFlags: ['security', 'rate_limiting'],
                    searchableFields: ['action', 'resource', 'userId', 'outcome'],
                });
                res.status(429).json({
                    error: 'Too Many Requests',
                    message: 'Rate limit exceeded. Please try again later.',
                    retryAfter: Math.ceil(this.config.rateLimit.windowMs / 1000),
                });
            },
        });
    }
    /**
     * Session validation middleware
     */
    sessionValidation() {
        return async (req, res, next) => {
            try {
                const sessionId = this.extractSessionId(req);
                if (!sessionId) {
                    return next(); // No session, continue to authentication
                }
                const session = this.activeSessions.get(sessionId);
                if (!session) {
                    return this.handleInvalidSession(req, res, 'Session not found');
                }
                // Check session expiration
                if (session.expiresAt && session.expiresAt < new Date()) {
                    this.activeSessions.delete(sessionId);
                    return this.handleInvalidSession(req, res, 'Session expired');
                }
                // Update last activity
                session.lastActivity = new Date();
                req.session = session;
                next();
            }
            catch (error) {
                await this.handleSecurityError(req, res, error, 'session_validation');
            }
        };
    }
    /**
     * Authentication middleware
     */
    authentication() {
        return async (req, res, next) => {
            try {
                const authHeader = req.headers.authorization;
                const sessionId = this.extractSessionId(req);
                // Skip authentication for public endpoints
                if (this.isPublicEndpoint(req.path)) {
                    return next();
                }
                let user = null;
                // Try session-based authentication first
                if (req.session && req.session.userId) {
                    user = await this.getUserFromSession(req.session);
                }
                // Try SSO authentication
                else if (this.config.sso.enabled && authHeader) {
                    user = await this.ssoService.validateToken(authHeader);
                }
                // Try bearer token authentication
                else if (authHeader && authHeader.startsWith('Bearer ')) {
                    const token = authHeader.substring(7);
                    user = await this.validateBearerToken(token);
                }
                if (!user) {
                    return this.handleUnauthenticated(req, res);
                }
                // Get user roles and permissions
                const roles = this.rbacService.getUserRoles(user.id);
                const permissions = await this.getUserPermissions(user.id, roles);
                req.user = {
                    id: user.id,
                    email: user.email,
                    name: user.name,
                    tenantId: user.tenantId,
                    organizationId: user.organizationId,
                    ssoProvider: user.ssoProvider,
                    mfaVerified: user.mfaVerified || false,
                    sessionId: sessionId || '',
                    roles: roles.map((r) => r.id),
                    permissions,
                    lastActivity: new Date(),
                    riskScore: user.riskScore || 0,
                };
                next();
            }
            catch (error) {
                await this.handleSecurityError(req, res, error, 'authentication');
            }
        };
    }
    /**
     * MFA validation middleware
     */
    mfaValidation() {
        return async (req, res, next) => {
            try {
                if (!this.config.mfa.enabled || !req.user) {
                    return next();
                }
                // Skip MFA for certain endpoints
                if (this.skipMFAForEndpoint(req.path)) {
                    return next();
                }
                // Check if MFA is required
                const mfaRequired = await this.isMFARequired(req);
                if (mfaRequired && !req.user.mfaVerified) {
                    // Check for ongoing MFA challenge
                    const challengeId = req.headers['x-mfa-challenge-id'];
                    if (challengeId) {
                        return this.handleMFAChallenge(req, res, challengeId);
                    }
                    // Initiate MFA challenge
                    return this.initiateMFA(req, res);
                }
                next();
            }
            catch (error) {
                await this.handleSecurityError(req, res, error, 'mfa_validation');
            }
        };
    }
    /**
     * Authorization middleware
     */
    authorization() {
        return async (req, res, next) => {
            try {
                if (!this.config.rbac.enabled || !req.user) {
                    return next();
                }
                // Skip authorization for public endpoints
                if (this.isPublicEndpoint(req.path)) {
                    return next();
                }
                const permission = this.getRequiredPermission(req);
                if (!permission) {
                    return next(); // No specific permission required
                }
                const context = this.buildSecurityContext(req);
                const decision = await this.rbacService.checkAccess({
                    userId: req.user.id,
                    permission: `${permission.resource}:${permission.action}`,
                    context: {
                        ip: context.ipAddress,
                        userAgent: context.userAgent,
                        tenantId: req.user.tenantId,
                        organizationId: req.user.organizationId,
                    },
                });
                if (!decision.granted) {
                    return this.handleUnauthorized(req, res, decision.reason || 'Access denied');
                }
                next();
            }
            catch (error) {
                await this.handleSecurityError(req, res, error, 'authorization');
            }
        };
    }
    /**
     * Audit logging middleware
     */
    auditLogging() {
        return async (req, res, next) => {
            const startTime = Date.now();
            const context = this.buildSecurityContext(req);
            // Capture response details
            const originalSend = res.send;
            res.send = function (body) {
                res.locals.responseBody = body;
                return originalSend.call(this, body);
            };
            res.on('finish', async () => {
                try {
                    const duration = Date.now() - startTime;
                    const severity = this.getAuditSeverity(req, res);
                    await this.auditService.logEvent({
                        action: 'api_request',
                        resource: 'api',
                        resourceId: `${req.method}:${req.path}`,
                        userId: req.user?.id || 'anonymous',
                        outcome: res.statusCode < 400 ? 'success' : 'failure',
                        severity,
                        source: {
                            ip: context.ipAddress,
                            userAgent: context.userAgent,
                        },
                        details: {
                            method: req.method,
                            path: req.path,
                            statusCode: res.statusCode,
                            duration,
                            userAgent: context.userAgent,
                            sessionId: req.user?.sessionId,
                            tenantId: req.user?.tenantId,
                            mfaVerified: req.user?.mfaVerified,
                        },
                        complianceFlags: this.getComplianceFlags(req, res),
                        searchableFields: ['action', 'resource', 'userId', 'method', 'path'],
                    });
                }
                catch (error) {
                    console.error('Audit logging failed:', error);
                }
            });
            next();
        };
    }
    /**
     * Build security context from request
     */
    buildSecurityContext(req) {
        return {
            userId: req.user?.id || 'anonymous',
            sessionId: req.user?.sessionId || '',
            ipAddress: req.ip || req.connection.remoteAddress || 'unknown',
            userAgent: req.get('User-Agent') || 'unknown',
            tenantId: req.user?.tenantId,
            organizationId: req.user?.organizationId,
            timestamp: new Date(),
            mfaVerified: req.user?.mfaVerified || false,
            ssoProvider: req.user?.ssoProvider,
            deviceFingerprint: req.headers['x-device-fingerprint'],
        };
    }
    /**
     * Handle MFA challenge initiation
     */
    async initiateMFA(req, res) {
        try {
            const context = this.buildSecurityContext(req);
            const challenge = await this.mfaService.initiateChallenge(req.user.id, req.user.sessionId, {
                ipAddress: context.ipAddress,
                userAgent: context.userAgent,
                deviceFingerprint: context.deviceFingerprint,
            });
            res.status(200).json({
                message: 'MFA challenge initiated',
                challengeId: challenge.challengeId,
                providers: challenge.providers,
                riskAssessment: challenge.riskAssessment,
            });
        }
        catch (error) {
            await this.handleSecurityError(req, res, error, 'mfa_initiation');
        }
    }
    /**
     * Handle MFA challenge response
     */
    async handleMFAChallenge(req, res, challengeId) {
        try {
            const code = req.headers['x-mfa-code'];
            if (!code) {
                return res.status(400).json({
                    error: 'MFA code required',
                    message: 'Please provide MFA code in X-MFA-Code header',
                });
            }
            const result = await this.mfaService.verifyChallenge(challengeId, code);
            if (result.success) {
                // Update user session to mark MFA as verified
                if (req.user) {
                    req.user.mfaVerified = true;
                }
                if (req.session) {
                    req.session.mfaVerified = true;
                }
                res.status(200).json({
                    message: 'MFA verification successful',
                    verified: true,
                });
            }
            else {
                res.status(401).json({
                    error: 'MFA verification failed',
                    message: result.error || 'Invalid MFA code',
                    remainingAttempts: result.remainingAttempts,
                });
            }
        }
        catch (error) {
            await this.handleSecurityError(req, res, error, 'mfa_challenge');
        }
    }
    /**
     * Check if MFA is required for this request
     */
    async isMFARequired(req) {
        if (!this.config.mfa.required) {
            return false;
        }
        // Risk-based MFA
        if (this.config.mfa.riskBasedEnabled) {
            const context = this.buildSecurityContext(req);
            const riskAssessment = await this.mfaService.assessRisk(req.user.id, req.user.sessionId, {
                ipAddress: context.ipAddress,
                userAgent: context.userAgent,
                deviceFingerprint: context.deviceFingerprint,
            });
            return riskAssessment.riskLevel !== 'low';
        }
        return true;
    }
    /**
     * Extract session ID from request
     */
    extractSessionId(req) {
        // Try multiple sources for session ID
        return (req.headers['x-session-id'] ||
            req.cookies?.sessionId ||
            req.session?.id ||
            null);
    }
    /**
     * Get required permission for endpoint
     */
    getRequiredPermission(req) {
        const path = req.path;
        const method = req.method.toLowerCase();
        // Map routes to permissions
        const routePermissions = {
            'GET:/api/cases': { resource: 'case', action: 'read' },
            'POST:/api/cases': { resource: 'case', action: 'create' },
            'PUT:/api/cases': { resource: 'case', action: 'update' },
            'DELETE:/api/cases': { resource: 'case', action: 'delete' },
            'GET:/api/documents': { resource: 'document', action: 'read' },
            'POST:/api/documents': { resource: 'document', action: 'create' },
            'PUT:/api/documents': { resource: 'document', action: 'update' },
            'DELETE:/api/documents': { resource: 'document', action: 'delete' },
            'GET:/api/users': { resource: 'user', action: 'read' },
            'POST:/api/users': { resource: 'user', action: 'create' },
            'PUT:/api/users': { resource: 'user', action: 'update' },
            'DELETE:/api/users': { resource: 'user', action: 'delete' },
            'GET:/api/admin': { resource: 'admin', action: 'read' },
            'POST:/api/admin': { resource: 'admin', action: 'manage' },
        };
        const key = `${method.toUpperCase()}:${path}`;
        return routePermissions[key] || null;
    }
    /**
     * Check if endpoint is public (no authentication required)
     */
    isPublicEndpoint(path) {
        const publicEndpoints = [
            '/api/health',
            '/api/status',
            '/api/auth/login',
            '/api/auth/sso',
            '/api/auth/callback',
            '/api/docs',
        ];
        return publicEndpoints.some(endpoint => path.startsWith(endpoint));
    }
    /**
     * Check if MFA should be skipped for endpoint
     */
    skipMFAForEndpoint(path) {
        const skipMFAEndpoints = [
            '/api/auth/mfa',
            '/api/auth/logout',
            '/api/health',
            '/api/status',
        ];
        return skipMFAEndpoints.some(endpoint => path.startsWith(endpoint));
    }
    /**
     * Handle unauthenticated requests
     */
    async handleUnauthenticated(req, res) {
        const context = this.buildSecurityContext(req);
        await this.auditService.logEvent({
            action: 'authentication_failed',
            resource: 'security',
            resourceId: `${req.method}:${req.path}`,
            userId: 'anonymous',
            outcome: 'failure',
            severity: 'medium',
            source: {
                ip: context.ipAddress,
                userAgent: context.userAgent,
            },
            details: {
                method: req.method,
                path: req.path,
                reason: 'No valid authentication provided',
            },
            complianceFlags: ['security', 'authentication'],
            searchableFields: ['action', 'resource', 'outcome', 'method'],
        });
        res.status(401).json({
            error: 'Unauthorized',
            message: 'Authentication required',
        });
    }
    /**
     * Handle unauthorized requests
     */
    async handleUnauthorized(req, res, reason) {
        const context = this.buildSecurityContext(req);
        await this.auditService.logEvent({
            action: 'authorization_failed',
            resource: 'security',
            resourceId: `${req.method}:${req.path}`,
            userId: req.user?.id || 'anonymous',
            outcome: 'failure',
            severity: 'medium',
            source: {
                ip: context.ipAddress,
                userAgent: context.userAgent,
            },
            details: {
                method: req.method,
                path: req.path,
                reason,
                userRoles: req.user?.roles,
            },
            complianceFlags: ['security', 'authorization'],
            searchableFields: ['action', 'resource', 'userId', 'outcome'],
        });
        res.status(403).json({
            error: 'Forbidden',
            message: 'Insufficient permissions',
            reason,
        });
    }
    /**
     * Handle invalid sessions
     */
    async handleInvalidSession(req, res, reason) {
        const context = this.buildSecurityContext(req);
        await this.auditService.logEvent({
            action: 'session_invalid',
            resource: 'security',
            resourceId: 'session',
            userId: 'anonymous',
            outcome: 'failure',
            severity: 'low',
            source: {
                ip: context.ipAddress,
                userAgent: context.userAgent,
            },
            details: {
                reason,
                sessionId: this.extractSessionId(req),
            },
            complianceFlags: ['security', 'session'],
            searchableFields: ['action', 'resource', 'outcome'],
        });
        res.status(401).json({
            error: 'Invalid Session',
            message: reason,
        });
    }
    /**
     * Handle security errors
     */
    async handleSecurityError(req, res, error, context) {
        const securityContext = this.buildSecurityContext(req);
        await this.auditService.logEvent({
            action: 'security_error',
            resource: 'security',
            resourceId: context,
            userId: req.user?.id || 'anonymous',
            outcome: 'failure',
            severity: 'high',
            source: {
                ip: securityContext.ipAddress,
                userAgent: securityContext.userAgent,
            },
            details: {
                error: error.message,
                stack: error.stack,
                context,
                method: req.method,
                path: req.path,
            },
            complianceFlags: ['security', 'error'],
            searchableFields: ['action', 'resource', 'userId', 'context'],
        });
        res.status(500).json({
            error: 'Security Error',
            message: 'An internal security error occurred',
        });
    }
    /**
     * Get audit severity based on request/response
     */
    getAuditSeverity(req, res) {
        if (res.statusCode >= 500)
            return 'high';
        if (res.statusCode >= 400)
            return 'medium';
        if (req.path.includes('/admin'))
            return 'medium';
        return 'low';
    }
    /**
     * Get compliance flags for audit
     */
    getComplianceFlags(req, res) {
        const flags = ['api_access'];
        if (req.user?.tenantId)
            flags.push('tenant_data');
        if (req.path.includes('/admin'))
            flags.push('admin_access');
        if (req.user?.mfaVerified)
            flags.push('mfa_verified');
        if (res.statusCode >= 400)
            flags.push('security_event');
        return flags;
    }
    /**
     * Sanitize headers for logging
     */
    sanitizeHeaders(headers) {
        const sanitized = { ...headers };
        delete sanitized.authorization;
        delete sanitized.cookie;
        delete sanitized['x-mfa-code'];
        return sanitized;
    }
    /**
     * Setup rate limiters for different endpoint types
     */
    setupRateLimiters() {
        // Different rate limits for different endpoint types
        this.rateLimiters.set('auth', (0, express_rate_limit_1.default)({
            windowMs: 15 * 60 * 1000, // 15 minutes
            max: 5, // 5 attempts per window
        }));
        this.rateLimiters.set('api', (0, express_rate_limit_1.default)({
            windowMs: this.config.rateLimit.windowMs,
            max: this.config.rateLimit.max,
        }));
        this.rateLimiters.set('upload', (0, express_rate_limit_1.default)({
            windowMs: 60 * 60 * 1000, // 1 hour
            max: 10, // 10 uploads per hour
        }));
    }
    /**
     * Setup security headers configuration
     */
    setupSecurityHeaders() {
        // Additional security header setup if needed
    }
    /**
     * Validate bearer token
     */
    async validateBearerToken(token) {
        // Implement JWT or API key validation
        // This would integrate with your existing authentication system
        return null;
    }
    /**
     * Get user from session
     */
    async getUserFromSession(session) {
        // Implement user lookup from session
        // This would query your user database
        return {
            id: session.userId,
            email: session.email,
            name: session.name,
            tenantId: session.tenantId,
            organizationId: session.organizationId,
            mfaVerified: session.mfaVerified,
        };
    }
    /**
     * Get user permissions from roles
     */
    async getUserPermissions(userId, roles) {
        const permissions = new Set();
        for (const role of roles) {
            for (const permission of role.permissions) {
                permissions.add(permission.id);
            }
        }
        return Array.from(permissions);
    }
}
exports.EnterpriseSecurityMiddleware = EnterpriseSecurityMiddleware;
/**
 * Factory function to create security middleware
 */
function createSecurityMiddleware(config, services) {
    return new EnterpriseSecurityMiddleware(config, services.ssoService, services.rbacService, services.mfaService, services.auditService);
}
/**
 * Default security configuration for enterprise deployment
 */
exports.defaultSecurityConfig = {
    sso: {
        enabled: true,
        providers: ['azure-ad', 'okta', 'google-workspace'],
        autoProvisioning: true,
        defaultRoles: ['business_user'],
    },
    mfa: {
        enabled: true,
        required: true,
        riskBasedEnabled: true,
        trustedDeviceEnabled: true,
    },
    rbac: {
        enabled: true,
        cacheEnabled: true,
        inheritanceEnabled: true,
    },
    rateLimit: {
        windowMs: 15 * 60 * 1000, // 15 minutes
        max: 100, // 100 requests per window
        skipSuccessfulRequests: false,
    },
    headers: {
        contentSecurityPolicy: true,
        hsts: true,
        xssFilter: true,
        noSniff: true,
    },
};
//# sourceMappingURL=enterprise-security.middleware.js.map
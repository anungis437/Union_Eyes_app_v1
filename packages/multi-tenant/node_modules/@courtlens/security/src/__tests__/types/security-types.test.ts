/**
 * @fileoverview Security Types Tests
 * Testing all security-related type definitions, interfaces, and enums
 */

import {
  User,
  UserRole,
  Organization,
  SubscriptionTier,
  OrganizationSecuritySettings,
  EncryptionLevel,
  AuthToken,
  MfaSetup,
  AuthSession,
  Permission,
  Role,
  AccessControl,
  SecurityEventType,
  SecurityEvent,
  RiskLevel,
  SecurityPolicy,
  SecurityRule,
  SecurityAction,
  EncryptionConfig,
  EncryptedData,
  AuditLog,
  ApiKey,
  RateLimitConfig,
  DocumentSecurity,
  DocumentClassification,
  AccessLevel,
  RetentionPolicy,
  ComplianceFramework,
  ComplianceRequirement,
  ComplianceControl,
  ImplementationStatus,
  SecurityConfig,
  AuthenticationConfig,
  PasswordPolicy,
  AuthorizationConfig,
  MonitoringConfig,
  AlertThresholds,
  LogLevel,
  ComplianceConfig,
  ReportingFrequency,
  SecurityError,
  AuthenticationError,
  AuthorizationError,
  ValidationError,
  EncryptionError,
  SecurityContext
} from '../../types';

describe('Security Types Tests', () => {
  describe('User and Organization Types', () => {
    it('should validate User interface structure', () => {
      const mockUser: User = {
        id: 'user-123',
        email: 'lawyer@lawfirm.ca',
        firstName: 'John',
        lastName: 'Doe',
        role: UserRole.PARTNER,
        organizationId: 'org-456',
        isActive: true,
        emailVerified: true,
        mfaEnabled: true,
        lastLogin: new Date('2024-01-15T10:30:00Z'),
        createdAt: new Date('2024-01-01T00:00:00Z'),
        updatedAt: new Date('2024-01-15T10:30:00Z')
      };

      expect(mockUser.id).toBe('user-123');
      expect(mockUser.email).toBe('lawyer@lawfirm.ca');
      expect(mockUser.role).toBe(UserRole.PARTNER);
      expect(mockUser.organizationId).toBe('org-456');
      expect(mockUser.isActive).toBe(true);
      expect(mockUser.emailVerified).toBe(true);
      expect(mockUser.mfaEnabled).toBe(true);
      expect(mockUser.lastLogin).toBeInstanceOf(Date);
      expect(mockUser.createdAt).toBeInstanceOf(Date);
      expect(mockUser.updatedAt).toBeInstanceOf(Date);
    });

    it('should validate UserRole enum values', () => {
      const roles: UserRole[] = [
        UserRole.SUPER_ADMIN,
        UserRole.ORG_ADMIN,
        UserRole.PARTNER,
        UserRole.SENIOR_ASSOCIATE,
        UserRole.ASSOCIATE,
        UserRole.PARALEGAL,
        UserRole.CLIENT,
        UserRole.GUEST
      ];

      expect(roles).toHaveLength(8);
      expect(UserRole.SUPER_ADMIN).toBe('super_admin');
      expect(UserRole.ORG_ADMIN).toBe('org_admin');
      expect(UserRole.PARTNER).toBe('partner');
      expect(UserRole.SENIOR_ASSOCIATE).toBe('senior_associate');
      expect(UserRole.ASSOCIATE).toBe('associate');
      expect(UserRole.PARALEGAL).toBe('paralegal');
      expect(UserRole.CLIENT).toBe('client');
      expect(UserRole.GUEST).toBe('guest');
    });

    it('should validate Organization interface structure', () => {
      const mockOrg: Organization = {
        id: 'org-123',
        name: 'Canadian Law Firm LLP',
        domain: 'canadianlawfirm.ca',
        subscriptionTier: SubscriptionTier.ENTERPRISE,
        isActive: true,
        securitySettings: {
          enforcePasswordPolicy: true,
          requireMfa: true,
          sessionTimeoutMinutes: 30,
          allowedIpRanges: ['192.168.1.0/24', '10.0.0.0/8'],
          enableAuditLogging: true,
          dataRetentionDays: 2555, // 7 years for Canadian legal requirements
          encryptionLevel: EncryptionLevel.MAXIMUM
        },
        createdAt: new Date('2024-01-01T00:00:00Z'),
        updatedAt: new Date('2024-01-15T10:30:00Z')
      };

      expect(mockOrg.name).toBe('Canadian Law Firm LLP');
      expect(mockOrg.domain).toBe('canadianlawfirm.ca');
      expect(mockOrg.subscriptionTier).toBe(SubscriptionTier.ENTERPRISE);
      expect(mockOrg.securitySettings.dataRetentionDays).toBe(2555);
      expect(mockOrg.securitySettings.encryptionLevel).toBe(EncryptionLevel.MAXIMUM);
      expect(Array.isArray(mockOrg.securitySettings.allowedIpRanges)).toBe(true);
    });

    it('should validate SubscriptionTier enum values', () => {
      const tiers: SubscriptionTier[] = [
        SubscriptionTier.BASIC,
        SubscriptionTier.PROFESSIONAL,
        SubscriptionTier.ENTERPRISE,
        SubscriptionTier.ENTERPRISE_PLUS
      ];

      expect(tiers).toHaveLength(4);
      expect(SubscriptionTier.BASIC).toBe('basic');
      expect(SubscriptionTier.PROFESSIONAL).toBe('professional');
      expect(SubscriptionTier.ENTERPRISE).toBe('enterprise');
      expect(SubscriptionTier.ENTERPRISE_PLUS).toBe('enterprise_plus');
    });

    it('should validate EncryptionLevel enum values', () => {
      const levels: EncryptionLevel[] = [
        EncryptionLevel.STANDARD,
        EncryptionLevel.ENHANCED,
        EncryptionLevel.MAXIMUM
      ];

      expect(levels).toHaveLength(3);
      expect(EncryptionLevel.STANDARD).toBe('standard');
      expect(EncryptionLevel.ENHANCED).toBe('enhanced');
      expect(EncryptionLevel.MAXIMUM).toBe('maximum');
    });
  });

  describe('Authentication Types', () => {
    it('should validate AuthToken interface structure', () => {
      const mockToken: AuthToken = {
        accessToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
        refreshToken: 'refresh_token_string',
        tokenType: 'Bearer',
        expiresIn: 3600,
        scope: ['read', 'write', 'admin']
      };

      expect(mockToken.tokenType).toBe('Bearer');
      expect(mockToken.expiresIn).toBe(3600);
      expect(Array.isArray(mockToken.scope)).toBe(true);
      expect(mockToken.scope).toContain('admin');
    });

    it('should validate MfaSetup interface structure', () => {
      const mockMfaSetup: MfaSetup = {
        secret: 'JBSWY3DPEHPK3PXP',
        qrCodeUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA...',
        backupCodes: [
          'backup-code-1',
          'backup-code-2',
          'backup-code-3',
          'backup-code-4',
          'backup-code-5'
        ]
      };

      expect(mockMfaSetup.secret).toBeTruthy();
      expect(mockMfaSetup.qrCodeUrl).toContain('data:image/png');
      expect(Array.isArray(mockMfaSetup.backupCodes)).toBe(true);
      expect(mockMfaSetup.backupCodes).toHaveLength(5);
    });

    it('should validate AuthSession interface structure', () => {
      const mockSession: AuthSession = {
        sessionId: 'session-123-456-789',
        userId: 'user-123',
        organizationId: 'org-456',
        ipAddress: '192.168.1.100',
        userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        issuedAt: new Date('2024-01-15T10:00:00Z'),
        expiresAt: new Date('2024-01-15T18:00:00Z'),
        lastActivity: new Date('2024-01-15T15:30:00Z'),
        isActive: true
      };

      expect(mockSession.sessionId).toBeTruthy();
      expect(mockSession.ipAddress).toMatch(/^\d+\.\d+\.\d+\.\d+$/);
      expect(mockSession.userAgent).toContain('Mozilla');
      expect(mockSession.issuedAt).toBeInstanceOf(Date);
      expect(mockSession.expiresAt).toBeInstanceOf(Date);
      expect(mockSession.isActive).toBe(true);
    });
  });

  describe('Authorization Types', () => {
    it('should validate Permission interface structure', () => {
      const mockPermission: Permission = {
        id: 'perm-123',
        name: 'Read Client Files',
        resource: 'client_files',
        action: 'read',
        conditions: {
          organizationId: 'org-456',
          clientId: 'client-789'
        }
      };

      expect(mockPermission.name).toBe('Read Client Files');
      expect(mockPermission.resource).toBe('client_files');
      expect(mockPermission.action).toBe('read');
      expect(mockPermission.conditions).toBeDefined();
      expect(mockPermission.conditions?.organizationId).toBe('org-456');
    });

    it('should validate Role interface structure', () => {
      const mockRole: Role = {
        id: 'role-partner',
        name: 'Partner',
        description: 'Senior partner with full access to all firm resources',
        permissions: [
          {
            id: 'perm-1',
            name: 'Full Access',
            resource: '*',
            action: '*'
          }
        ],
        organizationId: 'org-456',
        isSystemRole: false
      };

      expect(mockRole.name).toBe('Partner');
      expect(mockRole.description).toContain('Senior partner');
      expect(Array.isArray(mockRole.permissions)).toBe(true);
      expect(mockRole.permissions).toHaveLength(1);
      expect(mockRole.isSystemRole).toBe(false);
    });

    it('should validate AccessControl interface structure', () => {
      const mockAccessControl: AccessControl = {
        userId: 'user-123',
        resource: 'matter_files',
        action: 'download',
        organizationId: 'org-456',
        conditions: {
          matterIds: ['matter-789', 'matter-012'],
          timeRestriction: 'business_hours'
        }
      };

      expect(mockAccessControl.resource).toBe('matter_files');
      expect(mockAccessControl.action).toBe('download');
      expect(mockAccessControl.conditions).toBeDefined();
      expect(mockAccessControl.conditions?.matterIds).toContain('matter-789');
    });
  });

  describe('Security Event Types', () => {
    it('should validate SecurityEventType enum values', () => {
      const eventTypes: SecurityEventType[] = [
        SecurityEventType.LOGIN_SUCCESS,
        SecurityEventType.LOGIN_FAILURE,
        SecurityEventType.LOGOUT,
        SecurityEventType.PASSWORD_CHANGE,
        SecurityEventType.MFA_ENABLED,
        SecurityEventType.MFA_DISABLED,
        SecurityEventType.ACCOUNT_LOCKED,
        SecurityEventType.ACCOUNT_UNLOCKED,
        SecurityEventType.PERMISSION_DENIED,
        SecurityEventType.DATA_ACCESS,
        SecurityEventType.DATA_MODIFICATION,
        SecurityEventType.SECURITY_VIOLATION,
        SecurityEventType.SUSPICIOUS_ACTIVITY
      ];

      expect(eventTypes).toHaveLength(13);
      expect(SecurityEventType.LOGIN_SUCCESS).toBe('login_success');
      expect(SecurityEventType.SECURITY_VIOLATION).toBe('security_violation');
      expect(SecurityEventType.SUSPICIOUS_ACTIVITY).toBe('suspicious_activity');
    });

    it('should validate SecurityEvent interface structure', () => {
      const mockEvent: SecurityEvent = {
        id: 'event-123',
        type: SecurityEventType.LOGIN_SUCCESS,
        userId: 'user-456',
        organizationId: 'org-789',
        ipAddress: '192.168.1.100',
        userAgent: 'Mozilla/5.0...',
        resource: 'dashboard',
        action: 'view',
        details: {
          sessionId: 'session-123',
          mfaUsed: true,
          location: 'Toronto, ON, Canada'
        },
        riskLevel: RiskLevel.LOW,
        timestamp: new Date('2024-01-15T10:30:00Z')
      };

      expect(mockEvent.type).toBe(SecurityEventType.LOGIN_SUCCESS);
      expect(mockEvent.riskLevel).toBe(RiskLevel.LOW);
      expect(mockEvent.details.mfaUsed).toBe(true);
      expect(mockEvent.details.location).toBe('Toronto, ON, Canada');
      expect(mockEvent.timestamp).toBeInstanceOf(Date);
    });

    it('should validate RiskLevel enum values', () => {
      const riskLevels: RiskLevel[] = [
        RiskLevel.LOW,
        RiskLevel.MEDIUM,
        RiskLevel.HIGH,
        RiskLevel.CRITICAL
      ];

      expect(riskLevels).toHaveLength(4);
      expect(RiskLevel.LOW).toBe('low');
      expect(RiskLevel.MEDIUM).toBe('medium');
      expect(RiskLevel.HIGH).toBe('high');
      expect(RiskLevel.CRITICAL).toBe('critical');
    });
  });

  describe('Security Policy Types', () => {
    it('should validate SecurityPolicy interface structure', () => {
      const mockPolicy: SecurityPolicy = {
        id: 'policy-123',
        name: 'Canadian Legal Compliance Policy',
        description: 'Ensures compliance with Canadian legal data protection requirements',
        organizationId: 'org-456',
        rules: [
          {
            id: 'rule-1',
            condition: 'document.classification === "confidential"',
            action: SecurityAction.REQUIRE_MFA,
            parameters: {
              mfaType: 'totp',
              timeout: 300
            }
          }
        ],
        isActive: true,
        priority: 1,
        createdAt: new Date('2024-01-01T00:00:00Z'),
        updatedAt: new Date('2024-01-15T10:30:00Z')
      };

      expect(mockPolicy.name).toBe('Canadian Legal Compliance Policy');
      expect(mockPolicy.description).toContain('Canadian legal');
      expect(Array.isArray(mockPolicy.rules)).toBe(true);
      expect(mockPolicy.rules[0].action).toBe(SecurityAction.REQUIRE_MFA);
      expect(mockPolicy.priority).toBe(1);
    });

    it('should validate SecurityAction enum values', () => {
      const actions: SecurityAction[] = [
        SecurityAction.ALLOW,
        SecurityAction.DENY,
        SecurityAction.REQUIRE_MFA,
        SecurityAction.LOG_ONLY,
        SecurityAction.QUARANTINE,
        SecurityAction.NOTIFY_ADMIN
      ];

      expect(actions).toHaveLength(6);
      expect(SecurityAction.ALLOW).toBe('allow');
      expect(SecurityAction.DENY).toBe('deny');
      expect(SecurityAction.REQUIRE_MFA).toBe('require_mfa');
      expect(SecurityAction.QUARANTINE).toBe('quarantine');
    });
  });

  describe('Encryption Types', () => {
    it('should validate EncryptionConfig interface structure', () => {
      const mockConfig: EncryptionConfig = {
        algorithm: 'AES-256-GCM',
        keySize: 256,
        ivSize: 16,
        saltSize: 32,
        iterations: 100000
      };

      expect(mockConfig.algorithm).toBe('AES-256-GCM');
      expect(mockConfig.keySize).toBe(256);
      expect(mockConfig.ivSize).toBe(16);
      expect(mockConfig.saltSize).toBe(32);
      expect(mockConfig.iterations).toBe(100000);
    });

    it('should validate EncryptedData interface structure', () => {
      const mockEncryptedData: EncryptedData = {
        data: 'encrypted_base64_string_here',
        iv: 'initialization_vector_base64',
        salt: 'salt_base64_string',
        algorithm: 'AES-256-GCM',
        keyId: 'key-123-456',
        level: EncryptionLevel.MAXIMUM
      };

      expect(mockEncryptedData.algorithm).toBe('AES-256-GCM');
      expect(mockEncryptedData.level).toBe(EncryptionLevel.MAXIMUM);
      expect(mockEncryptedData.keyId).toBe('key-123-456');
      expect(mockEncryptedData.data).toBeTruthy();
      expect(mockEncryptedData.iv).toBeTruthy();
      expect(mockEncryptedData.salt).toBeTruthy();
    });
  });

  describe('Audit and Logging Types', () => {
    it('should validate AuditLog interface structure', () => {
      const mockAuditLog: AuditLog = {
        id: 'audit-123',
        userId: 'user-456',
        organizationId: 'org-789',
        action: 'update_client_file',
        resource: 'client_files',
        oldValues: {
          fileName: 'old_contract.pdf',
          status: 'draft'
        },
        newValues: {
          fileName: 'contract_final.pdf',
          status: 'executed'
        },
        ipAddress: '192.168.1.100',
        userAgent: 'Mozilla/5.0...',
        timestamp: new Date('2024-01-15T10:30:00Z'),
        success: true
      };

      expect(mockAuditLog.action).toBe('update_client_file');
      expect(mockAuditLog.resource).toBe('client_files');
      expect(mockAuditLog.oldValues?.fileName).toBe('old_contract.pdf');
      expect(mockAuditLog.newValues?.fileName).toBe('contract_final.pdf');
      expect(mockAuditLog.success).toBe(true);
    });

    it('should validate LogLevel enum values', () => {
      const logLevels: LogLevel[] = [
        LogLevel.DEBUG,
        LogLevel.INFO,
        LogLevel.WARN,
        LogLevel.ERROR,
        LogLevel.CRITICAL
      ];

      expect(logLevels).toHaveLength(5);
      expect(LogLevel.DEBUG).toBe('debug');
      expect(LogLevel.INFO).toBe('info');
      expect(LogLevel.WARN).toBe('warn');
      expect(LogLevel.ERROR).toBe('error');
      expect(LogLevel.CRITICAL).toBe('critical');
    });
  });

  describe('Legal Domain Security Types', () => {
    it('should validate DocumentSecurity interface structure', () => {
      const mockDocSecurity: DocumentSecurity = {
        documentId: 'doc-123',
        classification: DocumentClassification.CONFIDENTIAL,
        accessLevel: AccessLevel.READ_WRITE,
        retentionPolicy: {
          retentionPeriodDays: 2555, // 7 years
          autoDelete: false,
          archiveRequired: true,
          legalHoldExempt: false
        },
        encryptionRequired: true,
        auditRequired: true,
        restrictedCountries: ['CN', 'RU', 'IR']
      };

      expect(mockDocSecurity.classification).toBe(DocumentClassification.CONFIDENTIAL);
      expect(mockDocSecurity.accessLevel).toBe(AccessLevel.READ_WRITE);
      expect(mockDocSecurity.retentionPolicy.retentionPeriodDays).toBe(2555);
      expect(mockDocSecurity.encryptionRequired).toBe(true);
      expect(mockDocSecurity.auditRequired).toBe(true);
      expect(mockDocSecurity.restrictedCountries).toContain('CN');
    });

    it('should validate DocumentClassification enum values', () => {
      const classifications: DocumentClassification[] = [
        DocumentClassification.PUBLIC,
        DocumentClassification.INTERNAL,
        DocumentClassification.CONFIDENTIAL,
        DocumentClassification.RESTRICTED,
        DocumentClassification.TOP_SECRET
      ];

      expect(classifications).toHaveLength(5);
      expect(DocumentClassification.PUBLIC).toBe('public');
      expect(DocumentClassification.CONFIDENTIAL).toBe('confidential');
      expect(DocumentClassification.TOP_SECRET).toBe('top_secret');
    });

    it('should validate AccessLevel enum values', () => {
      const accessLevels: AccessLevel[] = [
        AccessLevel.READ_ONLY,
        AccessLevel.READ_WRITE,
        AccessLevel.FULL_ACCESS,
        AccessLevel.NO_ACCESS
      ];

      expect(accessLevels).toHaveLength(4);
      expect(AccessLevel.READ_ONLY).toBe('read_only');
      expect(AccessLevel.READ_WRITE).toBe('read_write');
      expect(AccessLevel.FULL_ACCESS).toBe('full_access');
      expect(AccessLevel.NO_ACCESS).toBe('no_access');
    });
  });

  describe('Error Types', () => {
    it('should validate SecurityError class', () => {
      const error = new SecurityError(
        'Security violation detected',
        'SECURITY_VIOLATION',
        403,
        { resource: 'confidential_file' }
      );

      expect(error.name).toBe('SecurityError');
      expect(error.message).toBe('Security violation detected');
      expect(error.code).toBe('SECURITY_VIOLATION');
      expect(error.statusCode).toBe(403);
      expect(error.details?.resource).toBe('confidential_file');
      expect(error).toBeInstanceOf(Error);
    });

    it('should validate AuthenticationError class', () => {
      const error = new AuthenticationError(
        'Invalid credentials',
        { attemptCount: 3 }
      );

      expect(error.name).toBe('AuthenticationError');
      expect(error.message).toBe('Invalid credentials');
      expect(error.code).toBe('AUTHENTICATION_ERROR');
      expect(error.statusCode).toBe(401);
      expect(error.details?.attemptCount).toBe(3);
      expect(error).toBeInstanceOf(SecurityError);
    });

    it('should validate AuthorizationError class', () => {
      const error = new AuthorizationError(
        'Access denied',
        { requiredRole: 'partner' }
      );

      expect(error.name).toBe('AuthorizationError');
      expect(error.code).toBe('AUTHORIZATION_ERROR');
      expect(error.statusCode).toBe(403);
      expect(error.details?.requiredRole).toBe('partner');
    });

    it('should validate ValidationError class', () => {
      const error = new ValidationError(
        'Invalid input data',
        { field: 'email' }
      );

      expect(error.name).toBe('ValidationError');
      expect(error.code).toBe('VALIDATION_ERROR');
      expect(error.statusCode).toBe(400);
      expect(error.details?.field).toBe('email');
    });

    it('should validate EncryptionError class', () => {
      const error = new EncryptionError(
        'Encryption failed',
        { algorithm: 'AES-256' }
      );

      expect(error.name).toBe('EncryptionError');
      expect(error.code).toBe('ENCRYPTION_ERROR');
      expect(error.statusCode).toBe(500);
      expect(error.details?.algorithm).toBe('AES-256');
    });
  });

  describe('Security Context Types', () => {
    it('should validate SecurityContext interface structure', () => {
      const mockContext: SecurityContext = {
        user: {
          id: 'user-123',
          email: 'lawyer@firm.ca',
          firstName: 'John',
          lastName: 'Doe',
          role: UserRole.PARTNER,
          organizationId: 'org-456',
          isActive: true,
          emailVerified: true,
          mfaEnabled: true,
          createdAt: new Date(),
          updatedAt: new Date()
        },
        organization: {
          id: 'org-456',
          name: 'Law Firm',
          domain: 'firm.ca',
          subscriptionTier: SubscriptionTier.ENTERPRISE,
          isActive: true,
          securitySettings: {
            enforcePasswordPolicy: true,
            requireMfa: true,
            sessionTimeoutMinutes: 30,
            enableAuditLogging: true,
            dataRetentionDays: 2555,
            encryptionLevel: EncryptionLevel.MAXIMUM
          },
          createdAt: new Date(),
          updatedAt: new Date()
        },
        permissions: [
          {
            id: 'perm-1',
            name: 'Full Access',
            resource: '*',
            action: '*'
          }
        ],
        ipAddress: '192.168.1.100',
        userAgent: 'Mozilla/5.0...',
        requestId: 'req-123-456',
        timestamp: new Date('2024-01-15T10:30:00Z')
      };

      expect(mockContext.user?.role).toBe(UserRole.PARTNER);
      expect(mockContext.organization?.subscriptionTier).toBe(SubscriptionTier.ENTERPRISE);
      expect(Array.isArray(mockContext.permissions)).toBe(true);
      expect(mockContext.ipAddress).toMatch(/^\d+\.\d+\.\d+\.\d+$/);
      expect(mockContext.requestId).toBe('req-123-456');
      expect(mockContext.timestamp).toBeInstanceOf(Date);
    });
  });
});
import { Request, Response, NextFunction } from 'express';
import { EventEmitter } from 'events';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import { EnterpriseSSOService } from '../services/enterprise-sso.service';
import { EnterpriseRBACService } from '../services/enterprise-rbac.service';
import { EnterpriseMFAService } from '../services/enterprise-mfa.service';
import { EnterpriseAuditService } from '../services/enterprise-audit.service';

/**
 * Enhanced security middleware for enterprise authentication and authorization
 */
export interface SecurityConfig {
  sso: {
    enabled: boolean;
    providers: string[];
    autoProvisioning: boolean;
    defaultRoles: string[];
  };
  mfa: {
    enabled: boolean;
    required: boolean;
    riskBasedEnabled: boolean;
    trustedDeviceEnabled: boolean;
  };
  rbac: {
    enabled: boolean;
    cacheEnabled: boolean;
    inheritanceEnabled: boolean;
  };
  rateLimit: {
    windowMs: number;
    max: number;
    skipSuccessfulRequests: boolean;
  };
  headers: {
    contentSecurityPolicy: boolean;
    hsts: boolean;
    xssFilter: boolean;
    noSniff: boolean;
  };
}

export interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
    email: string;
    name: string;
    tenantId?: string;
    organizationId?: string;
    ssoProvider?: string;
    mfaVerified: boolean;
    sessionId: string;
    roles: string[];
    permissions: string[];
    lastActivity: Date;
    riskScore: number;
  };
  session?: {
    id: string;
    userId: string;
    createdAt: Date;
    lastActivity: Date;
    ipAddress: string;
    userAgent: string;
    mfaVerified: boolean;
    trustedDevice: boolean;
    riskAssessment?: {
      level: 'low' | 'medium' | 'high' | 'critical';
      score: number;
      factors: string[];
    };
  };
}

export interface SecurityContext {
  userId: string;
  sessionId: string;
  ipAddress: string;
  userAgent: string;
  tenantId?: string;
  organizationId?: string;
  timestamp: Date;
  mfaVerified: boolean;
  ssoProvider?: string;
  deviceFingerprint?: string;
  geolocation?: {
    country: string;
    city: string;
    coordinates?: [number, number];
  };
}

/**
 * Enterprise Security Middleware
 * Provides comprehensive security features including SSO, MFA, RBAC, and audit logging
 */
export class EnterpriseSecurityMiddleware extends EventEmitter {
  private config: SecurityConfig;
  private ssoService: EnterpriseSSOService;
  private rbacService: EnterpriseRBACService;
  private mfaService: EnterpriseMFAService;
  private auditService: EnterpriseAuditService;
  private activeSessions = new Map<string, any>();
  private rateLimiters = new Map<string, any>();

  constructor(
    config: SecurityConfig,
    ssoService: EnterpriseSSOService,
    rbacService: EnterpriseRBACService,
    mfaService: EnterpriseMFAService,
    auditService: EnterpriseAuditService
  ) {
    super();
    this.config = config;
    this.ssoService = ssoService;
    this.rbacService = rbacService;
    this.mfaService = mfaService;
    this.auditService = auditService;
    this.setupRateLimiters();
    this.setupSecurityHeaders();
  }

  /**
   * Initialize security middleware stack
   */
  initializeMiddleware() {
    return [
      this.securityHeaders(),
      this.rateLimiting(),
      this.sessionValidation(),
      this.authentication(),
      this.mfaValidation(),
      this.authorization(),
      this.auditLogging(),
    ];
  }

  /**
   * Security headers middleware
   */
  private securityHeaders() {
    const options: any = {};

    if (this.config.headers.contentSecurityPolicy) {
      options.contentSecurityPolicy = {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'", "https:"],
          scriptSrc: ["'self'", "https:"],
          imgSrc: ["'self'", "data:", "https:"],
          connectSrc: ["'self'", "https:"],
          fontSrc: ["'self'", "https:"],
          objectSrc: ["'none'"],
          mediaSrc: ["'self'"],
          frameSrc: ["'none'"],
        },
      };
    }

    if (this.config.headers.hsts) {
      options.hsts = {
        maxAge: 31536000, // 1 year
        includeSubDomains: true,
        preload: true,
      };
    }

    options.xssFilter = this.config.headers.xssFilter;
    options.noSniff = this.config.headers.noSniff;

    return helmet(options);
  }

  /**
   * Rate limiting middleware
   */
  private rateLimiting() {
    return rateLimit({
      windowMs: this.config.rateLimit.windowMs,
      max: this.config.rateLimit.max,
      skipSuccessfulRequests: this.config.rateLimit.skipSuccessfulRequests,
      keyGenerator: (req: any) => {
        const authReq = req as AuthenticatedRequest;
        // Use user ID if authenticated, otherwise IP
        return authReq.user?.id || req.ip || 'unknown';
      },
      handler: async (req: any, res: any) => {
        const context = this.buildSecurityContext(req as AuthenticatedRequest);
        
        await this.auditService.logEvent({
          action: 'rate_limit_exceeded',
          resource: 'security',
          resourceId: `${req.method}:${req.path}`,
          userId: (req as AuthenticatedRequest).user?.id || 'anonymous',
          outcome: 'failure',
          severity: 'medium',
          source: {
            ip: context.ipAddress,
            userAgent: context.userAgent,
          },
          details: {
            method: req.method,
            path: req.path,
            headers: this.sanitizeHeaders(req.headers),
          },
          complianceFlags: ['security', 'rate_limiting'],
          searchableFields: ['action', 'resource', 'userId', 'outcome'],
        });

        res.status(429).json({
          error: 'Too Many Requests',
          message: 'Rate limit exceeded. Please try again later.',
          retryAfter: Math.ceil(this.config.rateLimit.windowMs / 1000),
        });
      },
    });
  }

  /**
   * Session validation middleware
   */
  private sessionValidation() {
    return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
      try {
        const sessionId = this.extractSessionId(req);
        
        if (!sessionId) {
          return next(); // No session, continue to authentication
        }

        const session = this.activeSessions.get(sessionId);
        if (!session) {
          return this.handleInvalidSession(req, res, 'Session not found');
        }

        // Check session expiration
        if (session.expiresAt && session.expiresAt < new Date()) {
          this.activeSessions.delete(sessionId);
          return this.handleInvalidSession(req, res, 'Session expired');
        }

        // Update last activity
        session.lastActivity = new Date();
        req.session = session;

        next();
      } catch (error) {
        await this.handleSecurityError(req, res, error as Error, 'session_validation');
      }
    };
  }

  /**
   * Authentication middleware
   */
  private authentication() {
    return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
      try {
        const authHeader = req.headers.authorization;
        const sessionId = this.extractSessionId(req);

        // Skip authentication for public endpoints
        if (this.isPublicEndpoint(req.path)) {
          return next();
        }

        let user: any = null;

        // Try session-based authentication first
        if (req.session && req.session.userId) {
          user = await this.getUserFromSession(req.session);
        }
        // Try SSO authentication
        else if (this.config.sso.enabled && authHeader) {
          user = await this.ssoService.validateToken(authHeader);
        }
        // Try bearer token authentication
        else if (authHeader && authHeader.startsWith('Bearer ')) {
          const token = authHeader.substring(7);
          user = await this.validateBearerToken(token);
        }

        if (!user) {
          return this.handleUnauthenticated(req, res);
        }

        // Get user roles and permissions
        const roles = this.rbacService.getUserRoles(user.id);
        const permissions = await this.getUserPermissions(user.id, roles);

        req.user = {
          id: user.id,
          email: user.email,
          name: user.name,
          tenantId: user.tenantId,
          organizationId: user.organizationId,
          ssoProvider: user.ssoProvider,
          mfaVerified: user.mfaVerified || false,
          sessionId: sessionId || '',
          roles: roles.map((r: any) => r.id),
          permissions,
          lastActivity: new Date(),
          riskScore: user.riskScore || 0,
        };

        next();
      } catch (error) {
        await this.handleSecurityError(req, res, error as Error, 'authentication');
      }
    };
  }

  /**
   * MFA validation middleware
   */
  private mfaValidation() {
    return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
      try {
        if (!this.config.mfa.enabled || !req.user) {
          return next();
        }

        // Skip MFA for certain endpoints
        if (this.skipMFAForEndpoint(req.path)) {
          return next();
        }

        // Check if MFA is required
        const mfaRequired = await this.isMFARequired(req);
        
        if (mfaRequired && !req.user.mfaVerified) {
          // Check for ongoing MFA challenge
          const challengeId = req.headers['x-mfa-challenge-id'] as string;
          
          if (challengeId) {
            return this.handleMFAChallenge(req, res, challengeId);
          }

          // Initiate MFA challenge
          return this.initiateMFA(req, res);
        }

        next();
      } catch (error) {
        await this.handleSecurityError(req, res, error as Error, 'mfa_validation');
      }
    };
  }

  /**
   * Authorization middleware
   */
  private authorization() {
    return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
      try {
        if (!this.config.rbac.enabled || !req.user) {
          return next();
        }

        // Skip authorization for public endpoints
        if (this.isPublicEndpoint(req.path)) {
          return next();
        }

        const permission = this.getRequiredPermission(req);
        if (!permission) {
          return next(); // No specific permission required
        }

        const context = this.buildSecurityContext(req);
        const decision = await this.rbacService.checkAccess({
          userId: req.user.id,
          permission: `${permission.resource}:${permission.action}`,
          context: {
            ip: context.ipAddress,
            userAgent: context.userAgent,
            tenantId: req.user.tenantId,
            organizationId: req.user.organizationId,
          },
        });

        if (!decision.granted) {
          return this.handleUnauthorized(req, res, decision.reason || 'Access denied');
        }

        next();
      } catch (error) {
        await this.handleSecurityError(req, res, error as Error, 'authorization');
      }
    };
  }

  /**
   * Audit logging middleware
   */
  private auditLogging() {
    return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
      const startTime = Date.now();
      const context = this.buildSecurityContext(req);

      // Capture response details
      const originalSend = res.send;
      res.send = function(body: any) {
        res.locals.responseBody = body;
        return originalSend.call(this, body);
      };

      res.on('finish', async () => {
        try {
          const duration = Date.now() - startTime;
          const severity = this.getAuditSeverity(req, res);

          await this.auditService.logEvent({
            action: 'api_request',
            resource: 'api',
            resourceId: `${req.method}:${req.path}`,
            userId: req.user?.id || 'anonymous',
            outcome: res.statusCode < 400 ? 'success' : 'failure',
            severity,
            source: {
              ip: context.ipAddress,
              userAgent: context.userAgent,
            },
            details: {
              method: req.method,
              path: req.path,
              statusCode: res.statusCode,
              duration,
              userAgent: context.userAgent,
              sessionId: req.user?.sessionId,
              tenantId: req.user?.tenantId,
              mfaVerified: req.user?.mfaVerified,
            },
            complianceFlags: this.getComplianceFlags(req, res),
            searchableFields: ['action', 'resource', 'userId', 'method', 'path'],
          });
        } catch (error) {
          console.error('Audit logging failed:', error);
        }
      });

      next();
    };
  }

  /**
   * Build security context from request
   */
  private buildSecurityContext(req: AuthenticatedRequest): SecurityContext {
    return {
      userId: req.user?.id || 'anonymous',
      sessionId: req.user?.sessionId || '',
      ipAddress: req.ip || req.connection.remoteAddress || 'unknown',
      userAgent: req.get('User-Agent') || 'unknown',
      tenantId: req.user?.tenantId,
      organizationId: req.user?.organizationId,
      timestamp: new Date(),
      mfaVerified: req.user?.mfaVerified || false,
      ssoProvider: req.user?.ssoProvider,
      deviceFingerprint: req.headers['x-device-fingerprint'] as string,
    };
  }

  /**
   * Handle MFA challenge initiation
   */
  private async initiateMFA(req: AuthenticatedRequest, res: Response) {
    try {
      const context = this.buildSecurityContext(req);
      const challenge = await this.mfaService.initiateChallenge(
        req.user!.id,
        req.user!.sessionId,
        {
          ipAddress: context.ipAddress,
          userAgent: context.userAgent,
          deviceFingerprint: context.deviceFingerprint,
        }
      );

      res.status(200).json({
        message: 'MFA challenge initiated',
        challengeId: challenge.challengeId,
        providers: challenge.providers,
        riskAssessment: challenge.riskAssessment,
      });
    } catch (error) {
      await this.handleSecurityError(req, res, error as Error, 'mfa_initiation');
    }
  }

  /**
   * Handle MFA challenge response
   */
  private async handleMFAChallenge(req: AuthenticatedRequest, res: Response, challengeId: string) {
    try {
      const code = req.headers['x-mfa-code'] as string;
      
      if (!code) {
        return res.status(400).json({
          error: 'MFA code required',
          message: 'Please provide MFA code in X-MFA-Code header',
        });
      }

      const result = await this.mfaService.verifyChallenge(challengeId, code);

      if (result.success) {
        // Update user session to mark MFA as verified
        if (req.user) {
          req.user.mfaVerified = true;
        }
        
        if (req.session) {
          req.session.mfaVerified = true;
        }

        res.status(200).json({
          message: 'MFA verification successful',
          verified: true,
        });
      } else {
        res.status(401).json({
          error: 'MFA verification failed',
          message: result.error || 'Invalid MFA code',
          remainingAttempts: result.remainingAttempts,
        });
      }
    } catch (error) {
      await this.handleSecurityError(req, res, error as Error, 'mfa_challenge');
    }
  }

  /**
   * Check if MFA is required for this request
   */
  private async isMFARequired(req: AuthenticatedRequest): Promise<boolean> {
    if (!this.config.mfa.required) {
      return false;
    }

    // Risk-based MFA
    if (this.config.mfa.riskBasedEnabled) {
      const context = this.buildSecurityContext(req);
      const riskAssessment = await this.mfaService.assessRisk(
        req.user!.id,
        req.user!.sessionId,
        {
          ipAddress: context.ipAddress,
          userAgent: context.userAgent,
          deviceFingerprint: context.deviceFingerprint,
        }
      );

      return riskAssessment.riskLevel !== 'low';
    }

    return true;
  }

  /**
   * Extract session ID from request
   */
  private extractSessionId(req: Request): string | null {
    // Try multiple sources for session ID
    return (
      req.headers['x-session-id'] as string ||
      req.cookies?.sessionId ||
      (req as any).session?.id ||
      null
    );
  }

  /**
   * Get required permission for endpoint
   */
  private getRequiredPermission(req: AuthenticatedRequest): { resource: string; action: string } | null {
    const path = req.path;
    const method = req.method.toLowerCase();

    // Map routes to permissions
    const routePermissions: Record<string, { resource: string; action: string }> = {
      'GET:/api/cases': { resource: 'case', action: 'read' },
      'POST:/api/cases': { resource: 'case', action: 'create' },
      'PUT:/api/cases': { resource: 'case', action: 'update' },
      'DELETE:/api/cases': { resource: 'case', action: 'delete' },
      'GET:/api/documents': { resource: 'document', action: 'read' },
      'POST:/api/documents': { resource: 'document', action: 'create' },
      'PUT:/api/documents': { resource: 'document', action: 'update' },
      'DELETE:/api/documents': { resource: 'document', action: 'delete' },
      'GET:/api/users': { resource: 'user', action: 'read' },
      'POST:/api/users': { resource: 'user', action: 'create' },
      'PUT:/api/users': { resource: 'user', action: 'update' },
      'DELETE:/api/users': { resource: 'user', action: 'delete' },
      'GET:/api/admin': { resource: 'admin', action: 'read' },
      'POST:/api/admin': { resource: 'admin', action: 'manage' },
    };

    const key = `${method.toUpperCase()}:${path}`;
    return routePermissions[key] || null;
  }

  /**
   * Check if endpoint is public (no authentication required)
   */
  private isPublicEndpoint(path: string): boolean {
    const publicEndpoints = [
      '/api/health',
      '/api/status',
      '/api/auth/login',
      '/api/auth/sso',
      '/api/auth/callback',
      '/api/docs',
    ];

    return publicEndpoints.some(endpoint => path.startsWith(endpoint));
  }

  /**
   * Check if MFA should be skipped for endpoint
   */
  private skipMFAForEndpoint(path: string): boolean {
    const skipMFAEndpoints = [
      '/api/auth/mfa',
      '/api/auth/logout',
      '/api/health',
      '/api/status',
    ];

    return skipMFAEndpoints.some(endpoint => path.startsWith(endpoint));
  }

  /**
   * Handle unauthenticated requests
   */
  private async handleUnauthenticated(req: AuthenticatedRequest, res: Response) {
    const context = this.buildSecurityContext(req);

    await this.auditService.logEvent({
      action: 'authentication_failed',
      resource: 'security',
      resourceId: `${req.method}:${req.path}`,
      userId: 'anonymous',
      outcome: 'failure',
      severity: 'medium',
      source: {
        ip: context.ipAddress,
        userAgent: context.userAgent,
      },
      details: {
        method: req.method,
        path: req.path,
        reason: 'No valid authentication provided',
      },
      complianceFlags: ['security', 'authentication'],
      searchableFields: ['action', 'resource', 'outcome', 'method'],
    });

    res.status(401).json({
      error: 'Unauthorized',
      message: 'Authentication required',
    });
  }

  /**
   * Handle unauthorized requests
   */
  private async handleUnauthorized(req: AuthenticatedRequest, res: Response, reason: string) {
    const context = this.buildSecurityContext(req);

    await this.auditService.logEvent({
      action: 'authorization_failed',
      resource: 'security',
      resourceId: `${req.method}:${req.path}`,
      userId: req.user?.id || 'anonymous',
      outcome: 'failure',
      severity: 'medium',
      source: {
        ip: context.ipAddress,
        userAgent: context.userAgent,
      },
      details: {
        method: req.method,
        path: req.path,
        reason,
        userRoles: req.user?.roles,
      },
      complianceFlags: ['security', 'authorization'],
      searchableFields: ['action', 'resource', 'userId', 'outcome'],
    });

    res.status(403).json({
      error: 'Forbidden',
      message: 'Insufficient permissions',
      reason,
    });
  }

  /**
   * Handle invalid sessions
   */
  private async handleInvalidSession(req: AuthenticatedRequest, res: Response, reason: string) {
    const context = this.buildSecurityContext(req);

    await this.auditService.logEvent({
      action: 'session_invalid',
      resource: 'security',
      resourceId: 'session',
      userId: 'anonymous',
      outcome: 'failure',
      severity: 'low',
      source: {
        ip: context.ipAddress,
        userAgent: context.userAgent,
      },
      details: {
        reason,
        sessionId: this.extractSessionId(req),
      },
      complianceFlags: ['security', 'session'],
      searchableFields: ['action', 'resource', 'outcome'],
    });

    res.status(401).json({
      error: 'Invalid Session',
      message: reason,
    });
  }

  /**
   * Handle security errors
   */
  private async handleSecurityError(
    req: AuthenticatedRequest,
    res: Response,
    error: Error,
    context: string
  ) {
    const securityContext = this.buildSecurityContext(req);

    await this.auditService.logEvent({
      action: 'security_error',
      resource: 'security',
      resourceId: context,
      userId: req.user?.id || 'anonymous',
      outcome: 'failure',
      severity: 'high',
      source: {
        ip: securityContext.ipAddress,
        userAgent: securityContext.userAgent,
      },
      details: {
        error: error.message,
        stack: error.stack,
        context,
        method: req.method,
        path: req.path,
      },
      complianceFlags: ['security', 'error'],
      searchableFields: ['action', 'resource', 'userId', 'context'],
    });

    res.status(500).json({
      error: 'Security Error',
      message: 'An internal security error occurred',
    });
  }

  /**
   * Get audit severity based on request/response
   */
  private getAuditSeverity(req: AuthenticatedRequest, res: Response): 'low' | 'medium' | 'high' | 'critical' {
    if (res.statusCode >= 500) return 'high';
    if (res.statusCode >= 400) return 'medium';
    if (req.path.includes('/admin')) return 'medium';
    return 'low';
  }

  /**
   * Get compliance flags for audit
   */
  private getComplianceFlags(req: AuthenticatedRequest, res: Response): string[] {
    const flags = ['api_access'];
    
    if (req.user?.tenantId) flags.push('tenant_data');
    if (req.path.includes('/admin')) flags.push('admin_access');
    if (req.user?.mfaVerified) flags.push('mfa_verified');
    if (res.statusCode >= 400) flags.push('security_event');
    
    return flags;
  }

  /**
   * Sanitize headers for logging
   */
  private sanitizeHeaders(headers: any): any {
    const sanitized = { ...headers };
    delete sanitized.authorization;
    delete sanitized.cookie;
    delete sanitized['x-mfa-code'];
    return sanitized;
  }

  /**
   * Setup rate limiters for different endpoint types
   */
  private setupRateLimiters(): void {
    // Different rate limits for different endpoint types
    this.rateLimiters.set('auth', rateLimit({
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 5, // 5 attempts per window
    }));

    this.rateLimiters.set('api', rateLimit({
      windowMs: this.config.rateLimit.windowMs,
      max: this.config.rateLimit.max,
    }));

    this.rateLimiters.set('upload', rateLimit({
      windowMs: 60 * 60 * 1000, // 1 hour
      max: 10, // 10 uploads per hour
    }));
  }

  /**
   * Setup security headers configuration
   */
  private setupSecurityHeaders(): void {
    // Additional security header setup if needed
  }

  /**
   * Validate bearer token
   */
  private async validateBearerToken(token: string): Promise<any> {
    // Implement JWT or API key validation
    // This would integrate with your existing authentication system
    return null;
  }

  /**
   * Get user from session
   */
  private async getUserFromSession(session: any): Promise<any> {
    // Implement user lookup from session
    // This would query your user database
    return {
      id: session.userId,
      email: session.email,
      name: session.name,
      tenantId: session.tenantId,
      organizationId: session.organizationId,
      mfaVerified: session.mfaVerified,
    };
  }

  /**
   * Get user permissions from roles
   */
  private async getUserPermissions(userId: string, roles: any[]): Promise<string[]> {
    const permissions = new Set<string>();
    
    for (const role of roles) {
      for (const permission of role.permissions) {
        permissions.add(permission.id);
      }
    }
    
    return Array.from(permissions);
  }
}

/**
 * Factory function to create security middleware
 */
export function createSecurityMiddleware(
  config: SecurityConfig,
  services: {
    ssoService: EnterpriseSSOService;
    rbacService: EnterpriseRBACService;
    mfaService: EnterpriseMFAService;
    auditService: EnterpriseAuditService;
  }
): EnterpriseSecurityMiddleware {
  return new EnterpriseSecurityMiddleware(
    config,
    services.ssoService,
    services.rbacService,
    services.mfaService,
    services.auditService
  );
}

/**
 * Default security configuration for enterprise deployment
 */
export const defaultSecurityConfig: SecurityConfig = {
  sso: {
    enabled: true,
    providers: ['azure-ad', 'okta', 'google-workspace'],
    autoProvisioning: true,
    defaultRoles: ['business_user'],
  },
  mfa: {
    enabled: true,
    required: true,
    riskBasedEnabled: true,
    trustedDeviceEnabled: true,
  },
  rbac: {
    enabled: true,
    cacheEnabled: true,
    inheritanceEnabled: true,
  },
  rateLimit: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // 100 requests per window
    skipSuccessfulRequests: false,
  },
  headers: {
    contentSecurityPolicy: true,
    hsts: true,
    xssFilter: true,
    noSniff: true,
  },
};
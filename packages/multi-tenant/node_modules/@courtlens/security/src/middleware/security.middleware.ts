// CourtLens Security Middleware
// Express middleware for authentication, authorization, and security headers
// Enhanced with enterprise SSO, MFA, RBAC, and comprehensive audit logging

import { Request, Response, NextFunction } from 'express';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import { body, validationResult } from 'express-validator';
import {
  SecurityContext,
  AuthenticationError,
  AuthorizationError,
  ValidationError,
  Permission,
  PermissionCheck
} from '../types/index';
import { AuthenticationService } from '../services/authentication.service';
import { AuthorizationService } from '../services/authorization.service';
import { EnterpriseSSOService } from '../services/enterprise-sso.service';
import { EnterpriseRBACService } from '../services/enterprise-rbac.service';
import { EnterpriseMFAService } from '../services/enterprise-mfa.service';
import { EnterpriseAuditService } from '../services/enterprise-audit.service';
import { 
  EnterpriseSecurityMiddleware, 
  createSecurityMiddleware, 
  defaultSecurityConfig,
  type SecurityConfig 
} from './enterprise-security.middleware';
import { SecurityLogger } from '../utils/logger';

// Extend Express Request to include security context
declare global {
  namespace Express {
    interface Request {
      security?: SecurityContext;
      user?: {
        id: string;
        email: string;
        name: string;
        tenantId?: string;
        organizationId?: string;
        roles: string[];
        permissions: string[];
        mfaVerified: boolean;
        sessionId: string;
        riskScore: number;
      };
    }
  }
}

export interface SecurityMiddlewareConfig {
  authenticationService: AuthenticationService;
  authorizationService: AuthorizationService;
  // Enterprise services
  ssoService?: EnterpriseSSOService;
  rbacService?: EnterpriseRBACService;
  mfaService?: EnterpriseMFAService;
  auditService?: EnterpriseAuditService;
  // Configuration
  rateLimitConfig?: any;
  corsConfig?: any;
  securityConfig?: Partial<SecurityConfig>;
  enableEnterprise?: boolean;
}

export class SecurityMiddleware {
  private authService: AuthenticationService;
  private authzService: AuthorizationService;
  private ssoService?: EnterpriseSSOService;
  private rbacService?: EnterpriseRBACService;
  private mfaService?: EnterpriseMFAService;
  private auditService?: EnterpriseAuditService;
  private enterpriseMiddleware?: EnterpriseSecurityMiddleware;
  private logger: SecurityLogger;
  private config: SecurityMiddlewareConfig;

  constructor(config: SecurityMiddlewareConfig) {
    this.config = config;
    this.authService = config.authenticationService;
    this.authzService = config.authorizationService;
    this.ssoService = config.ssoService;
    this.rbacService = config.rbacService;
    this.mfaService = config.mfaService;
    this.auditService = config.auditService;
    this.logger = new SecurityLogger('SecurityMiddleware');

    // Initialize enterprise middleware if enabled and all services available
    if (this.isEnterpriseEnabled()) {
      this.initializeEnterpriseMiddleware();
    }
  }

  /**
   * Initialize enterprise security middleware
   */
  private initializeEnterpriseMiddleware(): void {
    if (!this.ssoService || !this.rbacService || !this.mfaService || !this.auditService) {
      this.logger.warn('Enterprise mode enabled but some services missing. Falling back to standard security.');
      return;
    }

    const securityConfig = {
      ...defaultSecurityConfig,
      ...this.config.securityConfig,
    };

    this.enterpriseMiddleware = createSecurityMiddleware(securityConfig, {
      ssoService: this.ssoService,
      rbacService: this.rbacService,
      mfaService: this.mfaService,
      auditService: this.auditService,
    });

    this.logger.info('Enterprise security middleware initialized');
  }

  /**
   * Check if enterprise features are enabled
   */
  private isEnterpriseEnabled(): boolean {
    return this.config.enableEnterprise === true;
  }

  /**
   * Get the complete middleware stack
   */
  getMiddlewareStack() {
    if (this.isEnterpriseEnabled() && this.enterpriseMiddleware) {
      // Return enterprise middleware stack
      return this.enterpriseMiddleware.initializeMiddleware();
    }

    // Return standard middleware stack
    return [
      this.securityHeaders(),
      this.rateLimit(),
      this.requestLogger(),
      this.authenticate(),
      this.errorHandler(),
    ];
  }

  /**
   * Security headers middleware using Helmet
   */
  securityHeaders() {
    return helmet({
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
          fontSrc: ["'self'", "https://fonts.gstatic.com"],
          imgSrc: ["'self'", "data:", "https:"],
          scriptSrc: ["'self'"],
          connectSrc: ["'self'", "https://api.courtlens.com"],
          frameSrc: ["'none'"],
          objectSrc: ["'none'"],
          baseUri: ["'self'"],
          formAction: ["'self'"],
          frameAncestors: ["'none'"],
          upgradeInsecureRequests: []
        }
      },
      hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
      },
      noSniff: true,
      xssFilter: true,
      referrerPolicy: { policy: "strict-origin-when-cross-origin" }
    });
  }

  /**
   * Rate limiting middleware
   */
  rateLimit(options?: any) {
    const defaultOptions = {
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 100, // limit each IP to 100 requests per windowMs
      message: 'Too many requests from this IP, please try again later',
      standardHeaders: true,
      legacyHeaders: false,
      keyGenerator: (req: Request) => {
        return req.ip || req.connection.remoteAddress || 'unknown';
      }
    };

    return rateLimit({ ...defaultOptions, ...options });
  }

  /**
   * Strict rate limiting for authentication endpoints
   */
  authRateLimit() {
    return rateLimit({
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 5, // limit each IP to 5 login attempts per window
      message: 'Too many login attempts, please try again later',
      standardHeaders: true,
      legacyHeaders: false,
      skipSuccessfulRequests: true
    });
  }

  /**
   * Authentication middleware
   */
  authenticate(options: { optional?: boolean } = {}) {
    return async (req: Request, res: Response, next: NextFunction) => {
      try {
        const authHeader = req.headers.authorization;
        
        if (!authHeader && options.optional) {
          return next();
        }

        if (!authHeader || !authHeader.startsWith('Bearer ')) {
          throw new AuthenticationError('Missing or invalid authorization header');
        }

        const token = authHeader.substring(7);
        const context = await this.authService.validateToken(token);

        // Add security context to request
        req.security = {
          ...context,
          ipAddress: req.ip || req.connection.remoteAddress || 'unknown',
          userAgent: req.headers['user-agent'] || 'unknown',
          requestId: req.headers['x-request-id'] as string || '',
          timestamp: new Date()
        };

        next();

      } catch (error) {
        this.logger.warn('Authentication failed', {
          ip: req.ip,
          userAgent: req.headers['user-agent'],
          path: req.path,
          error: error instanceof Error ? error.message : 'Unknown error'
        });

        if (options.optional) {
          return next();
        }

        if (error instanceof AuthenticationError) {
          return res.status(401).json({
            error: 'Unauthorized',
            message: error.message
          });
        }

        return res.status(500).json({
          error: 'Internal Server Error',
          message: 'Authentication service error'
        });
      }
    };
  }

  /**
   * Authorization middleware
   */
  authorize(permissionCheck: PermissionCheck) {
    return async (req: Request, res: Response, next: NextFunction) => {
      try {
        if (!req.security) {
          throw new AuthorizationError('No security context available');
        }

        await this.authzService.requirePermission(req.security, permissionCheck);
        next();

      } catch (error) {
        this.logger.warn('Authorization failed', {
          userId: req.security?.user?.id,
          resource: permissionCheck.resource,
          action: permissionCheck.action,
          ip: req.ip,
          path: req.path,
          error: error instanceof Error ? error.message : 'Unknown error'
        });

        if (error instanceof AuthorizationError) {
          return res.status(403).json({
            error: 'Forbidden',
            message: error.message
          });
        }

        return res.status(500).json({
          error: 'Internal Server Error',
          message: 'Authorization service error'
        });
      }
    };
  }

  /**
   * Organization access middleware
   */
  requireOrganizationAccess(organizationIdParam: string = 'organizationId') {
    return async (req: Request, res: Response, next: NextFunction) => {
      try {
        if (!req.security) {
          throw new AuthorizationError('No security context available');
        }

        const organizationId = req.params[organizationIdParam];
        if (!organizationId) {
          throw new ValidationError('Organization ID is required');
        }

        const canAccess = await this.authzService.canAccessOrganization(
          req.security,
          organizationId
        );

        if (!canAccess) {
          throw new AuthorizationError('Access denied to organization');
        }

        next();

      } catch (error) {
        this.logger.warn('Organization access denied', {
          userId: req.security?.user?.id,
          organizationId: req.params[organizationIdParam],
          error: error instanceof Error ? error.message : 'Unknown error'
        });

        if (error instanceof AuthorizationError || error instanceof ValidationError) {
          return res.status(403).json({
            error: 'Forbidden',
            message: error.message
          });
        }

        return res.status(500).json({
          error: 'Internal Server Error',
          message: 'Access control service error'
        });
      }
    };
  }

  /**
   * Input validation middleware
   */
  validateInput(validations: any[]) {
    return [
      ...validations,
      (req: Request, res: Response, next: NextFunction) => {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
          this.logger.warn('Input validation failed', {
            errors: errors.array(),
            ip: req.ip,
            path: req.path
          });

          return res.status(400).json({
            error: 'Validation Error',
            message: 'Invalid input data',
            details: errors.array()
          });
        }
        next();
      }
    ];
  }

  /**
   * CORS middleware with security considerations
   */
  cors(options: any = {}) {
    const defaultOptions = {
      origin: (origin: string, callback: Function) => {
        // In production, maintain a whitelist of allowed origins
        const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'];
        
        if (!origin || allowedOrigins.includes(origin)) {
          callback(null, true);
        } else {
          callback(new Error('Not allowed by CORS'));
        }
      },
      credentials: true,
      optionsSuccessStatus: 200,
      methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
      allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID']
    };

    return (req: Request, res: Response, next: NextFunction) => {
      const config = { ...defaultOptions, ...options };
      
      // Apply CORS headers
      if (config.origin) {
        const origin = req.headers.origin;
        if (typeof config.origin === 'function') {
          config.origin(origin, (err: any, allowed: boolean) => {
            if (err) {
              return res.status(403).json({ error: 'CORS policy violation' });
            }
            if (allowed) {
              res.header('Access-Control-Allow-Origin', origin);
            }
          });
        } else {
          res.header('Access-Control-Allow-Origin', config.origin);
        }
      }

      res.header('Access-Control-Allow-Methods', config.methods.join(','));
      res.header('Access-Control-Allow-Headers', config.allowedHeaders.join(','));
      res.header('Access-Control-Allow-Credentials', config.credentials.toString());

      if (req.method === 'OPTIONS') {
        return res.status(config.optionsSuccessStatus).end();
      }

      next();
    };
  }

  /**
   * Error handling middleware
   */
  errorHandler() {
    return (error: any, req: Request, res: Response, next: NextFunction) => {
      this.logger.error('Unhandled error', {
        error: error.message,
        stack: error.stack,
        ip: req.ip,
        path: req.path,
        method: req.method,
        userId: req.security?.user?.id
      });

      // Don't expose internal errors in production
      const isDevelopment = process.env.NODE_ENV === 'development';

      if (error instanceof AuthenticationError) {
        return res.status(401).json({
          error: 'Unauthorized',
          message: error.message
        });
      }

      if (error instanceof AuthorizationError) {
        return res.status(403).json({
          error: 'Forbidden',
          message: error.message
        });
      }

      if (error instanceof ValidationError) {
        return res.status(400).json({
          error: 'Validation Error',
          message: error.message,
          details: error.details
        });
      }

      // Generic error response
      res.status(500).json({
        error: 'Internal Server Error',
        message: isDevelopment ? error.message : 'An unexpected error occurred',
        ...(isDevelopment && { stack: error.stack })
      });
    };
  }

  /**
   * Request logging middleware
   */
  requestLogger() {
    return (req: Request, res: Response, next: NextFunction) => {
      const startTime = Date.now();

      // Log request
      this.logger.info('Request started', {
        method: req.method,
        path: req.path,
        ip: req.ip,
        userAgent: req.headers['user-agent'],
        userId: req.security?.user?.id
      });

      // Log response when finished
      res.on('finish', () => {
        const duration = Date.now() - startTime;
        this.logger.info('Request completed', {
          method: req.method,
          path: req.path,
          statusCode: res.statusCode,
          duration,
          ip: req.ip,
          userId: req.security?.user?.id
        });
      });

      next();
    };
  }
}

// Common validation schemas
export const ValidationSchemas = {
  email: body('email').isEmail().normalizeEmail(),
  password: body('password')
    .isLength({ min: 8, max: 128 })
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
    .withMessage('Password must contain at least one lowercase letter, one uppercase letter, one number, and one special character'),
  uuid: (field: string) => body(field).isUUID(),
  requiredString: (field: string) => body(field).isString().trim().isLength({ min: 1 })
};
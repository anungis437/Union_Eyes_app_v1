/**
 * Azure Key Vault Integration Service
 * Secure key retrieval for production environments
 */

import { DefaultAzureCredential } from '@azure/identity';
import { SecretClient } from '@azure/keyvault-secrets';

interface KeyVaultConfig {
  vaultUrl: string;
  clientId?: string;
  clientSecret?: string;
  tenantId?: string;
}

interface SecretValue {
  value: string;
  expiresOn?: Date;
  contentType?: string;
}

export class AzureKeyVaultService {
  private client: SecretClient;
  private cache: Map<string, { value: string; expiresAt: number }> = new Map();
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes

  constructor(config: KeyVaultConfig) {
    const credential = config.clientSecret 
      ? new DefaultAzureCredential({
          tenantId: config.tenantId,
          managedIdentityClientId: config.clientId,
        })
      : new DefaultAzureCredential();

    this.client = new SecretClient(config.vaultUrl, credential);
  }

  /**
   * Get secret value from Azure Key Vault with caching
   */
  async getSecret(secretName: string): Promise<string> {
    // Check cache first
    const cached = this.cache.get(secretName);
    if (cached && cached.expiresAt > Date.now()) {
      return cached.value;
    }

    try {
      const response = await this.client.getSecret(secretName);
      
      if (!response.value) {
        throw new Error(`Secret '${secretName}' has no value`);
      }

      // Cache the result
      this.cache.set(secretName, {
        value: response.value,
        expiresAt: Date.now() + this.CACHE_TTL
      });

      return response.value;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(`Failed to retrieve secret '${secretName}':`, error);
      throw new Error(`Failed to retrieve secret '${secretName}': ${errorMessage}`);
    }
  }

  /**
   * Get multiple secrets in parallel
   */
  async getSecrets(secretNames: string[]): Promise<Record<string, string>> {
    const promises = secretNames.map(async (name) => {
      const value = await this.getSecret(name);
      return { name, value };
    });

    const results = await Promise.all(promises);
    
    return results.reduce((acc, { name, value }) => {
      acc[name] = value;
      return acc;
    }, {} as Record<string, string>);
  }

  /**
   * Clear cache for specific secret or all secrets
   */
  clearCache(secretName?: string): void {
    if (secretName) {
      this.cache.delete(secretName);
    } else {
      this.cache.clear();
    }
  }

  /**
   * Check if Key Vault is accessible
   */
  async healthCheck(): Promise<boolean> {
    try {
      // Try to list secrets (without values) to test connectivity
      const iterator = this.client.listPropertiesOfSecrets();
      await iterator.next();
      return true;
    } catch (error) {
      console.error('Key Vault health check failed:', error);
      return false;
    }
  }
}

/**
 * Environment-aware secret retrieval
 * Falls back to environment variables in development
 */
export class SecureConfigService {
  private keyVaultService?: AzureKeyVaultService;
  private isProduction: boolean;

  constructor() {
    this.isProduction = process.env.NODE_ENV === 'production';
    
    if (this.isProduction && process.env.AZURE_KEY_VAULT_URL) {
      this.keyVaultService = new AzureKeyVaultService({
        vaultUrl: process.env.AZURE_KEY_VAULT_URL,
        tenantId: process.env.AZURE_TENANT_ID,
        clientId: process.env.AZURE_CLIENT_ID,
        clientSecret: process.env.AZURE_CLIENT_SECRET
      });
    }
  }

  /**
   * Get configuration value from Key Vault (production) or environment (development)
   */
  async getConfig(key: string, fallbackEnvVar?: string): Promise<string> {
    // In production, try Key Vault first
    if (this.isProduction && this.keyVaultService) {
      try {
        return await this.keyVaultService.getSecret(key);
      } catch (error) {
        console.warn(`Failed to get ${key} from Key Vault, trying environment variable`);
      }
    }

    // Fallback to environment variable
    const envVar = fallbackEnvVar || key;
    const value = process.env[envVar];
    
    if (!value) {
      throw new Error(`Configuration '${key}' not found in Key Vault or environment variables`);
    }

    return value;
  }

  /**
   * Get Azure AI Services configuration
   */
  async getAzureAIConfig() {
    return {
      endpoint: await this.getConfig('azure-ai-services-endpoint', 'AZURE_AI_SERVICES_ENDPOINT'),
      apiKey: await this.getConfig('azure-ai-services-key', 'AZURE_AI_SERVICES_API_KEY'),
      location: await this.getConfig('azure-ai-services-location', 'AZURE_AI_SERVICES_LOCATION')
    };
  }

  /**
   * Get Azure OpenAI configuration
   */
  async getAzureOpenAIConfig() {
    return {
      endpoint: await this.getConfig('azure-openai-endpoint', 'AZURE_OPENAI_ENDPOINT'),
      apiKey: await this.getConfig('azure-openai-key', 'AZURE_OPENAI_API_KEY'),
      apiVersion: await this.getConfig('azure-openai-api-version', 'AZURE_OPENAI_API_VERSION')
    };
  }

  /**
   * Health check for the configuration service
   */
  async healthCheck(): Promise<{ keyVault: boolean; environment: boolean }> {
    const results = {
      keyVault: false,
      environment: true // Environment variables are always available
    };

    if (this.keyVaultService) {
      results.keyVault = await this.keyVaultService.healthCheck();
    }

    return results;
  }
}

// Singleton instance
export const secureConfig = new SecureConfigService();

// Export types
export type { KeyVaultConfig, SecretValue };
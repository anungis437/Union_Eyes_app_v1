// CourtLens Enterprise RBAC Service
// Advanced role-based access control with hierarchical roles and dynamic permissions

import { EventEmitter } from 'events';
import { SecurityLogger } from '../utils/logger';
import { Permission, Role, User } from '../types/index';
import { EnterpriseAuditService } from './enterprise-audit.service';

export interface EnterpriseRole extends Role {
  hierarchy: number; // Higher number = more privileges
  inheritsFrom?: string[]; // Role IDs this role inherits from
  conditions?: RoleCondition[]; // Conditional permissions
  timeRestrictions?: TimeRestriction[];
  ipRestrictions?: string[]; // CIDR blocks
  organizationRestrictions?: string[]; // Organization IDs
  isSystem?: boolean; // Cannot be deleted or modified
  approvalRequired?: boolean; // Requires approval for assignment
  expiresAt?: Date; // Role expiration
  isActive: boolean; // Add isActive to extend base Role
  createdAt: Date; // Add createdAt
  updatedAt: Date; // Add updatedAt
  riskLevel?: 'low' | 'medium' | 'high' | 'critical'; // Risk level for role
  maxConcurrentSessions?: number; // Maximum concurrent sessions allowed
  requiresMFA?: boolean; // Requires MFA for access
  dataClassificationAccess?: string[]; // Data classifications this role can access
  businessUnits?: string[]; // Business units this role applies to
  geographicRestrictions?: string[]; // Geographic restrictions (country codes)
}

export interface RoleCondition {
  type: 'time' | 'location' | 'device' | 'mfa' | 'approval' | 'data_classification' | 'business_unit' | 'risk_level';
  operator: 'equals' | 'not_equals' | 'in' | 'not_in' | 'greater_than' | 'less_than' | 'contains' | 'within_range';
  value: any;
  description: string;
  metadata?: Record<string, any>;
}

export interface TimeRestriction {
  daysOfWeek: number[]; // 0-6, Sunday = 0
  startTime: string; // HH:MM format
  endTime: string; // HH:MM format
  timezone: string;
}

export interface RoleAssignment {
  id: string;
  userId: string;
  roleId: string;
  organizationId?: string;
  tenantId?: string;
  assignedBy: string;
  assignedAt: Date;
  expiresAt?: Date;
  isActive: boolean;
  conditions?: RoleCondition[];
  approvalStatus?: 'pending' | 'approved' | 'rejected';
  approvedBy?: string;
  approvedAt?: Date;
}

export interface PermissionEvaluation {
  hasPermission: boolean;
  reason: string;
  conditions: string[];
  restrictions: string[];
  effectiveRoles: string[];
}

export class EnterpriseRBACService extends EventEmitter {
  private logger: SecurityLogger;
  private auditService: EnterpriseAuditService;
  private roles: Map<string, EnterpriseRole> = new Map();
  private roleAssignments: Map<string, RoleAssignment[]> = new Map();
  private permissionCache: Map<string, PermissionEvaluation> = new Map();

  constructor(auditService: EnterpriseAuditService) {
    super();
    this.logger = new SecurityLogger('EnterpriseRBACService');
    this.auditService = auditService;
    this.initializeSystemRoles();
  }

  /**
   * Initialize system roles that cannot be modified
   */
  private initializeSystemRoles(): void {
    const systemRoles: EnterpriseRole[] = [
      {
        id: 'system_admin',
        name: 'System Administrator',
        description: 'Full system access',
        permissions: [{ id: 'all', name: 'All Permissions', resource: '*', action: '*' }],
        hierarchy: 1000,
        isSystem: true,
        approvalRequired: true,
        organizationId: 'system',
        isSystemRole: true,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        id: 'org_admin',
        name: 'Organization Administrator',
        description: 'Full organization access',
        permissions: [{ id: 'org_all', name: 'Organization All', resource: 'organization', action: '*' }],
        hierarchy: 900,
        isSystem: true,
        approvalRequired: true,
        organizationId: 'system',
        isSystemRole: true,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        id: 'security_admin',
        name: 'Security Administrator',
        description: 'Security management access',
        permissions: [
          { id: 'security_all', name: 'Security All', resource: 'security', action: '*' },
          { id: 'audit_read', name: 'Audit Read', resource: 'audit', action: 'read' },
          { id: 'users_read', name: 'Users Read', resource: 'users', action: 'read' }
        ],
        hierarchy: 850,
        isSystem: true,
        approvalRequired: true,
        organizationId: 'system',
        isSystemRole: true,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        id: 'tenant_admin',
        name: 'Tenant Administrator',
        description: 'Tenant-level administrative access',
        permissions: [{ id: 'tenant_all', name: 'Tenant All', resource: 'tenant', action: '*' }],
        hierarchy: 800,
        organizationId: 'system',
        isSystemRole: false,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        id: 'user',
        name: 'Standard User',
        description: 'Basic user access',
        permissions: [
          { id: 'profile_read', name: 'Read Own Profile', resource: 'profile', action: 'read' },
          { id: 'profile_update', name: 'Update Own Profile', resource: 'profile', action: 'update' }
        ],
        hierarchy: 100,
        isSystem: true,
        organizationId: 'system',
        isSystemRole: false,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ];

    systemRoles.forEach(role => {
      this.roles.set(role.id, role);
    });

    this.logger.info('System roles initialized', {
      roleCount: systemRoles.length
    });
  }

  /**
   * Create a new role with hierarchy validation
   */
  async createRole(role: Omit<EnterpriseRole, 'id' | 'createdAt' | 'updatedAt'>): Promise<EnterpriseRole> {
    try {
      // Validate hierarchy
      if (role.hierarchy > 999 && !role.isSystem) {
        throw new Error('Non-system roles cannot have hierarchy above 999');
      }

      // Validate inheritance
      if (role.inheritsFrom) {
        await this.validateRoleInheritance(role.inheritsFrom, role.hierarchy);
      }

      const newRole: EnterpriseRole = {
        id: this.generateRoleId(),
        createdAt: new Date(),
        updatedAt: new Date(),
        ...role
      };

      this.roles.set(newRole.id, newRole);

      await this.auditService.logEvent({
        action: 'role_created',
        resource: 'rbac_role',
        resourceId: newRole.id,
        userId: 'system',
        outcome: 'success',
        severity: 'medium',
        source: { 
          ip: 'system',
          userAgent: 'system',
        },
        details: {
          roleName: newRole.name,
          hierarchy: newRole.hierarchy,
          permissions: newRole.permissions.length
        },
        complianceFlags: ['access_control'],
        searchableFields: ['action', 'resource', 'userId', 'roleName'],
      });

      this.logger.info('Role created', {
        roleId: newRole.id,
        roleName: newRole.name,
        hierarchy: newRole.hierarchy
      });

      return newRole;

    } catch (error) {
      await this.auditService.logEvent({
        action: 'role_creation_failed',
        resource: 'rbac_role',
        resourceId: 'unknown',
        userId: 'system',
        outcome: 'failure',
        severity: 'medium',
        source: { 
          ip: 'system',
          userAgent: 'system',
        },
        details: {
          error: error instanceof Error ? error.message : 'Unknown error',
          roleName: role.name
        },
        complianceFlags: ['access_control'],
        searchableFields: ['action', 'resource', 'userId', 'roleName'],
      });

      this.logger.error('Failed to create role', {
        error: error instanceof Error ? error.message : 'Unknown error',
        roleName: role.name
      });

      throw error;
    }
  }

  /**
   * Assign role to user with conditional logic
   */
  async assignRole(
    userId: string,
    roleId: string,
    assignedBy: string,
    options?: {
      organizationId?: string;
      tenantId?: string;
      expiresAt?: Date;
      conditions?: RoleCondition[];
      requireApproval?: boolean;
    }
  ): Promise<RoleAssignment> {
    try {
      const role = this.roles.get(roleId);
      if (!role) {
        throw new Error(`Role not found: ${roleId}`);
      }

      if (!role.isActive) {
        throw new Error(`Role is inactive: ${roleId}`);
      }

      // Check if approval is required
      const requiresApproval = role.approvalRequired || options?.requireApproval;

      const assignment: RoleAssignment = {
        id: this.generateAssignmentId(),
        userId,
        roleId,
        organizationId: options?.organizationId,
        tenantId: options?.tenantId,
        assignedBy,
        assignedAt: new Date(),
        expiresAt: options?.expiresAt,
        isActive: !requiresApproval, // Inactive until approved if approval required
        conditions: options?.conditions,
        approvalStatus: requiresApproval ? 'pending' : 'approved'
      };

      // Store assignment
      const userAssignments = this.roleAssignments.get(userId) || [];
      userAssignments.push(assignment);
      this.roleAssignments.set(userId, userAssignments);

      // Clear permission cache for user
      this.clearUserPermissionCache(userId);

      await this.auditService.logEvent({
        action: 'role_assigned',
        resource: 'rbac_assignment',
        resourceId: assignment.id,
        outcome: 'success',
        severity: 'medium',
        userId: assignedBy,
        source: { 
          ip: 'system',
          userAgent: 'system',
        },
        details: {
          targetUserId: userId,
          roleId,
          roleName: role.name,
          requiresApproval,
          organizationId: options?.organizationId,
          tenantId: options?.tenantId
        },
        complianceFlags: ['access_control'],
        searchableFields: ['action', 'resource', 'userId', 'targetUserId', 'roleId'],
      });

      this.logger.info('Role assigned', {
        assignmentId: assignment.id,
        userId,
        roleId,
        assignedBy,
        requiresApproval
      });

      return assignment;

    } catch (error) {
      await this.auditService.logEvent({
        action: 'role_assignment_failed',
        resource: 'rbac_assignment',
        resourceId: 'unknown',
        outcome: 'failure',
        severity: 'medium',
        userId: assignedBy,
        source: { 
          ip: 'system',
          userAgent: 'system',
        },
        details: {
          error: error instanceof Error ? error.message : 'Unknown error',
          targetUserId: userId,
          roleId
        },
        complianceFlags: ['access_control'],
        searchableFields: ['action', 'resource', 'userId', 'targetUserId', 'roleId'],
      });

      this.logger.error('Failed to assign role', {
        error: error instanceof Error ? error.message : 'Unknown error',
        userId,
        roleId,
        assignedBy
      });

      throw error;
    }
  }

  /**
   * Get user roles
   */
  getUserRoles(userId: string): EnterpriseRole[] {
    const userAssignments = Array.from(this.roleAssignments.values())
      .flat()
      .filter(assignment => assignment.userId === userId && assignment.isActive);
    
    return userAssignments
      .map(assignment => this.roles.get(assignment.roleId))
      .filter((role): role is EnterpriseRole => role !== undefined);
  }

  /**
   * Check access with comprehensive evaluation
   */
  async checkAccess(request: {
    userId: string;
    permission: string;
    context?: {
      organizationId?: string;
      tenantId?: string;
      resourceId?: string;
      ip?: string;
      userAgent?: string;
    };
  }): Promise<{ granted: boolean; reason?: string; }> {
    try {
      const evaluation = await this.hasPermission(
        request.userId, 
        request.permission, 
        request.context
      );
      
      return {
        granted: evaluation.hasPermission,
        reason: evaluation.hasPermission ? 'Access granted' : evaluation.reason
      };
    } catch (error) {
      return {
        granted: false,
        reason: error instanceof Error ? error.message : 'Access check failed'
      };
    }
  }

  /**
   * Evaluate permission with advanced logic
   */
  async hasPermission(
    userId: string,
    permission: string,
    context?: {
      organizationId?: string;
      tenantId?: string;
      resourceId?: string;
      ip?: string;
      userAgent?: string;
      mfaVerified?: boolean;
    }
  ): Promise<PermissionEvaluation> {
    try {
      const cacheKey = this.generateCacheKey(userId, permission, context);
      const cached = this.permissionCache.get(cacheKey);
      
      if (cached) {
        return cached;
      }

      const userAssignments = this.roleAssignments.get(userId) || [];
      const activeAssignments = userAssignments.filter(a => 
        a.isActive && 
        a.approvalStatus === 'approved' &&
        (!a.expiresAt || a.expiresAt > new Date())
      );

      const evaluation: PermissionEvaluation = {
        hasPermission: false,
        reason: '',
        conditions: [],
        restrictions: [],
        effectiveRoles: []
      };

      for (const assignment of activeAssignments) {
        const role = this.roles.get(assignment.roleId);
        if (!role || !role.isActive) continue;

        // Check organizational restrictions
        if (context?.organizationId && assignment.organizationId && 
            assignment.organizationId !== context.organizationId) {
          continue;
        }

        // Check tenant restrictions
        if (context?.tenantId && assignment.tenantId && 
            assignment.tenantId !== context.tenantId) {
          continue;
        }

        // Check time restrictions
        if (role.timeRestrictions && !this.checkTimeRestrictions(role.timeRestrictions)) {
          evaluation.restrictions.push(`Time restriction for role ${role.name}`);
          continue;
        }

        // Check IP restrictions
        if (role.ipRestrictions && context?.ip && 
            !this.checkIpRestrictions(role.ipRestrictions, context.ip)) {
          evaluation.restrictions.push(`IP restriction for role ${role.name}`);
          continue;
        }

        // Check role conditions
        if (assignment.conditions && !this.checkRoleConditions(assignment.conditions, context)) {
          evaluation.conditions.push(`Role conditions not met for ${role.name}`);
          continue;
        }

        // Check if role has permission
        if (this.roleHasPermission(role, permission)) {
          evaluation.hasPermission = true;
          evaluation.effectiveRoles.push(role.name);
          evaluation.reason = `Granted by role: ${role.name}`;
          break;
        }
      }

      if (!evaluation.hasPermission) {
        evaluation.reason = 'No roles with required permission found';
      }

      // Cache the result for 5 minutes
      this.permissionCache.set(cacheKey, evaluation);
      setTimeout(() => this.permissionCache.delete(cacheKey), 5 * 60 * 1000);

      // Log permission check
      await this.auditService.logEvent({
        action: 'permission_check',
        resource: 'rbac_permission',
        resourceId: permission,
        outcome: evaluation.hasPermission ? 'success' : 'denied',
        severity: evaluation.hasPermission ? 'low' : 'medium',
        userId,
        source: { 
          ip: context?.ip || 'unknown',
          userAgent: context?.userAgent || 'unknown',
        },
        details: {
          permission,
          hasPermission: evaluation.hasPermission,
          reason: evaluation.reason,
          effectiveRoles: evaluation.effectiveRoles,
          organizationId: context?.organizationId,
          tenantId: context?.tenantId
        },
        complianceFlags: ['access_control'],
        searchableFields: ['action', 'resource', 'userId', 'permission', 'outcome'],
      });

      return evaluation;

    } catch (error) {
      this.logger.error('Failed to evaluate permission', {
        error: error instanceof Error ? error.message : 'Unknown error',
        userId,
        permission
      });

      return {
        hasPermission: false,
        reason: 'Error evaluating permission',
        conditions: [],
        restrictions: [],
        effectiveRoles: []
      };
    }
  }

  /**
   * Approve pending role assignment
   */
  async approveRoleAssignment(
    assignmentId: string,
    approvedBy: string,
    approved: boolean
  ): Promise<void> {
    try {
      let assignment: RoleAssignment | undefined;
      let userId: string | undefined;

      // Find the assignment
      for (const [uid, assignments] of this.roleAssignments) {
        const found = assignments.find(a => a.id === assignmentId);
        if (found) {
          assignment = found;
          userId = uid;
          break;
        }
      }

      if (!assignment || !userId) {
        throw new Error(`Assignment not found: ${assignmentId}`);
      }

      if (assignment.approvalStatus !== 'pending') {
        throw new Error(`Assignment is not pending approval: ${assignmentId}`);
      }

      assignment.approvalStatus = approved ? 'approved' : 'rejected';
      assignment.approvedBy = approvedBy;
      assignment.approvedAt = new Date();
      assignment.isActive = approved;

      // Clear permission cache for user
      this.clearUserPermissionCache(userId);

      const role = this.roles.get(assignment.roleId);

      await this.auditService.logEvent({
        action: approved ? 'role_assignment_approved' : 'role_assignment_rejected',
        resource: 'rbac_assignment',
        resourceId: assignmentId,
        outcome: 'success',
        severity: 'medium',
        userId: approvedBy,
        source: { 
          ip: 'system',
          userAgent: 'system',
        },
        details: {
          targetUserId: userId,
          roleId: assignment.roleId,
          roleName: role?.name,
          approved
        },
        complianceFlags: ['access_control'],
        searchableFields: ['action', 'resource', 'userId', 'targetUserId', 'roleId'],
      });

      this.logger.info('Role assignment approval processed', {
        assignmentId,
        userId,
        approvedBy,
        approved
      });

    } catch (error) {
      await this.auditService.logEvent({
        action: 'role_assignment_approval_failed',
        resource: 'rbac_assignment',
        resourceId: assignmentId,
        outcome: 'failure',
        severity: 'medium',
        userId: approvedBy,
        source: { 
          ip: 'system',
          userAgent: 'system',
        },
        details: {
          error: error instanceof Error ? error.message : 'Unknown error',
          approved
        },
        complianceFlags: ['access_control'],
        searchableFields: ['action', 'resource', 'userId', 'assignmentId'],
      });

      this.logger.error('Failed to process role assignment approval', {
        error: error instanceof Error ? error.message : 'Unknown error',
        assignmentId,
        approvedBy,
        approved
      });

      throw error;
    }
  }

  /**
   * Get effective roles for user
   */
  getEffectiveRoles(userId: string, context?: { organizationId?: string; tenantId?: string }): EnterpriseRole[] {
    const userAssignments = this.roleAssignments.get(userId) || [];
    const activeAssignments = userAssignments.filter(a => 
      a.isActive && 
      a.approvalStatus === 'approved' &&
      (!a.expiresAt || a.expiresAt > new Date()) &&
      (!context?.organizationId || !a.organizationId || a.organizationId === context.organizationId) &&
      (!context?.tenantId || !a.tenantId || a.tenantId === context.tenantId)
    );

    const roles: EnterpriseRole[] = [];
    const inheritedRoles = new Set<string>();

    for (const assignment of activeAssignments) {
      const role = this.roles.get(assignment.roleId);
      if (role && role.isActive) {
        roles.push(role);
        
        // Add inherited roles
        if (role.inheritsFrom) {
          this.addInheritedRoles(role.inheritsFrom, inheritedRoles, roles);
        }
      }
    }

    // Sort by hierarchy (highest first)
    return roles.sort((a, b) => b.hierarchy - a.hierarchy);
  }

  /**
   * Private helper methods
   */

  private validateRoleInheritance(inheritsFrom: string[], hierarchy: number): void {
    for (const roleId of inheritsFrom) {
      const parentRole = this.roles.get(roleId);
      if (!parentRole) {
        throw new Error(`Parent role not found: ${roleId}`);
      }
      if (parentRole.hierarchy >= hierarchy) {
        throw new Error(`Parent role hierarchy must be lower: ${roleId}`);
      }
    }
  }

  private addInheritedRoles(
    inheritsFrom: string[], 
    visited: Set<string>, 
    roles: EnterpriseRole[]
  ): void {
    for (const roleId of inheritsFrom) {
      if (visited.has(roleId)) continue;
      
      const role = this.roles.get(roleId);
      if (role && role.isActive) {
        visited.add(roleId);
        roles.push(role);
        
        if (role.inheritsFrom) {
          this.addInheritedRoles(role.inheritsFrom, visited, roles);
        }
      }
    }
  }

  private roleHasPermission(role: EnterpriseRole, permission: string): boolean {
    return role.permissions.some(p => {
      // Check for wildcard permissions
      if (p.resource === '*' && p.action === '*') return true;
      
      // Parse the permission string (format: "resource:action")
      const [reqResource, reqAction] = permission.split(':');
      
      // Check exact match
      if (p.resource === reqResource && p.action === reqAction) return true;
      
      // Check resource wildcard
      if (p.resource === reqResource && p.action === '*') return true;
      
      // Check action wildcard
      if (p.resource === '*' && p.action === reqAction) return true;
      
      return false;
    });
  }

  private checkTimeRestrictions(restrictions: TimeRestriction[]): boolean {
    const now = new Date();
    const currentDay = now.getDay();
    const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;

    return restrictions.some(restriction => {
      if (!restriction.daysOfWeek.includes(currentDay)) return false;
      if (currentTime < restriction.startTime || currentTime > restriction.endTime) return false;
      return true;
    });
  }

  private checkIpRestrictions(restrictions: string[], userIp: string): boolean {
    // This would typically use a proper CIDR checking library
    return restrictions.some(cidr => {
      // Simple implementation - in production use proper CIDR checking
      if (cidr.includes('/')) {
        const [network] = cidr.split('/');
        return userIp.startsWith(network.split('.').slice(0, 3).join('.'));
      }
      return cidr === userIp;
    });
  }

  private checkRoleConditions(conditions: RoleCondition[], context?: any): boolean {
    return conditions.every(condition => {
      switch (condition.type) {
        case 'mfa':
          return context?.mfaVerified === true;
        case 'time':
          // Time-based conditions
          return this.evaluateTimeCondition(condition, context);
        case 'location':
          // Location-based conditions
          return this.evaluateLocationCondition(condition, context);
        default:
          return true;
      }
    });
  }

  private evaluateTimeCondition(condition: RoleCondition, context: any): boolean {
    // Implement time-based condition logic
    return true;
  }

  private evaluateLocationCondition(condition: RoleCondition, context: any): boolean {
    // Implement location-based condition logic
    return true;
  }

  private generateCacheKey(userId: string, permission: string, context?: any): string {
    return `${userId}:${permission}:${JSON.stringify(context || {})}`;
  }

  private clearUserPermissionCache(userId: string): void {
    for (const key of this.permissionCache.keys()) {
      if (key.startsWith(`${userId}:`)) {
        this.permissionCache.delete(key);
      }
    }
  }

  private generateRoleId(): string {
    return `role_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private generateAssignmentId(): string {
    return `assign_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
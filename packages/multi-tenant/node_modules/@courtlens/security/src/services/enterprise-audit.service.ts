// CourtLens Enterprise Audit Service
// Comprehensive audit logging for compliance and security monitoring with SOC 2 support

import { SecurityLogger } from '../utils/logger';
import { SecurityEvent } from '../types/index';
import crypto from 'crypto';
import { EventEmitter } from 'events';

export interface AuditEvent {
  id: string;
  timestamp: Date;
  userId?: string;
  organizationId?: string;
  tenantId?: string;
  action: string;
  resource: string;
  resourceId?: string;
  outcome: 'success' | 'failure' | 'denied';
  severity: 'low' | 'medium' | 'high' | 'critical';
  source: {
    ip: string;
    userAgent?: string;
    sessionId?: string;
    deviceFingerprint?: string;
    geolocation?: string;
  };
  details: Record<string, any>;
  complianceFlags: string[];
  retentionPeriod: number; // days
  hash?: string; // For tamper detection
  previousHash?: string; // Chain for integrity
  encrypted?: boolean;
  searchableFields: string[]; // Fields that can be searched
}

export interface SOC2ComplianceEvent extends AuditEvent {
  soc2Category: 'security' | 'availability' | 'processing_integrity' | 'confidentiality' | 'privacy';
  controlObjective: string;
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  requiresReview: boolean;
  reviewedBy?: string;
  reviewedAt?: Date;
  mitigationActions?: string[];
}

export interface ComplianceReport {
  reportId: string;
  generatedAt: Date;
  generatedBy: string;
  reportType: 'soc2' | 'gdpr' | 'hipaa' | 'custom';
  period: {
    start: Date;
    end: Date;
  };
  summary: {
    totalEvents: number;
    criticalEvents: number;
    failedAttempts: number;
    uniqueUsers: number;
    securityIncidents: number;
    dataAccess: number;
    privilegedAccess: number;
  };
  compliance: {
    soc2Compliant: boolean;
    gdprCompliant: boolean;
    hipaaCompliant: boolean;
    customChecks: Record<string, boolean>;
    violations: ComplianceViolation[];
  };
  events: AuditEvent[];
  digitalSignature: string;
}

export interface ComplianceViolation {
  id: string;
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  events: string[]; // Event IDs
  detectedAt: Date;
  status: 'open' | 'investigating' | 'resolved' | 'false_positive';
  assignedTo?: string;
  resolution?: string;
  resolvedAt?: Date;
}

export interface AuditConfiguration {
  enableRealTimeMonitoring: boolean;
  enableTamperDetection: boolean;
  enableEncryption: boolean;
  retentionPolicies: Record<string, number>; // Event type -> retention days
  alertThresholds: Record<string, number>;
  complianceStandards: string[];
  customRules: AuditRule[];
}

export interface AuditRule {
  id: string;
  name: string;
  description: string;
  condition: string; // JSON logic expression
  action: 'alert' | 'block' | 'escalate' | 'log';
  severity: 'low' | 'medium' | 'high' | 'critical';
  isActive: boolean;
}

export interface RealTimeAlert {
  id: string;
  triggeredAt: Date;
  eventId: string;
  ruleId: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  message: string;
  details: Record<string, any>;
  status: 'new' | 'acknowledged' | 'resolved' | 'false_positive';
  acknowledgedBy?: string;
  acknowledgedAt?: Date;
}

export class EnterpriseAuditService extends EventEmitter {
  private logger: SecurityLogger;
  private auditStore: Map<string, AuditEvent> = new Map();
  private retentionPolicies: Map<string, number> = new Map();
  private config: AuditConfiguration;
  private alerts: Map<string, RealTimeAlert> = new Map();
  private violations: Map<string, ComplianceViolation> = new Map();
  private lastHash: string = '';

  constructor() {
    super(); // Call EventEmitter constructor
    this.logger = new SecurityLogger('EnterpriseAuditService');
    this.config = this.getDefaultConfiguration();
    this.initializeRetentionPolicies();
    this.startRealTimeMonitoring();
  }

  /**
   * Initialize retention policies for different event types
   */
  private initializeRetentionPolicies(): void {
    this.retentionPolicies.set('authentication', 2555); // 7 years for SOX
    this.retentionPolicies.set('authorization', 2555);
    this.retentionPolicies.set('data_access', 2555);
    this.retentionPolicies.set('configuration_change', 2555);
    this.retentionPolicies.set('user_management', 2555);
    this.retentionPolicies.set('system_event', 365); // 1 year
    this.retentionPolicies.set('security_incident', 3650); // 10 years
  }

  /**
   * Get default audit configuration
   */
  private getDefaultConfiguration(): AuditConfiguration {
    return {
      enableRealTimeMonitoring: true,
      enableTamperDetection: true,
      enableEncryption: true,
      retentionPolicies: {
        'authentication': 2555,
        'authorization': 2555,
        'data_access': 2555,
        'system_event': 365,
      },
      alertThresholds: {
        'failed_login_attempts': 5,
        'privilege_escalation': 1,
        'data_export': 1,
      },
      complianceStandards: ['soc2', 'gdpr', 'hipaa'],
      customRules: [],
    };
  }

  /**
   * Start real-time monitoring for audit events
   */
  private startRealTimeMonitoring(): void {
    if (this.config.enableRealTimeMonitoring) {
      this.on('audit_event', (event: AuditEvent) => {
        this.processRealTimeAlert(event);
      });
    }
  }

  /**
   * Process real-time alerts for audit events
   */
  private async processRealTimeAlert(event: AuditEvent): Promise<void> {
    // Check alert thresholds and generate alerts if needed
    const ruleViolations = this.checkRuleViolations(event);
    
    for (const violation of ruleViolations) {
      const alert: RealTimeAlert = {
        id: crypto.randomUUID(),
        triggeredAt: new Date(),
        eventId: event.id,
        ruleId: violation.ruleId,
        severity: violation.severity,
        message: violation.message,
        details: { event, violation },
        status: 'new',
      };

      this.alerts.set(alert.id, alert);
      this.emit('security_alert', alert);
    }
  }

  /**
   * Check for rule violations in an audit event
   */
  private checkRuleViolations(event: AuditEvent): Array<{ ruleId: string; severity: 'low' | 'medium' | 'high' | 'critical'; message: string }> {
    const violations = [];

    // Example: Multiple failed login attempts
    if (event.action === 'login' && event.outcome === 'failure') {
      const recentFailures = Array.from(this.auditStore.values())
        .filter(e => 
          e.userId === event.userId &&
          e.action === 'login' &&
          e.outcome === 'failure' &&
          (Date.now() - e.timestamp.getTime()) < 300000 // 5 minutes
        ).length;

      if (recentFailures >= 5) {
        violations.push({
          ruleId: 'multiple_failed_logins',
          severity: 'high' as const,
          message: `Multiple failed login attempts detected for user ${event.userId}`,
        });
      }
    }

    return violations;
  }

  /**
   * Log an audit event
   */
  async logEvent(event: Omit<AuditEvent, 'id' | 'timestamp' | 'retentionPeriod'>): Promise<void> {
    try {
      const auditEvent: AuditEvent = {
        id: this.generateEventId(),
        timestamp: new Date(),
        retentionPeriod: this.getRetentionPeriod(event.action),
        ...event
      };

      // Store event
      this.auditStore.set(auditEvent.id, auditEvent);

      // Log for monitoring systems
      this.logger.info('Audit event logged', {
        eventId: auditEvent.id,
        action: auditEvent.action,
        outcome: auditEvent.outcome,
        severity: auditEvent.severity,
        userId: auditEvent.userId,
        organizationId: auditEvent.organizationId
      });

      // Check for critical events that need immediate attention
      if (auditEvent.severity === 'critical') {
        await this.handleCriticalEvent(auditEvent);
      }

      // Archive if needed
      await this.checkAndArchiveEvent(auditEvent);

    } catch (error) {
      this.logger.error('Failed to log audit event', {
        error: error instanceof Error ? error.message : 'Unknown error',
        action: event.action
      });
      throw error;
    }
  }

  /**
   * Generate compliance report
   */
  async generateComplianceReport(
    startDate: Date,
    endDate: Date,
    organizationId?: string
  ): Promise<ComplianceReport> {
    try {
      const events = Array.from(this.auditStore.values())
        .filter(event => {
          const inDateRange = event.timestamp >= startDate && event.timestamp <= endDate;
          const inOrg = !organizationId || event.organizationId === organizationId;
          return inDateRange && inOrg;
        });

      const summary = {
        totalEvents: events.length,
        criticalEvents: events.filter(e => e.severity === 'critical').length,
        failedAttempts: events.filter(e => e.outcome === 'failure').length,
        uniqueUsers: new Set(events.map(e => e.userId).filter(Boolean)).size,
        securityIncidents: events.filter(e => e.action.includes('security_incident')).length,
        dataAccess: events.filter(e => e.action.includes('data_access')).length,
        privilegedAccess: events.filter(e => e.action.includes('admin_') || e.action.includes('privileged_')).length
      };

      const violations = Array.from(this.violations.values()).filter(v => 
        v.detectedAt >= startDate && v.detectedAt <= endDate
      );

      const compliance = {
        soc2Compliant: this.checkSOC2Compliance(events),
        gdprCompliant: this.checkGDPRCompliance(events),
        hipaaCompliant: this.checkHIPAACompliance(events),
        customChecks: await this.runCustomComplianceChecks(events),
        violations
      };

      const report: ComplianceReport = {
        reportId: this.generateReportId(),
        generatedAt: new Date(),
        generatedBy: 'system', // Could be passed as parameter
        reportType: 'soc2', // Could be passed as parameter
        period: { start: startDate, end: endDate },
        summary,
        compliance,
        events,
        digitalSignature: await this.generateDigitalSignature(events)
      };

      this.logger.info('Compliance report generated', {
        reportId: report.reportId,
        period: report.period,
        eventCount: events.length,
        organizationId
      });

      return report;

    } catch (error) {
      this.logger.error('Failed to generate compliance report', {
        error: error instanceof Error ? error.message : 'Unknown error',
        startDate,
        endDate,
        organizationId
      });
      throw error;
    }
  }

  /**
   * Search audit events with filtering
   */
  async searchEvents(criteria: {
    userId?: string;
    organizationId?: string;
    action?: string;
    resource?: string;
    outcome?: 'success' | 'failure' | 'denied';
    severity?: 'low' | 'medium' | 'high' | 'critical';
    startDate?: Date;
    endDate?: Date;
    limit?: number;
    offset?: number;
  }): Promise<AuditEvent[]> {
    try {
      let events = Array.from(this.auditStore.values());

      // Apply filters
      if (criteria.userId) {
        events = events.filter(e => e.userId === criteria.userId);
      }
      if (criteria.organizationId) {
        events = events.filter(e => e.organizationId === criteria.organizationId);
      }
      if (criteria.action) {
        events = events.filter(e => e.action.includes(criteria.action!));
      }
      if (criteria.resource) {
        events = events.filter(e => e.resource === criteria.resource);
      }
      if (criteria.outcome) {
        events = events.filter(e => e.outcome === criteria.outcome);
      }
      if (criteria.severity) {
        events = events.filter(e => e.severity === criteria.severity);
      }
      if (criteria.startDate) {
        events = events.filter(e => e.timestamp >= criteria.startDate!);
      }
      if (criteria.endDate) {
        events = events.filter(e => e.timestamp <= criteria.endDate!);
      }

      // Sort by timestamp (newest first)
      events.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());

      // Apply pagination
      const offset = criteria.offset || 0;
      const limit = criteria.limit || 100;
      events = events.slice(offset, offset + limit);

      this.logger.info('Audit events searched', {
        criteria,
        resultCount: events.length
      });

      return events;

    } catch (error) {
      this.logger.error('Failed to search audit events', {
        error: error instanceof Error ? error.message : 'Unknown error',
        criteria
      });
      throw error;
    }
  }

  /**
   * Handle critical security events
   */
  private async handleCriticalEvent(event: AuditEvent): Promise<void> {
    // Alert security team
    this.logger.error('CRITICAL SECURITY EVENT', {
      eventId: event.id,
      action: event.action,
      userId: event.userId,
      details: event.details
    });

    // Here you would integrate with alerting systems
    // - Send to security team
    // - Trigger incident response
    // - Block suspicious IPs if needed
  }

  /**
   * Check and archive old events based on retention policy
   */
  private async checkAndArchiveEvent(event: AuditEvent): Promise<void> {
    // This would typically involve moving old events to long-term storage
    // For now, we'll just log when events should be archived
    const expiryDate = new Date(event.timestamp);
    expiryDate.setDate(expiryDate.getDate() + event.retentionPeriod);

    if (expiryDate < new Date()) {
      this.logger.info('Event ready for archival', {
        eventId: event.id,
        expiryDate
      });
    }
  }

  /**
   * Check access control compliance
   */
  private checkAccessControl(events: AuditEvent[]): boolean {
    const accessEvents = events.filter(e => e.action.includes('access'));
    return accessEvents.every(e => e.outcome === 'success' || e.details.reasonForFailure);
  }

  private checkIncidentResponse(events: AuditEvent[]): boolean {
    const securityEvents = events.filter(e => e.severity === 'critical');
    return securityEvents.every(e => e.details.responseTime && e.details.responseTime < 900); // 15 minutes
  }

  /**
   * Get retention period for event type
   */
  private getRetentionPeriod(action: string): number {
    for (const [type, period] of this.retentionPolicies) {
      if (action.includes(type)) {
        return period;
      }
    }
    return 365; // Default 1 year
  }

  /**
   * Generate unique event ID
   */
  private generateEventId(): string {
    return `audit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Generate unique report ID
   */
  private generateReportId(): string {
    return `report_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Check SOC 2 compliance
   */
  private checkSOC2Compliance(events: AuditEvent[]): boolean {
    // Check for proper access controls, audit trails, and monitoring
    const hasAccessControls = events.some(e => e.action.includes('authorization'));
    const hasAuditTrails = events.length > 0;
    const hasSecurityMonitoring = events.some(e => e.action.includes('security'));
    
    return hasAccessControls && hasAuditTrails && hasSecurityMonitoring;
  }

  /**
   * Check GDPR compliance
   */
  private checkGDPRCompliance(events: AuditEvent[]): boolean {
    // Check for data processing consent and data access controls
    const hasDataProcessingControls = events.some(e => e.complianceFlags.includes('gdpr'));
    const hasDataAccessLogs = events.some(e => e.action.includes('data_access'));
    
    return hasDataProcessingControls && hasDataAccessLogs;
  }

  /**
   * Check SOX compliance
   */
  private checkSOXCompliance(events: AuditEvent[]): boolean {
    // Check for financial data access controls
    const hasFinancialControls = events.some(e => e.complianceFlags.includes('sox'));
    const hasChangeManagement = events.some(e => e.action.includes('configuration_change'));
    
    return hasFinancialControls && hasChangeManagement;
  }

  /**
   * Check HIPAA compliance
   */
  private checkHIPAACompliance(events: AuditEvent[]): boolean {
    // Check for healthcare data protection measures
    const hasHealthcareControls = events.some(e => e.complianceFlags.includes('hipaa'));
    const hasDataEncryption = events.some(e => e.encrypted === true);
    
    return hasHealthcareControls && hasDataEncryption;
  }

  /**
   * Run custom compliance checks
   */
  private async runCustomComplianceChecks(events: AuditEvent[]): Promise<Record<string, boolean>> {
    const checks: Record<string, boolean> = {};
    
    // Example custom checks
    checks.allCriticalEventsLogged = events.filter(e => e.severity === 'critical').length > 0;
    checks.noUnauthorizedAccess = !events.some(e => e.outcome === 'denied' && e.severity === 'high');
    checks.properRetentionPeriods = events.every(e => e.retentionPeriod > 0);
    
    return checks;
  }

  /**
   * Generate digital signature for report integrity
   */
  private async generateDigitalSignature(events: AuditEvent[]): Promise<string> {
    const reportData = JSON.stringify(events.map(e => ({
      id: e.id,
      timestamp: e.timestamp,
      action: e.action,
      outcome: e.outcome,
    })));
    
    const hash = crypto.createHash('sha256').update(reportData).digest('hex');
    
    // In production, this would use proper digital signing with private keys
    return `sig_${hash.substring(0, 32)}`;
  }

  /**
   * Clean up expired events
   */
  async cleanupExpiredEvents(): Promise<number> {
    const now = new Date();
    let cleanedCount = 0;

    for (const [eventId, event] of this.auditStore) {
      const expiryDate = new Date(event.timestamp);
      expiryDate.setDate(expiryDate.getDate() + event.retentionPeriod);

      if (expiryDate < now) {
        this.auditStore.delete(eventId);
        cleanedCount++;
      }
    }

    this.logger.info('Expired audit events cleaned up', {
      cleanedCount,
      remainingCount: this.auditStore.size
    });

    return cleanedCount;
  }
}
// CourtLens Enterprise Security Hardening Service
// Advanced security controls and threat detection

import { SecurityLogger } from '../utils/logger';
import { EnterpriseAuditService } from './enterprise-audit.service';
import crypto from 'crypto';

export interface SecurityThreat {
  id: string;
  type: ThreatType;
  severity: 'low' | 'medium' | 'high' | 'critical';
  source: {
    ip: string;
    userAgent?: string;
    userId?: string;
    sessionId?: string;
  };
  description: string;
  evidence: Record<string, any>;
  detectedAt: Date;
  status: 'active' | 'investigating' | 'mitigated' | 'false_positive';
  mitigationActions: string[];
}

export enum ThreatType {
  BRUTE_FORCE = 'brute_force',
  SUSPICIOUS_LOGIN = 'suspicious_login',
  UNUSUAL_ACCESS_PATTERN = 'unusual_access_pattern',
  DATA_EXFILTRATION = 'data_exfiltration',
  PRIVILEGE_ESCALATION = 'privilege_escalation',
  MALICIOUS_FILE_UPLOAD = 'malicious_file_upload',
  SQL_INJECTION = 'sql_injection',
  XSS_ATTEMPT = 'xss_attempt',
  CSRF_ATTACK = 'csrf_attack',
  API_ABUSE = 'api_abuse',
  ACCOUNT_TAKEOVER = 'account_takeover',
  INSIDER_THREAT = 'insider_threat'
}

export interface SecurityMetrics {
  timestamp: Date;
  failedLogins: number;
  successfulLogins: number;
  blockedRequests: number;
  threatsDetected: number;
  activeSessions: number;
  averageResponseTime: number;
  systemLoad: number;
}

export interface RateLimitRule {
  id: string;
  name: string;
  pattern: string; // URL pattern or endpoint
  windowMs: number; // Time window in milliseconds
  maxRequests: number; // Max requests per window
  blockDurationMs: number; // How long to block after limit exceeded
  skipSuccessfulRequests?: boolean;
  skipFailedRequests?: boolean;
  keyGenerator?: (req: any) => string;
  onLimitReached?: (req: any) => void;
}

export interface IpBlockRule {
  id: string;
  ip: string;
  cidr?: string;
  reason: string;
  blockedAt: Date;
  expiresAt?: Date;
  blockedBy: string;
  isActive: boolean;
}

export class SecurityHardeningService {
  private logger: SecurityLogger;
  private auditService: EnterpriseAuditService;
  private threats: Map<string, SecurityThreat> = new Map();
  private rateLimitRules: Map<string, RateLimitRule> = new Map();
  private ipBlockList: Map<string, IpBlockRule> = new Map();
  private loginAttempts: Map<string, { count: number; lastAttempt: Date; blocked: boolean }> = new Map();
  private securityMetrics: SecurityMetrics[] = [];
  private honeyTokens: Set<string> = new Set();

  constructor(auditService: EnterpriseAuditService) {
    this.logger = new SecurityLogger('SecurityHardeningService');
    this.auditService = auditService;
    this.initializeDefaultRules();
    this.generateHoneyTokens();
    this.startSecurityMonitoring();
  }

  /**
   * Initialize default security rules
   */
  private initializeDefaultRules(): void {
    // Default rate limiting rules
    const defaultRules: RateLimitRule[] = [
      {
        id: 'login_rate_limit',
        name: 'Login Rate Limit',
        pattern: '/api/auth/login',
        windowMs: 15 * 60 * 1000, // 15 minutes
        maxRequests: 5,
        blockDurationMs: 30 * 60 * 1000, // 30 minutes
        skipSuccessfulRequests: true
      },
      {
        id: 'api_rate_limit',
        name: 'General API Rate Limit',
        pattern: '/api/*',
        windowMs: 60 * 1000, // 1 minute
        maxRequests: 100,
        blockDurationMs: 5 * 60 * 1000 // 5 minutes
      },
      {
        id: 'password_reset_limit',
        name: 'Password Reset Rate Limit',
        pattern: '/api/auth/reset-password',
        windowMs: 60 * 60 * 1000, // 1 hour
        maxRequests: 3,
        blockDurationMs: 2 * 60 * 60 * 1000 // 2 hours
      }
    ];

    defaultRules.forEach(rule => {
      this.rateLimitRules.set(rule.id, rule);
    });

    this.logger.info('Default security rules initialized', {
      ruleCount: defaultRules.length
    });
  }

  /**
   * Generate honey tokens for intrusion detection
   */
  private generateHoneyTokens(): void {
    // Generate fake API keys, tokens, etc.
    for (let i = 0; i < 10; i++) {
      const honeyToken = `hny_${crypto.randomBytes(16).toString('hex')}`;
      this.honeyTokens.add(honeyToken);
    }

    this.logger.info('Honey tokens generated', {
      tokenCount: this.honeyTokens.size
    });
  }

  /**
   * Start continuous security monitoring
   */
  private startSecurityMonitoring(): void {
    // Collect security metrics every minute
    setInterval(() => {
      this.collectSecurityMetrics();
    }, 60 * 1000);

    // Clean up old data every hour
    setInterval(() => {
      this.cleanupOldData();
    }, 60 * 60 * 1000);

    this.logger.info('Security monitoring started');
  }

  /**
   * Analyze request for security threats
   */
  async analyzeRequest(req: {
    ip: string;
    url: string;
    method: string;
    headers: Record<string, string>;
    body?: any;
    userId?: string;
    sessionId?: string;
  }): Promise<{ allowed: boolean; threats: SecurityThreat[] }> {
    const threats: SecurityThreat[] = [];

    try {
      // Check IP blocklist
      if (this.isIpBlocked(req.ip)) {
        threats.push(await this.createThreat({
          type: ThreatType.SUSPICIOUS_LOGIN,
          severity: 'high',
          source: { ip: req.ip, userAgent: req.headers['user-agent'], userId: req.userId, sessionId: req.sessionId },
          description: 'Request from blocked IP address',
          evidence: { blockedIp: req.ip, url: req.url }
        }));
      }

      // Check for honey token usage
      const honeyTokenDetected = this.checkHoneyTokens(req);
      if (honeyTokenDetected) {
        threats.push(await this.createThreat({
          type: ThreatType.INSIDER_THREAT,
          severity: 'critical',
          source: { ip: req.ip, userAgent: req.headers['user-agent'], userId: req.userId },
          description: 'Honey token accessed - potential insider threat',
          evidence: { honeyToken: honeyTokenDetected, url: req.url }
        }));
      }

      // Check for SQL injection patterns
      const sqlInjection = this.detectSqlInjection(req);
      if (sqlInjection) {
        threats.push(await this.createThreat({
          type: ThreatType.SQL_INJECTION,
          severity: 'high',
          source: { ip: req.ip, userAgent: req.headers['user-agent'] },
          description: 'SQL injection attempt detected',
          evidence: { pattern: sqlInjection, url: req.url }
        }));
      }

      // Check for XSS patterns
      const xssAttempt = this.detectXssAttempt(req);
      if (xssAttempt) {
        threats.push(await this.createThreat({
          type: ThreatType.XSS_ATTEMPT,
          severity: 'high',
          source: { ip: req.ip, userAgent: req.headers['user-agent'] },
          description: 'XSS attempt detected',
          evidence: { pattern: xssAttempt, url: req.url }
        }));
      }

      // Check rate limits
      const rateLimitViolation = this.checkRateLimit(req);
      if (rateLimitViolation) {
        threats.push(await this.createThreat({
          type: ThreatType.API_ABUSE,
          severity: 'medium',
          source: { ip: req.ip, userAgent: req.headers['user-agent'] },
          description: 'Rate limit exceeded',
          evidence: { rule: rateLimitViolation, url: req.url }
        }));
      }

      // Check for unusual access patterns
      const unusualPattern = await this.detectUnusualAccessPattern(req);
      if (unusualPattern) {
        threats.push(await this.createThreat({
          type: ThreatType.UNUSUAL_ACCESS_PATTERN,
          severity: 'medium',
          source: { ip: req.ip, userAgent: req.headers['user-agent'], userId: req.userId },
          description: 'Unusual access pattern detected',
          evidence: unusualPattern
        }));
      }

      // Log all threats
      for (const threat of threats) {
        await this.logThreat(threat);
      }

      const allowed = threats.length === 0 || !threats.some(t => t.severity === 'critical' || t.severity === 'high');

      return { allowed, threats };

    } catch (error) {
      this.logger.error('Error analyzing request for security threats', {
        error: error instanceof Error ? error.message : 'Unknown error',
        ip: req.ip,
        url: req.url
      });

      return { allowed: true, threats: [] };
    }
  }

  /**
   * Handle failed login attempt
   */
  async handleFailedLogin(ip: string, userId?: string): Promise<void> {
    const key = userId || ip;
    const attempt = this.loginAttempts.get(key) || { count: 0, lastAttempt: new Date(), blocked: false };
    
    attempt.count++;
    attempt.lastAttempt = new Date();

    // Block after 5 failed attempts
    if (attempt.count >= 5) {
      attempt.blocked = true;
      
      // Automatically block IP after multiple failed attempts
      await this.blockIp({
        ip,
        reason: 'Multiple failed login attempts',
        expiresAt: new Date(Date.now() + 30 * 60 * 1000), // 30 minutes
        blockedBy: 'system'
      });

      await this.createThreat({
        type: ThreatType.BRUTE_FORCE,
        severity: 'high',
        source: { ip, userId },
        description: 'Brute force attack detected - multiple failed login attempts',
        evidence: { failedAttempts: attempt.count, timeWindow: '15 minutes' }
      });
    }

    this.loginAttempts.set(key, attempt);

    await this.auditService.logEvent({
      action: 'failed_login_attempt',
      resource: 'authentication',
      outcome: 'failure',
      severity: attempt.count >= 3 ? 'high' : 'medium',
      userId,
      source: { ip },
      details: {
        attemptCount: attempt.count,
        blocked: attempt.blocked
      },
      complianceFlags: ['security_incident'],
      searchableFields: ['failed_login', 'authentication', userId || 'anonymous'],
    });
  }

  /**
   * Block an IP address
   */
  async blockIp(options: {
    ip: string;
    reason: string;
    expiresAt?: Date;
    blockedBy: string;
    cidr?: string;
  }): Promise<void> {
    const blockRule: IpBlockRule = {
      id: this.generateId(),
      ip: options.ip,
      cidr: options.cidr,
      reason: options.reason,
      blockedAt: new Date(),
      expiresAt: options.expiresAt,
      blockedBy: options.blockedBy,
      isActive: true
    };

    this.ipBlockList.set(options.ip, blockRule);

    await this.auditService.logEvent({
      action: 'ip_blocked',
      resource: 'security_policy',
      resourceId: blockRule.id,
      outcome: 'success',
      severity: 'high',
      source: { ip: options.ip },
      details: {
        reason: options.reason,
        blockedBy: options.blockedBy,
        expiresAt: options.expiresAt
      },
      complianceFlags: ['security_action'],
      searchableFields: ['ip_blocked', 'security_policy', options.ip],
    });

    this.logger.warn('IP address blocked', {
      ip: options.ip,
      reason: options.reason,
      blockedBy: options.blockedBy
    });
  }

  /**
   * Unblock an IP address
   */
  async unblockIp(ip: string, unblockedBy: string): Promise<void> {
    const blockRule = this.ipBlockList.get(ip);
    if (blockRule) {
      blockRule.isActive = false;
      
      await this.auditService.logEvent({
        action: 'ip_unblocked',
        resource: 'security_policy',
        resourceId: blockRule.id,
        outcome: 'success',
        severity: 'medium',
        source: { ip },
        details: {
          unblockedBy,
          originalReason: blockRule.reason
        },
        complianceFlags: ['security_action'],
        searchableFields: ['ip_unblocked', 'security_policy', ip],
      });

      this.logger.info('IP address unblocked', {
        ip,
        unblockedBy,
        originalReason: blockRule.reason
      });
    }
  }

  /**
   * Get security dashboard data
   */
  getSecurityDashboard(): {
    activeThreats: SecurityThreat[];
    blockedIps: IpBlockRule[];
    recentMetrics: SecurityMetrics[];
    threatsByType: Record<ThreatType, number>;
    topThreatenedIps: { ip: string; threatCount: number }[];
  } {
    const activeThreats = Array.from(this.threats.values())
      .filter(t => t.status === 'active')
      .sort((a, b) => b.detectedAt.getTime() - a.detectedAt.getTime());

    const blockedIps = Array.from(this.ipBlockList.values())
      .filter(rule => rule.isActive)
      .sort((a, b) => b.blockedAt.getTime() - a.blockedAt.getTime());

    const recentMetrics = this.securityMetrics
      .slice(-24) // Last 24 data points
      .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());

    const threatsByType: Record<ThreatType, number> = {} as Record<ThreatType, number>;
    Object.values(ThreatType).forEach(type => {
      threatsByType[type] = 0;
    });

    const ipThreatCounts = new Map<string, number>();
    
    Array.from(this.threats.values()).forEach(threat => {
      threatsByType[threat.type]++;
      
      const ip = threat.source.ip;
      ipThreatCounts.set(ip, (ipThreatCounts.get(ip) || 0) + 1);
    });

    const topThreatenedIps = Array.from(ipThreatCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([ip, threatCount]) => ({ ip, threatCount }));

    return {
      activeThreats,
      blockedIps,
      recentMetrics,
      threatsByType,
      topThreatenedIps
    };
  }

  /**
   * Private helper methods
   */

  private isIpBlocked(ip: string): boolean {
    const blockRule = this.ipBlockList.get(ip);
    if (!blockRule || !blockRule.isActive) return false;
    
    if (blockRule.expiresAt && blockRule.expiresAt < new Date()) {
      blockRule.isActive = false;
      return false;
    }
    
    return true;
  }

  private checkHoneyTokens(req: any): string | null {
    const checkString = JSON.stringify(req.body || {}) + JSON.stringify(req.headers) + req.url;
    
    for (const token of this.honeyTokens) {
      if (checkString.includes(token)) {
        return token;
      }
    }
    
    return null;
  }

  private detectSqlInjection(req: any): string | null {
    const sqlPatterns = [
      /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION)\b)/gi,
      /(\'|\"|;|--|\*|\/\*|\*\/|xp_|sp_)/gi,
      /(\b(OR|AND)\b.*?=.*?=)/gi
    ];

    const checkString = JSON.stringify(req.body || {}) + req.url;
    
    for (const pattern of sqlPatterns) {
      const match = checkString.match(pattern);
      if (match) {
        return match[0];
      }
    }
    
    return null;
  }

  private detectXssAttempt(req: any): string | null {
    const xssPatterns = [
      /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
      /javascript:/gi,
      /on\w+\s*=/gi,
      /<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi
    ];

    const checkString = JSON.stringify(req.body || {}) + req.url;
    
    for (const pattern of xssPatterns) {
      const match = checkString.match(pattern);
      if (match) {
        return match[0];
      }
    }
    
    return null;
  }

  private checkRateLimit(req: any): string | null {
    // Simple rate limiting check - in production would use Redis or similar
    for (const rule of this.rateLimitRules.values()) {
      if (req.url.match(new RegExp(rule.pattern.replace('*', '.*')))) {
        // Rate limiting logic would go here
        return rule.name;
      }
    }
    
    return null;
  }

  private async detectUnusualAccessPattern(req: any): Promise<Record<string, any> | null> {
    // Implement ML-based or rule-based unusual pattern detection
    // For now, return null (no unusual pattern detected)
    return null;
  }

  private async createThreat(threat: Omit<SecurityThreat, 'id' | 'detectedAt' | 'status' | 'mitigationActions'>): Promise<SecurityThreat> {
    const newThreat: SecurityThreat = {
      id: this.generateId(),
      detectedAt: new Date(),
      status: 'active',
      mitigationActions: [],
      ...threat
    };

    this.threats.set(newThreat.id, newThreat);
    return newThreat;
  }

  private async logThreat(threat: SecurityThreat): Promise<void> {
    await this.auditService.logEvent({
      action: 'security_threat_detected',
      resource: 'security_threat',
      resourceId: threat.id,
      outcome: 'success',
      severity: threat.severity === 'critical' ? 'critical' : 'high',
      userId: threat.source.userId,
      source: threat.source,
      details: {
        threatType: threat.type,
        description: threat.description,
        evidence: threat.evidence
      },
      complianceFlags: ['security_incident', 'threat_detection'],
      searchableFields: ['security_threat_detected', 'security_threat', threat.type, threat.id],
    });

    this.logger.warn('Security threat detected', {
      threatId: threat.id,
      type: threat.type,
      severity: threat.severity,
      source: threat.source
    });
  }

  private collectSecurityMetrics(): void {
    const now = new Date();
    const activeThreats = Array.from(this.threats.values()).filter(t => t.status === 'active');
    const blockedIps = Array.from(this.ipBlockList.values()).filter(rule => rule.isActive);

    const metrics: SecurityMetrics = {
      timestamp: now,
      failedLogins: 0, // Would be calculated from actual data
      successfulLogins: 0, // Would be calculated from actual data
      blockedRequests: 0, // Would be calculated from actual data
      threatsDetected: activeThreats.length,
      activeSessions: 0, // Would be calculated from session store
      averageResponseTime: 0, // Would be calculated from response times
      systemLoad: 0 // Would be calculated from system metrics
    };

    this.securityMetrics.push(metrics);

    // Keep only last 7 days of metrics
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    this.securityMetrics = this.securityMetrics.filter(m => m.timestamp > sevenDaysAgo);
  }

  private cleanupOldData(): void {
    const now = new Date();
    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);

    // Clean up old login attempts
    for (const [key, attempt] of this.loginAttempts) {
      if (attempt.lastAttempt < oneDayAgo) {
        this.loginAttempts.delete(key);
      }
    }

    // Clean up expired IP blocks
    for (const [ip, rule] of this.ipBlockList) {
      if (rule.expiresAt && rule.expiresAt < now) {
        rule.isActive = false;
      }
    }

    this.logger.info('Security data cleanup completed', {
      loginAttemptsRemaining: this.loginAttempts.size,
      activeIpBlocks: Array.from(this.ipBlockList.values()).filter(r => r.isActive).length
    });
  }

  private generateId(): string {
    return `sec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
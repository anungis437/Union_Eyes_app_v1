// CourtLens Authorization Service
// Role-based access control (RBAC) and permission management

import { createClient, SupabaseClient } from '@supabase/supabase-js';
import {
  User,
  UserRole,
  Permission,
  Role,
  AccessControl,
  SecurityContext,
  AuthorizationError,
  SecurityEventType,
  RiskLevel
} from '../types';
import { SecurityLogger } from '../utils/logger';
import { SecurityEventService } from './security-event.service';

export interface PermissionCheck {
  resource: string;
  action: string;
  conditions?: Record<string, any>;
}

export class AuthorizationService {
  private supabase: SupabaseClient;
  private logger: SecurityLogger;
  private eventService: SecurityEventService;
  private permissionCache: Map<string, Permission[]> = new Map();
  private cacheTimeout = 5 * 60 * 1000; // 5 minutes

  constructor(supabaseUrl: string, supabaseServiceKey: string) {
    this.supabase = createClient(supabaseUrl, supabaseServiceKey);
    this.logger = new SecurityLogger('AuthorizationService');
    this.eventService = new SecurityEventService(supabaseUrl, supabaseServiceKey);
  }

  /**
   * Check if user has permission for a specific action on a resource
   */
  async hasPermission(
    context: SecurityContext,
    permissionCheck: PermissionCheck
  ): Promise<boolean> {
    try {
      if (!context.user) {
        this.logger.warn('Authorization check without user context');
        return false;
      }

      // Get user permissions (cached)
      const permissions = await this.getUserPermissions(context.user.id);

      // Check for exact permission match
      const hasExactPermission = permissions.some(permission => 
        permission.resource === permissionCheck.resource &&
        permission.action === permissionCheck.action &&
        this.matchesConditions(permission.conditions, permissionCheck.conditions)
      );

      if (hasExactPermission) {
        return true;
      }

      // Check for wildcard permissions
      const hasWildcardPermission = permissions.some(permission =>
        (permission.resource === '*' || permission.resource === permissionCheck.resource) &&
        (permission.action === '*' || permission.action === permissionCheck.action)
      );

      if (hasWildcardPermission) {
        return true;
      }

      // Check role-based permissions
      const hasRolePermission = await this.checkRolePermission(
        context.user.role,
        permissionCheck
      );

      const hasAccess = hasRolePermission;

      // Log permission check
      if (!hasAccess) {
        await this.logPermissionDenied(context, permissionCheck);
      }

      return hasAccess;

    } catch (error) {
      this.logger.error('Permission check failed', {
        userId: context.user?.id,
        resource: permissionCheck.resource,
        action: permissionCheck.action,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      return false;
    }
  }

  /**
   * Require permission or throw authorization error
   */
  async requirePermission(
    context: SecurityContext,
    permissionCheck: PermissionCheck
  ): Promise<void> {
    const hasAccess = await this.hasPermission(context, permissionCheck);
    if (!hasAccess) {
      throw new AuthorizationError(
        `Access denied: insufficient permissions for ${permissionCheck.action} on ${permissionCheck.resource}`,
        {
          resource: permissionCheck.resource,
          action: permissionCheck.action,
          userId: context.user?.id
        }
      );
    }
  }

  /**
   * Get all permissions for a user
   */
  async getUserPermissions(userId: string): Promise<Permission[]> {
    const cacheKey = `user_permissions_${userId}`;
    
    // Check cache first
    const cached = this.permissionCache.get(cacheKey);
    if (cached) {
      return cached;
    }

    try {
      // Get user's direct permissions
      const { data: directPermissions } = await this.supabase
        .from('user_permissions')
        .select(`
          permission:permissions(*)
        `)
        .eq('user_id', userId);

      // Get user's role permissions
      const { data: rolePermissions } = await this.supabase
        .from('user_profiles')
        .select(`
          role,
          role_permissions:roles!role(
            permissions:role_permissions(
              permission:permissions(*)
            )
          )
        `)
        .eq('id', userId)
        .single();

      // Combine permissions
      const allPermissions: Permission[] = [
        ...(directPermissions?.map((dp: any) => dp.permission) || []),
        ...(rolePermissions?.role_permissions?.map((rp: any) => rp.permission) || [])
      ];

      // Remove duplicates
      const uniquePermissions = allPermissions.filter((permission, index, self) =>
        index === self.findIndex(p => p.id === permission.id)
      );

      // Cache permissions
      this.permissionCache.set(cacheKey, uniquePermissions);
      setTimeout(() => {
        this.permissionCache.delete(cacheKey);
      }, this.cacheTimeout);

      return uniquePermissions;

    } catch (error) {
      this.logger.error('Failed to get user permissions', {
        userId,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      return [];
    }
  }

  /**
   * Check if user can access organization data
   */
  async canAccessOrganization(
    context: SecurityContext,
    organizationId: string
  ): Promise<boolean> {
    if (!context.user) {
      return false;
    }

    // Super admin can access any organization
    if (context.user.role === UserRole.SUPER_ADMIN) {
      return true;
    }

    // User can access their own organization
    if (context.user.organizationId === organizationId) {
      return true;
    }

    // Check for cross-organization permissions
    return await this.hasPermission(context, {
      resource: 'organization',
      action: 'read',
      conditions: { organizationId }
    });
  }

  /**
   * Check if user can access user data
   */
  async canAccessUser(
    context: SecurityContext,
    targetUserId: string
  ): Promise<boolean> {
    if (!context.user) {
      return false;
    }

    // User can access their own data
    if (context.user.id === targetUserId) {
      return true;
    }

    // Check for user management permissions
    return await this.hasPermission(context, {
      resource: 'user',
      action: 'read',
      conditions: { userId: targetUserId }
    });
  }

  /**
   * Create a new role
   */
  async createRole(
    context: SecurityContext,
    roleData: Omit<Role, 'id'>
  ): Promise<Role> {
    await this.requirePermission(context, {
      resource: 'role',
      action: 'create'
    });

    try {
      const { data, error } = await this.supabase
        .from('roles')
        .insert([roleData])
        .select()
        .single();

      if (error || !data) {
        throw new Error('Failed to create role');
      }

      this.logger.info('Role created', {
        roleId: data.id,
        roleName: data.name,
        createdBy: context.user?.id
      });

      return data as Role;

    } catch (error) {
      this.logger.error('Role creation failed', {
        roleName: roleData.name,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      throw error;
    }
  }

  /**
   * Assign role to user
   */
  async assignRole(
    context: SecurityContext,
    userId: string,
    roleId: string
  ): Promise<void> {
    await this.requirePermission(context, {
      resource: 'user',
      action: 'update',
      conditions: { userId }
    });

    try {
      const { error } = await this.supabase
        .from('user_profiles')
        .update({ role: roleId })
        .eq('id', userId);

      if (error) {
        throw new Error('Failed to assign role');
      }

      // Clear permission cache
      this.permissionCache.delete(`user_permissions_${userId}`);

      this.logger.info('Role assigned', {
        userId,
        roleId,
        assignedBy: context.user?.id
      });

    } catch (error) {
      this.logger.error('Role assignment failed', {
        userId,
        roleId,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      throw error;
    }
  }

  /**
   * Get role hierarchy for organization
   */
  async getRoleHierarchy(organizationId: string): Promise<Role[]> {
    try {
      const { data, error } = await this.supabase
        .from('roles')
        .select(`
          *,
          permissions:role_permissions(
            permission:permissions(*)
          )
        `)
        .eq('organization_id', organizationId)
        .order('name');

      if (error) {
        throw new Error('Failed to get role hierarchy');
      }

      return (data || []) as Role[];

    } catch (error) {
      this.logger.error('Failed to get role hierarchy', {
        organizationId,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      throw error;
    }
  }

  // Private helper methods

  private matchesConditions(
    permissionConditions?: Record<string, any>,
    checkConditions?: Record<string, any>
  ): boolean {
    if (!permissionConditions && !checkConditions) {
      return true;
    }

    if (!permissionConditions || !checkConditions) {
      return false;
    }

    // Simple condition matching - can be extended for complex conditions
    return Object.keys(checkConditions).every(key =>
      permissionConditions[key] === checkConditions[key]
    );
  }

  private async checkRolePermission(
    role: UserRole,
    permissionCheck: PermissionCheck
  ): Promise<boolean> {
    // Define default role permissions
    const rolePermissions: Record<UserRole, PermissionCheck[]> = {
      [UserRole.SUPER_ADMIN]: [
        { resource: '*', action: '*' }
      ],
      [UserRole.ORG_ADMIN]: [
        { resource: 'organization', action: '*' },
        { resource: 'user', action: '*' },
        { resource: 'role', action: '*' },
        { resource: 'document', action: '*' }
      ],
      [UserRole.PARTNER]: [
        { resource: 'document', action: '*' },
        { resource: 'matter', action: '*' },
        { resource: 'client', action: '*' }
      ],
      [UserRole.SENIOR_ASSOCIATE]: [
        { resource: 'document', action: 'read' },
        { resource: 'document', action: 'write' },
        { resource: 'matter', action: 'read' },
        { resource: 'matter', action: 'write' }
      ],
      [UserRole.ASSOCIATE]: [
        { resource: 'document', action: 'read' },
        { resource: 'matter', action: 'read' }
      ],
      [UserRole.PARALEGAL]: [
        { resource: 'document', action: 'read' },
        { resource: 'matter', action: 'read' }
      ],
      [UserRole.CLIENT]: [
        { resource: 'document', action: 'read', conditions: { owner: true } },
        { resource: 'matter', action: 'read', conditions: { client: true } }
      ],
      [UserRole.GUEST]: []
    };

    const permissions = rolePermissions[role] || [];
    
    return permissions.some(permission =>
      (permission.resource === '*' || permission.resource === permissionCheck.resource) &&
      (permission.action === '*' || permission.action === permissionCheck.action) &&
      this.matchesConditions(permission.conditions, permissionCheck.conditions)
    );
  }

  private async logPermissionDenied(
    context: SecurityContext,
    permissionCheck: PermissionCheck
  ): Promise<void> {
    await this.eventService.logEvent({
      id: '',
      type: SecurityEventType.PERMISSION_DENIED,
      userId: context.user?.id,
      organizationId: context.user?.organizationId || '',
      ipAddress: context.ipAddress,
      userAgent: context.userAgent,
      resource: permissionCheck.resource,
      action: permissionCheck.action,
      details: {
        resource: permissionCheck.resource,
        action: permissionCheck.action,
        conditions: permissionCheck.conditions
      },
      riskLevel: RiskLevel.MEDIUM,
      timestamp: new Date()
    });
  }
}
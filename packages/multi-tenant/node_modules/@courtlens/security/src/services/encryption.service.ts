// CourtLens Encryption Service
// Advanced encryption for sensitive legal data with key management

import crypto from 'crypto';
import CryptoJS from 'crypto-js';
import {
  EncryptionConfig,
  EncryptedData,
  EncryptionLevel,
  EncryptionError
} from '../types';
import { SecurityLogger } from '../utils/logger';

export interface EncryptionKey {
  id: string;
  algorithm: string;
  key: string;
  iv?: string;
  createdAt: Date;
  expiresAt?: Date;
  isActive: boolean;
}

export class EncryptionService {
  private logger: SecurityLogger;
  private keys: Map<string, EncryptionKey> = new Map();
  private defaultConfig: EncryptionConfig;

  constructor() {
    this.logger = new SecurityLogger('EncryptionService');
    this.defaultConfig = {
      algorithm: 'aes-256-gcm',
      keySize: 32,
      ivSize: 16,
      saltSize: 32,
      iterations: 100000
    };
  }

  /**
   * Encrypt sensitive data
   */
  async encrypt(
    data: string,
    level: EncryptionLevel = EncryptionLevel.STANDARD,
    keyId?: string
  ): Promise<EncryptedData> {
    try {
      const config = this.getConfigForLevel(level);
      const key = keyId ? await this.getKey(keyId) : await this.generateKey(config);
      
      if (!key) {
        throw new EncryptionError('Encryption key not available');
      }

      const iv = crypto.randomBytes(config.ivSize);
      const salt = crypto.randomBytes(config.saltSize);
      
      // Derive key using PBKDF2
      const derivedKey = crypto.pbkdf2Sync(key.key, salt, config.iterations, config.keySize, 'sha256');
      
      // Encrypt data
      const cipher = crypto.createCipheriv(config.algorithm, derivedKey, iv);
      cipher.setAutoPadding(true);
      
      let encrypted = cipher.update(data, 'utf8', 'hex');
      encrypted += cipher.final('hex');
      
      // Get authentication tag for GCM mode
      let authTag = '';
      if (config.algorithm.includes('gcm') && (cipher as any).getAuthTag) {
        authTag = (cipher as any).getAuthTag().toString('hex');
      }

      const result: EncryptedData = {
        data: encrypted + (authTag ? ':' + authTag : ''),
        iv: iv.toString('hex'),
        salt: salt.toString('hex'),
        algorithm: config.algorithm,
        keyId: key.id,
        level: level
      };

      this.logger.info('Data encrypted', {
        keyId: key.id,
        algorithm: config.algorithm,
        level
      });

      return result;

    } catch (error) {
      this.logger.error('Encryption failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        level
      });
      throw new EncryptionError('Failed to encrypt data');
    }
  }

  /**
   * Decrypt encrypted data
   */
  async decrypt(encryptedData: EncryptedData): Promise<string> {
    try {
      const key = await this.getKey(encryptedData.keyId);
      if (!key) {
        throw new EncryptionError('Decryption key not found');
      }

      const config = encryptedData.level 
        ? this.getConfigForLevel(encryptedData.level)
        : this.getConfigForAlgorithm(encryptedData.algorithm);
      const iv = Buffer.from(encryptedData.iv, 'hex');
      const salt = Buffer.from(encryptedData.salt, 'hex');
      
      // Derive the same key used for encryption
      const derivedKey = crypto.pbkdf2Sync(key.key, salt, config.iterations, config.keySize, 'sha256');
      
      // Split data and auth tag for GCM mode
      const parts = encryptedData.data.split(':');
      const encrypted = parts[0];
      const authTag = parts[1] ? Buffer.from(parts[1], 'hex') : null;

      // Decrypt data
      const decipher = crypto.createDecipheriv(encryptedData.algorithm, derivedKey, iv);
      
      if (authTag && encryptedData.algorithm.includes('gcm') && (decipher as any).setAuthTag) {
        (decipher as any).setAuthTag(authTag);
      }
      
      let decrypted = decipher.update(encrypted, 'hex', 'utf8');
      decrypted += decipher.final('utf8');

      this.logger.info('Data decrypted', {
        keyId: encryptedData.keyId,
        algorithm: encryptedData.algorithm
      });

      return decrypted;

    } catch (error) {
      this.logger.error('Decryption failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        keyId: encryptedData.keyId,
        algorithm: encryptedData.algorithm,
        stack: error instanceof Error ? error.stack : undefined
      });
      throw new EncryptionError('Failed to decrypt data');
    }
  }

  /**
   * Encrypt file data
   */
  async encryptFile(
    fileBuffer: Buffer,
    level: EncryptionLevel = EncryptionLevel.STANDARD
  ): Promise<EncryptedData> {
    const base64Data = fileBuffer.toString('base64');
    return await this.encrypt(base64Data, level);
  }

  /**
   * Decrypt file data
   */
  async decryptFile(encryptedData: EncryptedData): Promise<Buffer> {
    const decryptedBase64 = await this.decrypt(encryptedData);
    return Buffer.from(decryptedBase64, 'base64');
  }

  /**
   * Hash sensitive data (one-way)
   */
  hash(data: string, salt?: string): string {
    const actualSalt = salt || crypto.randomBytes(16).toString('hex');
    const hash = crypto.createHash('sha256');
    hash.update(data + actualSalt);
    return hash.digest('hex') + ':' + actualSalt;
  }

  /**
   * Verify hashed data
   */
  verifyHash(data: string, hashedData: string): boolean {
    const [hash, salt] = hashedData.split(':');
    const newHash = this.hash(data, salt);
    return newHash === hashedData;
  }

  /**
   * Generate secure random token
   */
  generateToken(length: number = 32): string {
    return crypto.randomBytes(length).toString('hex');
  }

  /**
   * Generate secure password
   */
  generateSecurePassword(length: number = 16): string {
    // Ensure minimum length for complexity requirements
    if (length < 8) length = 8;
    
    const lowercase = 'abcdefghijklmnopqrstuvwxyz';
    const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const numbers = '0123456789';
    const special = '!@#$%^&*';
    const allChars = lowercase + uppercase + numbers + special;
    
    let password = '';
    
    // Ensure at least one character from each required category
    password += lowercase[crypto.randomInt(0, lowercase.length)];
    password += uppercase[crypto.randomInt(0, uppercase.length)];
    password += numbers[crypto.randomInt(0, numbers.length)];
    password += special[crypto.randomInt(0, special.length)];
    
    // Fill the rest with random characters from all categories
    for (let i = 4; i < length; i++) {
      password += allChars[crypto.randomInt(0, allChars.length)];
    }
    
    // Shuffle the password to avoid predictable patterns
    const passwordArray = password.split('');
    for (let i = passwordArray.length - 1; i > 0; i--) {
      const j = crypto.randomInt(0, i + 1);
      [passwordArray[i], passwordArray[j]] = [passwordArray[j], passwordArray[i]];
    }
    
    return passwordArray.join('');
  }

  /**
   * Generate encryption key
   */
  private async generateKey(config: EncryptionConfig): Promise<EncryptionKey> {
    const keyId = crypto.randomUUID();
    const key = crypto.randomBytes(config.keySize).toString('hex');
    
    const encryptionKey: EncryptionKey = {
      id: keyId,
      algorithm: config.algorithm,
      key,
      createdAt: new Date(),
      isActive: true
    };

    // Store key (in production, use secure key management service)
    this.keys.set(keyId, encryptionKey);

    this.logger.info('Encryption key generated', {
      keyId,
      algorithm: config.algorithm
    });

    return encryptionKey;
  }

  /**
   * Get encryption key by ID
   */
  private async getKey(keyId: string): Promise<EncryptionKey | null> {
    const key = this.keys.get(keyId);
    
    if (!key) {
      this.logger.warn('Encryption key not found', { keyId });
      return null;
    }

    if (!key.isActive) {
      this.logger.warn('Encryption key is inactive', { keyId });
      return null;
    }

    if (key.expiresAt && key.expiresAt < new Date()) {
      this.logger.warn('Encryption key has expired', { keyId });
      return null;
    }

    return key;
  }

  /**
   * Get encryption configuration for security level
   */
  private getConfigForLevel(level: EncryptionLevel): EncryptionConfig {
    switch (level) {
      case EncryptionLevel.STANDARD:
        return {
          algorithm: 'aes-256-cbc',
          keySize: 32,
          ivSize: 16,
          saltSize: 16,
          iterations: 10000
        };
      
      case EncryptionLevel.ENHANCED:
        return {
          algorithm: 'aes-256-gcm',
          keySize: 32,
          ivSize: 16,
          saltSize: 32,
          iterations: 50000
        };
      
      case EncryptionLevel.MAXIMUM:
        return {
          algorithm: 'aes-256-gcm',
          keySize: 32,
          ivSize: 16,
          saltSize: 64,
          iterations: 100000
        };
      
      default:
        return this.defaultConfig;
    }
  }

  /**
   * Get configuration for specific algorithm
   */
  private getConfigForAlgorithm(algorithm: string): EncryptionConfig {
    // Find the correct configuration based on algorithm
    if (algorithm === 'aes-256-cbc') {
      return this.getConfigForLevel(EncryptionLevel.STANDARD);
    } else if (algorithm === 'aes-256-gcm') {
      // Try to determine if it's enhanced or maximum based on context
      // For now, return enhanced as it's more commonly used
      return this.getConfigForLevel(EncryptionLevel.ENHANCED);
    }
    return this.defaultConfig;
  }

  /**
   * Rotate encryption keys
   */
  async rotateKeys(): Promise<void> {
    this.logger.info('Starting key rotation');
    
    // Mark old keys as inactive
    for (const [keyId, key] of this.keys.entries()) {
      if (key.isActive) {
        key.isActive = false;
        key.expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days
        this.keys.set(keyId, key);
      }
    }

    this.logger.info('Key rotation completed');
  }

  /**
   * Clean up expired keys
   */
  async cleanupExpiredKeys(): Promise<void> {
    const now = new Date();
    let cleanedCount = 0;

    for (const [keyId, key] of this.keys.entries()) {
      if (key.expiresAt && key.expiresAt < now) {
        this.keys.delete(keyId);
        cleanedCount++;
      }
    }

    this.logger.info('Cleaned up expired keys', { count: cleanedCount });
  }
}
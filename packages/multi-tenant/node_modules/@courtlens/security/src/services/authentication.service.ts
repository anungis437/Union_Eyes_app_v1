// CourtLens Authentication Service
// Comprehensive authentication with Supabase integration, MFA, and security hardening

import { createClient, SupabaseClient, User as SupabaseUser } from '@supabase/supabase-js';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import speakeasy from 'speakeasy';
import QRCode from 'qrcode';
import { v4 as uuidv4 } from 'uuid';
import crypto from 'crypto';
import {
  User,
  UserRole,
  AuthToken,
  MfaSetup,
  AuthSession,
  SecurityEventType,
  SecurityEvent,
  RiskLevel,
  AuthenticationError,
  ValidationError,
  SecurityContext
} from '../types';
import { SecurityLogger, SecurityValidator } from '../utils';
import { SecurityEventService } from './security-event.service';

export interface LoginCredentials {
  email: string;
  password: string;
  mfaToken?: string;
  deviceFingerprint?: string;
}

export interface RegistrationData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  organizationId: string;
  role?: UserRole;
}

export interface PasswordResetRequest {
  email: string;
  clientUrl: string;
}

export interface PasswordUpdateRequest {
  currentPassword: string;
  newPassword: string;
}

export class AuthenticationService {
  private supabase: SupabaseClient;
  private logger: SecurityLogger;
  private validator: SecurityValidator;
  private eventService: SecurityEventService;
  private jwtSecret: string;
  private sessionStore: Map<string, AuthSession> = new Map();

  constructor(
    supabaseUrl: string,
    supabaseServiceKey: string,
    jwtSecret: string
  ) {
    this.supabase = createClient(supabaseUrl, supabaseServiceKey);
    this.logger = new SecurityLogger('AuthenticationService');
    this.validator = new SecurityValidator();
    this.eventService = new SecurityEventService();
    this.jwtSecret = jwtSecret;
  }

  /**
   * Authenticate user with email and password
   */
  async login(credentials: LoginCredentials, context: Partial<SecurityContext>): Promise<AuthToken> {
    this.logger.info('Login attempt', { email: credentials.email });

    try {
      // Validate input
      this.validator.validateEmail(credentials.email);
      this.validator.validatePassword(credentials.password);

      // Check for suspicious activity
      await this.checkSuspiciousActivity(credentials.email, context.ipAddress);

      // Authenticate with Supabase
      const { data: authData, error: authError } = await this.supabase.auth.signInWithPassword({
        email: credentials.email,
        password: credentials.password
      });

      if (authError || !authData.user) {
        await this.logSecurityEvent({
          type: SecurityEventType.LOGIN_FAILURE,
          organizationId: '', // Will be filled if user exists
          ipAddress: context.ipAddress || '',
          userAgent: context.userAgent || '',
          details: { email: credentials.email, reason: 'invalid_credentials' },
          riskLevel: RiskLevel.MEDIUM
        });
        throw new AuthenticationError('Invalid credentials');
      }

      // Get user profile
      const user = await this.getUserProfile(authData.user.id);
      
      if (!user.isActive) {
        throw new AuthenticationError('Account is deactivated');
      }

      // Check MFA requirement
      if (user.mfaEnabled && !credentials.mfaToken) {
        throw new AuthenticationError('MFA token required', { requiresMfa: true });
      }

      if (user.mfaEnabled && credentials.mfaToken) {
        const mfaValid = await this.verifyMfaToken(user.id, credentials.mfaToken);
        if (!mfaValid) {
          await this.logSecurityEvent({
            type: SecurityEventType.LOGIN_FAILURE,
            userId: user.id,
            organizationId: user.organizationId,
            ipAddress: context.ipAddress || '',
            userAgent: context.userAgent || '',
            details: { email: credentials.email, reason: 'invalid_mfa' },
            riskLevel: RiskLevel.HIGH
          });
          throw new AuthenticationError('Invalid MFA token');
        }
      }

      // Generate JWT tokens
      const tokens = await this.generateTokens(user);

      // Create session
      const session = await this.createSession(user, context);

      // Update last login
      await this.updateLastLogin(user.id);

      // Log successful login
      await this.logSecurityEvent({
        type: SecurityEventType.LOGIN_SUCCESS,
        userId: user.id,
        organizationId: user.organizationId,
        ipAddress: context.ipAddress || '',
        userAgent: context.userAgent || '',
        details: { sessionId: session.sessionId },
        riskLevel: RiskLevel.LOW
      });

      this.logger.info('Login successful', { userId: user.id, email: user.email });

      return tokens;

    } catch (error) {
      this.logger.error('Login failed', { 
        email: credentials.email, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
      throw error;
    }
  }

  /**
   * Register new user
   */
  async register(data: RegistrationData, context: Partial<SecurityContext>): Promise<User> {
    this.logger.info('Registration attempt', { email: data.email });

    try {
      // Validate input
      this.validator.validateEmail(data.email);
      this.validator.validatePassword(data.password);
      this.validator.validateRequired(data.firstName, 'firstName');
      this.validator.validateRequired(data.lastName, 'lastName');
      this.validator.validateRequired(data.organizationId, 'organizationId');

      // Check if user already exists
      const existingUser = await this.findUserByEmail(data.email);
      if (existingUser) {
        throw new ValidationError('User already exists');
      }

      // Validate organization
      const organization = await this.getOrganization(data.organizationId);
      if (!organization || !organization.isActive) {
        throw new ValidationError('Invalid organization');
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(data.password, 12);

      // Create user in Supabase Auth
      const { data: authData, error: authError } = await this.supabase.auth.admin.createUser({
        email: data.email,
        password: data.password,
        email_confirm: false // We'll handle email confirmation separately
      });

      if (authError || !authData.user) {
        throw new AuthenticationError('Failed to create user account');
      }

      // Create user profile
      const userProfile: Omit<User, 'id' | 'createdAt' | 'updatedAt'> = {
        email: data.email,
        firstName: data.firstName,
        lastName: data.lastName,
        role: data.role || UserRole.ASSOCIATE,
        organizationId: data.organizationId,
        isActive: true,
        emailVerified: false,
        mfaEnabled: false
      };

      const { data: profile, error: profileError } = await this.supabase
        .from('user_profiles')
        .insert([{ ...userProfile, id: authData.user.id }])
        .select()
        .single();

      if (profileError) {
        // Cleanup auth user if profile creation fails
        await this.supabase.auth.admin.deleteUser(authData.user.id);
        throw new AuthenticationError('Failed to create user profile');
      }

      // Send verification email
      await this.sendVerificationEmail(data.email);

      this.logger.info('User registered successfully', { 
        userId: authData.user.id, 
        email: data.email 
      });

      return profile as User;

    } catch (error) {
      this.logger.error('Registration failed', { 
        email: data.email, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
      throw error;
    }
  }

  /**
   * Setup Multi-Factor Authentication
   */
  async setupMfa(userId: string): Promise<MfaSetup> {
    this.logger.info('MFA setup initiated', { userId });

    try {
      const user = await this.getUserProfile(userId);
      if (!user) {
        throw new AuthenticationError('User not found');
      }

      // Generate secret
      const secret = speakeasy.generateSecret({
        name: `CourtLens (${user.email})`,
        issuer: 'CourtLens',
        length: 32
      });

      // Generate QR code
      const qrCodeUrl = await QRCode.toDataURL(secret.otpauth_url!);

      // Generate backup codes
      const backupCodes = Array.from({ length: 10 }, () => 
        crypto.randomBytes(4).toString('hex').toUpperCase()
      );

      // Store MFA secret (encrypted)
      await this.storeMfaSecret(userId, secret.base32, backupCodes);

      this.logger.info('MFA setup completed', { userId });

      return {
        secret: secret.base32,
        qrCodeUrl,
        backupCodes
      };

    } catch (error) {
      this.logger.error('MFA setup failed', { 
        userId, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
      throw error;
    }
  }

  /**
   * Verify MFA token
   */
  async verifyMfaToken(userId: string, token: string): Promise<boolean> {
    try {
      const mfaSecret = await this.getMfaSecret(userId);
      if (!mfaSecret) {
        return false;
      }

      // Verify TOTP token
      const verified = speakeasy.totp.verify({
        secret: mfaSecret,
        encoding: 'base32',
        token: token,
        window: 2 // Allow 2 time steps before/after
      });

      if (verified) {
        this.logger.info('MFA token verified', { userId });
        return true;
      }

      // Check backup codes if TOTP fails
      const backupCodeValid = await this.verifyBackupCode(userId, token);
      if (backupCodeValid) {
        this.logger.info('MFA backup code verified', { userId });
        return true;
      }

      this.logger.warn('MFA token verification failed', { userId });
      return false;

    } catch (error) {
      this.logger.error('MFA verification error', { 
        userId, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
      return false;
    }
  }

  /**
   * Refresh access token
   */
  async refreshToken(refreshToken: string): Promise<AuthToken> {
    try {
      const { data, error } = await this.supabase.auth.refreshSession({
        refresh_token: refreshToken
      });

      if (error || !data.session) {
        throw new AuthenticationError('Invalid refresh token');
      }

      const user = await this.getUserProfile(data.user!.id);
      return await this.generateTokens(user);

    } catch (error) {
      this.logger.error('Token refresh failed', { 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
      throw error;
    }
  }

  /**
   * Logout user
   */
  async logout(sessionId: string, context: Partial<SecurityContext>): Promise<void> {
    try {
      const session = this.sessionStore.get(sessionId);
      if (session) {
        // Invalidate session
        session.isActive = false;
        this.sessionStore.set(sessionId, session);

        // Log logout event
        await this.logSecurityEvent({
          type: SecurityEventType.LOGOUT,
          userId: session.userId,
          organizationId: session.organizationId,
          ipAddress: context.ipAddress || '',
          userAgent: context.userAgent || '',
          details: { sessionId },
          riskLevel: RiskLevel.LOW
        });
      }

      // Sign out from Supabase
      await this.supabase.auth.signOut();

      this.logger.info('User logged out', { sessionId });

    } catch (error) {
      this.logger.error('Logout failed', { 
        sessionId, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
      throw error;
    }
  }

  /**
   * Validate JWT token and return user context
   */
  async validateToken(token: string): Promise<SecurityContext> {
    try {
      const decoded = jwt.verify(token, this.jwtSecret) as any;
      
      const user = await this.getUserProfile(decoded.sub);
      if (!user || !user.isActive) {
        throw new AuthenticationError('Invalid token');
      }

      const session = this.sessionStore.get(decoded.sessionId);
      if (!session || !session.isActive || session.expiresAt < new Date()) {
        throw new AuthenticationError('Session expired');
      }

      // Update session activity
      session.lastActivity = new Date();
      this.sessionStore.set(decoded.sessionId, session);

      // Get user permissions
      const permissions = await this.getUserPermissions(user.id);

      return {
        user,
        session,
        permissions,
        ipAddress: session.ipAddress,
        userAgent: session.userAgent,
        requestId: uuidv4(),
        timestamp: new Date()
      };

    } catch (error) {
      if (error instanceof jwt.JsonWebTokenError) {
        throw new AuthenticationError('Invalid token');
      }
      throw error;
    }
  }

  // Private helper methods

  private async getUserProfile(userId: string): Promise<User> {
    const { data, error } = await this.supabase
      .from('user_profiles')
      .select('*')
      .eq('id', userId)
      .single();

    if (error || !data) {
      throw new AuthenticationError('User not found');
    }

    return data as User;
  }

  private async findUserByEmail(email: string): Promise<User | null> {
    const { data } = await this.supabase
      .from('user_profiles')
      .select('*')
      .eq('email', email)
      .single();

    return data as User | null;
  }

  private async getOrganization(organizationId: string): Promise<any> {
    const { data } = await this.supabase
      .from('organizations')
      .select('*')
      .eq('id', organizationId)
      .single();

    return data;
  }

  private async generateTokens(user: User): Promise<AuthToken> {
    const sessionId = uuidv4();
    const now = Date.now();
    const expiresIn = 3600; // 1 hour

    const accessToken = jwt.sign(
      {
        sub: user.id,
        email: user.email,
        role: user.role,
        organizationId: user.organizationId,
        sessionId,
        iat: Math.floor(now / 1000),
        exp: Math.floor(now / 1000) + expiresIn
      },
      this.jwtSecret
    );

    const refreshToken = jwt.sign(
      {
        sub: user.id,
        sessionId,
        type: 'refresh',
        iat: Math.floor(now / 1000),
        exp: Math.floor(now / 1000) + (30 * 24 * 3600) // 30 days
      },
      this.jwtSecret
    );

    return {
      accessToken,
      refreshToken,
      tokenType: 'Bearer',
      expiresIn,
      scope: ['read', 'write']
    };
  }

  private async createSession(user: User, context: Partial<SecurityContext>): Promise<AuthSession> {
    const session: AuthSession = {
      sessionId: uuidv4(),
      userId: user.id,
      organizationId: user.organizationId,
      ipAddress: context.ipAddress || '',
      userAgent: context.userAgent || '',
      issuedAt: new Date(),
      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours
      lastActivity: new Date(),
      isActive: true
    };

    this.sessionStore.set(session.sessionId, session);
    return session;
  }

  private async updateLastLogin(userId: string): Promise<void> {
    await this.supabase
      .from('user_profiles')
      .update({ lastLogin: new Date().toISOString() })
      .eq('id', userId);
  }

  private async storeMfaSecret(userId: string, secret: string, backupCodes: string[]): Promise<void> {
    // TODO: Implement encrypted storage of MFA secrets
    // This should use the encryption service to encrypt the secret before storage
  }

  private async getMfaSecret(userId: string): Promise<string | null> {
    // TODO: Implement retrieval and decryption of MFA secrets
    return null;
  }

  private async verifyBackupCode(userId: string, code: string): Promise<boolean> {
    // TODO: Implement backup code verification
    return false;
  }

  private async getUserPermissions(userId: string): Promise<any[]> {
    // TODO: Implement permission retrieval
    return [];
  }

  private async checkSuspiciousActivity(email: string, ipAddress?: string): Promise<void> {
    // TODO: Implement suspicious activity detection
  }

  private async sendVerificationEmail(email: string): Promise<void> {
    // TODO: Implement email verification
  }

  private async logSecurityEvent(event: Omit<SecurityEvent, 'id' | 'timestamp'>): Promise<void> {
    await this.eventService.logEvent({
      ...event,
      id: uuidv4(),
      timestamp: new Date()
    });
  }
}
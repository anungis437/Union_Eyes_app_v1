/**
 * Enterprise Multi-Factor Authentication Service
 * Advanced MFA with multiple authentication factors and risk-based authentication
 */

import speakeasy from 'speakeasy';
import QRCode from 'qrcode';
import crypto from 'crypto';
import { SecurityLogger } from '../utils/logger';
import { EnterpriseAuditService } from './enterprise-audit.service';
import { SecurityEventType } from '../types';

export interface MFAProvider {
  id: string;
  name: string;
  type: 'totp' | 'sms' | 'email' | 'push' | 'hardware_token' | 'biometric';
  isActive: boolean;
  priority: number; // Lower number = higher priority
  config: MFAProviderConfig;
}

export interface MFAProviderConfig {
  // TOTP Configuration
  totpConfig?: {
    issuer: string;
    algorithm: 'sha1' | 'sha256' | 'sha512';
    digits: 6 | 8;
    period: number; // seconds
    window: number; // tolerance window
  };

  // SMS Configuration
  smsConfig?: {
    provider: 'twilio' | 'aws_sns' | 'custom';
    accountSid?: string;
    authToken?: string;
    fromNumber?: string;
    template?: string;
    codeLength: number;
    expiryMinutes: number;
  };

  // Email Configuration
  emailConfig?: {
    provider: 'sendgrid' | 'ses' | 'custom';
    fromEmail: string;
    template: string;
    codeLength: number;
    expiryMinutes: number;
  };

  // Push Notification Configuration
  pushConfig?: {
    provider: 'firebase' | 'apns' | 'custom';
    appId: string;
    serverKey?: string;
    bundleId?: string;
  };

  // Hardware Token Configuration
  hardwareConfig?: {
    tokenType: 'yubikey' | 'rsa_token' | 'custom';
    apiEndpoint?: string;
    apiKey?: string;
  };

  // Biometric Configuration
  biometricConfig?: {
    enabledTypes: ('fingerprint' | 'face' | 'voice' | 'iris')[];
    threshold: number;
    fallbackToPassword: boolean;
  };
}

export interface MFAChallenge {
  challengeId: string;
  userId: string;
  providerId: string;
  providerType: string;
  createdAt: Date;
  expiresAt: Date;
  attempts: number;
  maxAttempts: number;
  isActive: boolean;
  metadata: Record<string, any>;
}

export interface MFAUserSettings {
  userId: string;
  primaryProviderId: string;
  backupProviderIds: string[];
  isEnabled: boolean;
  enrolledProviders: MFAEnrollment[];
  riskLevel: 'low' | 'medium' | 'high';
  lastUsed: Date;
  trustedDevices: TrustedDevice[];
}

export interface MFAEnrollment {
  providerId: string;
  enrolledAt: Date;
  isActive: boolean;
  secret?: string; // Encrypted
  phoneNumber?: string; // For SMS
  email?: string; // For email
  deviceId?: string; // For push/biometric
  publicKey?: string; // For hardware tokens
  metadata: Record<string, any>;
}

export interface TrustedDevice {
  deviceId: string;
  deviceName: string;
  fingerprint: string;
  trustedAt: Date;
  expiresAt: Date;
  lastUsed: Date;
  ipAddress: string;
  userAgent: string;
}

export interface RiskAssessment {
  userId: string;
  sessionId: string;
  riskScore: number; // 0-100
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  factors: RiskFactor[];
  recommendedMFA: string[]; // Provider IDs
  requireAdditionalVerification: boolean;
  calculatedAt: Date;
}

export interface RiskFactor {
  type: 'location' | 'device' | 'behavior' | 'time' | 'velocity' | 'threat_intel';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  value: any;
  weight: number;
}

export interface MFAVerificationResult {
  success: boolean;
  challengeId: string;
  providerId: string;
  remainingAttempts?: number;
  error?: string;
  nextStepRequired?: boolean;
  trustDevice?: boolean;
  metadata?: Record<string, any>;
}

export class EnterpriseMFAService {
  private logger: SecurityLogger;
  private auditService: EnterpriseAuditService;
  private providers: Map<string, MFAProvider> = new Map();
  private activeChallenges: Map<string, MFAChallenge> = new Map();
  private userSettings: Map<string, MFAUserSettings> = new Map();

  constructor(auditService: EnterpriseAuditService) {
    this.logger = new SecurityLogger('EnterpriseMFAService');
    this.auditService = auditService;
    this.initializeDefaultProviders();
    this.startCleanupTimer();
  }

  /**
   * Configure MFA provider
   */
  async configureProvider(provider: MFAProvider): Promise<void> {
    // Encrypt sensitive configuration
    const encryptedProvider = await this.encryptProviderConfig(provider);
    this.providers.set(provider.id, encryptedProvider);

    await this.auditService.logEvent({
      action: 'mfa_provider_configured',
      resource: 'mfa_provider',
      resourceId: provider.id,
      outcome: 'success',
      severity: 'medium',
      source: {
        ip: '127.0.0.1', // Would be actual IP in real implementation
        userAgent: 'system',
      },
      details: {
        providerId: provider.id,
        providerType: provider.type,
        isActive: provider.isActive,
      },
      complianceFlags: ['security', 'soc2'],
      searchableFields: ['action', 'resource', 'providerId'],
    });

    this.logger.info('MFA provider configured', { 
      providerId: provider.id, 
      type: provider.type 
    });
  }

  /**
   * Enroll user in MFA provider
   */
  async enrollUser(
    userId: string,
    providerId: string,
    enrollmentData: Record<string, any>
  ): Promise<{ secret?: string; qrCode?: string; backupCodes?: string[] }> {
    const provider = this.providers.get(providerId);
    if (!provider || !provider.isActive) {
      throw new Error(`MFA provider not found or inactive: ${providerId}`);
    }

    let userSettings = this.userSettings.get(userId);
    if (!userSettings) {
      userSettings = {
        userId,
        primaryProviderId: providerId,
        backupProviderIds: [],
        isEnabled: false,
        enrolledProviders: [],
        riskLevel: 'low',
        lastUsed: new Date(),
        trustedDevices: [],
      };
    }

    const result: { secret?: string; qrCode?: string; backupCodes?: string[] } = {};

    switch (provider.type) {
      case 'totp':
        const totpResult = await this.enrollTOTP(userId, provider);
        result.secret = totpResult.secret;
        result.qrCode = totpResult.qrCode;
        result.backupCodes = totpResult.backupCodes;
        break;

      case 'sms':
        await this.enrollSMS(userId, provider, enrollmentData.phoneNumber);
        break;

      case 'email':
        await this.enrollEmail(userId, provider, enrollmentData.email);
        break;

      case 'push':
        await this.enrollPush(userId, provider, enrollmentData.deviceId);
        break;

      case 'hardware_token':
        await this.enrollHardwareToken(userId, provider, enrollmentData);
        break;

      case 'biometric':
        await this.enrollBiometric(userId, provider, enrollmentData);
        break;
    }

    // Add enrollment to user settings
    const enrollment: MFAEnrollment = {
      providerId,
      enrolledAt: new Date(),
      isActive: true,
      metadata: enrollmentData,
      ...result,
    };

    userSettings.enrolledProviders.push(enrollment);
    if (!userSettings.isEnabled) {
      userSettings.isEnabled = true;
    }

    this.userSettings.set(userId, userSettings);

    await this.auditService.logEvent({
      action: 'mfa_user_enrolled',
      resource: 'user_mfa',
      resourceId: userId,
      userId,
      outcome: 'success',
      severity: 'medium',
      source: {
        ip: '127.0.0.1', // Would be actual IP in real implementation
        userAgent: 'system',
      },
      details: {
        providerId,
        providerType: provider.type,
        enrollmentMethod: provider.type,
      },
      complianceFlags: ['security', 'authentication'],
      searchableFields: ['action', 'resource', 'userId', 'providerId'],
    });

    return result;
  }

  /**
   * Initiate MFA challenge with risk assessment
   */
  async initiateChallenge(
    userId: string,
    sessionId: string,
    context: {
      ipAddress: string;
      userAgent: string;
      deviceFingerprint?: string;
      location?: { country: string; city: string };
    }
  ): Promise<{ challengeId: string; providers: string[]; riskAssessment: RiskAssessment }> {
    const userSettings = this.userSettings.get(userId);
    if (!userSettings || !userSettings.isEnabled) {
      throw new Error('MFA not enabled for user');
    }

    // Perform risk assessment
    const riskAssessment = await this.assessRisk(userId, sessionId, context);

    // Determine required MFA providers based on risk
    const requiredProviders = this.selectProvidersForRisk(
      userSettings,
      riskAssessment
    );

    // Check for trusted device
    const isTrustedDevice = this.isTrustedDevice(userId, context.deviceFingerprint);
    
    if (isTrustedDevice && riskAssessment.riskLevel === 'low') {
      // Skip MFA for trusted device with low risk
      return {
        challengeId: 'trusted_device',
        providers: [],
        riskAssessment,
      };
    }

    // Create challenge
    const challengeId = this.generateChallengeId();
    const challenge: MFAChallenge = {
      challengeId,
      userId,
      providerId: requiredProviders[0], // Primary provider
      providerType: this.providers.get(requiredProviders[0])?.type || 'unknown',
      createdAt: new Date(),
      expiresAt: new Date(Date.now() + 300000), // 5 minutes
      attempts: 0,
      maxAttempts: 3,
      isActive: true,
      metadata: { context, riskAssessment, requiredProviders },
    };

    this.activeChallenges.set(challengeId, challenge);

    // Send challenge to user
    await this.sendChallenge(challenge, requiredProviders[0]);

    await this.auditService.logEvent({
      action: 'mfa_challenge_initiated',
      resource: 'mfa_challenge',
      resourceId: challengeId,
      userId,
      outcome: 'success',
      severity: 'low',
      source: {
        ip: '127.0.0.1', // Would be actual IP in real implementation
        userAgent: 'system',
      },
      details: {
        challengeId,
        providers: requiredProviders,
        riskLevel: riskAssessment.riskLevel,
        riskScore: riskAssessment.riskScore,
      },
      complianceFlags: ['security', 'authentication'],
      searchableFields: ['action', 'resource', 'userId', 'challengeId'],
    });

    return {
      challengeId,
      providers: requiredProviders,
      riskAssessment,
    };
  }

  /**
   * Verify MFA challenge response
   */
  async verifyChallenge(
    challengeId: string,
    code: string,
    additionalData?: Record<string, any>
  ): Promise<MFAVerificationResult> {
    const challenge = this.activeChallenges.get(challengeId);
    
    if (!challenge || !challenge.isActive) {
      return {
        success: false,
        challengeId,
        providerId: '',
        error: 'Invalid or expired challenge',
      };
    }

    if (challenge.expiresAt < new Date()) {
      challenge.isActive = false;
      return {
        success: false,
        challengeId,
        providerId: challenge.providerId,
        error: 'Challenge expired',
      };
    }

    if (challenge.attempts >= challenge.maxAttempts) {
      challenge.isActive = false;
      return {
        success: false,
        challengeId,
        providerId: challenge.providerId,
        error: 'Maximum attempts exceeded',
      };
    }

    challenge.attempts++;

    const provider = this.providers.get(challenge.providerId);
    if (!provider) {
      return {
        success: false,
        challengeId,
        providerId: challenge.providerId,
        error: 'Provider not found',
      };
    }

    // Verify code based on provider type
    const verified = await this.verifyChallengeCode(
      challenge,
      provider,
      code,
      additionalData
    );

    const result: MFAVerificationResult = {
      success: verified,
      challengeId,
      providerId: challenge.providerId,
      remainingAttempts: challenge.maxAttempts - challenge.attempts,
    };

    if (verified) {
      challenge.isActive = false;
      
      // Update user's last used time
      const userSettings = this.userSettings.get(challenge.userId);
      if (userSettings) {
        userSettings.lastUsed = new Date();
      }

      await this.auditService.logEvent({
        action: 'mfa_challenge_verified',
        resource: 'mfa_challenge',
        resourceId: challengeId,
        userId: challenge.userId,
        outcome: 'success',
        severity: 'low',
        source: {
          ip: '127.0.0.1', // Would be actual IP in real implementation
          userAgent: 'system',
        },
        details: {
          challengeId,
          providerId: challenge.providerId,
          attempts: challenge.attempts,
        },
        complianceFlags: ['security', 'authentication'],
        searchableFields: ['action', 'resource', 'userId', 'challengeId', 'providerId'],
      });
    } else {
      await this.auditService.logEvent({
        action: 'mfa_challenge_failed',
        resource: 'mfa_challenge',
        resourceId: challengeId,
        userId: challenge.userId,
        outcome: 'failure',
        severity: 'medium',
        source: {
          ip: '127.0.0.1', // Would be actual IP in real implementation
          userAgent: 'system',
        },
        details: {
          challengeId,
          providerId: challenge.providerId,
          attempts: challenge.attempts,
          remainingAttempts: result.remainingAttempts,
        },
        complianceFlags: ['security', 'authentication'],
        searchableFields: ['action', 'resource', 'userId', 'challengeId'],
      });
    }

    return result;
  }

  /**
   * Add trusted device
   */
  async addTrustedDevice(
    userId: string,
    deviceData: {
      deviceName: string;
      fingerprint: string;
      ipAddress: string;
      userAgent: string;
      expiryDays?: number;
    }
  ): Promise<void> {
    const userSettings = this.userSettings.get(userId);
    if (!userSettings) {
      throw new Error('User MFA settings not found');
    }

    const trustedDevice: TrustedDevice = {
      deviceId: crypto.randomUUID(),
      deviceName: deviceData.deviceName,
      fingerprint: deviceData.fingerprint,
      trustedAt: new Date(),
      expiresAt: new Date(Date.now() + (deviceData.expiryDays || 30) * 24 * 60 * 60 * 1000),
      lastUsed: new Date(),
      ipAddress: deviceData.ipAddress,
      userAgent: deviceData.userAgent,
    };

    userSettings.trustedDevices.push(trustedDevice);
    this.userSettings.set(userId, userSettings);

    await this.auditService.logEvent({
      action: 'mfa_trusted_device_added',
      resource: 'trusted_device',
      resourceId: trustedDevice.deviceId,
      userId,
      outcome: 'success',
      severity: 'medium',
      source: {
        ip: '127.0.0.1', // Would be actual IP in real implementation
        userAgent: 'system',
      },
      details: {
        deviceId: trustedDevice.deviceId,
        deviceName: trustedDevice.deviceName,
        expiresAt: trustedDevice.expiresAt,
      },
      complianceFlags: ['security', 'authentication'],
      searchableFields: ['action', 'resource', 'userId', 'deviceId'],
    });
  }

  // Private helper methods

  private initializeDefaultProviders(): void {
    // TOTP Provider
    this.providers.set('totp-default', {
      id: 'totp-default',
      name: 'Authenticator App',
      type: 'totp',
      isActive: true,
      priority: 1,
      config: {
        totpConfig: {
          issuer: 'CourtLens',
          algorithm: 'sha256',
          digits: 6,
          period: 30,
          window: 1,
        },
      },
    });

    // SMS Provider
    this.providers.set('sms-default', {
      id: 'sms-default',
      name: 'SMS Code',
      type: 'sms',
      isActive: true,
      priority: 2,
      config: {
        smsConfig: {
          provider: 'twilio',
          codeLength: 6,
          expiryMinutes: 5,
          template: 'Your CourtLens verification code is: {code}',
        },
      },
    });
  }

  private async encryptProviderConfig(provider: MFAProvider): Promise<MFAProvider> {
    // Encrypt sensitive configuration data
    return { ...provider }; // Simplified for now
  }

  private async enrollTOTP(
    userId: string,
    provider: MFAProvider
  ): Promise<{ secret: string; qrCode: string; backupCodes: string[] }> {
    const totpConfig = provider.config.totpConfig!;
    
    const secret = speakeasy.generateSecret({
      name: `CourtLens (${userId})`,
      issuer: totpConfig.issuer,
      length: 32,
    });

    const qrCode = await QRCode.toDataURL(secret.otpauth_url!);
    
    // Generate backup codes
    const backupCodes = Array.from({ length: 10 }, () => 
      Math.random().toString(36).substring(2, 8).toUpperCase()
    );

    return {
      secret: secret.base32,
      qrCode,
      backupCodes,
    };
  }

  private async enrollSMS(
    userId: string,
    provider: MFAProvider,
    phoneNumber: string
  ): Promise<void> {
    // Validate phone number and send test SMS
    this.logger.info('SMS MFA enrolled', { userId, phoneNumber });
  }

  private async enrollEmail(
    userId: string,
    provider: MFAProvider,
    email: string
  ): Promise<void> {
    // Validate email and send test email
    this.logger.info('Email MFA enrolled', { userId, email });
  }

  private async enrollPush(
    userId: string,
    provider: MFAProvider,
    deviceId: string
  ): Promise<void> {
    // Register device for push notifications
    this.logger.info('Push MFA enrolled', { userId, deviceId });
  }

  private async enrollHardwareToken(
    userId: string,
    provider: MFAProvider,
    enrollmentData: Record<string, any>
  ): Promise<void> {
    // Register hardware token
    this.logger.info('Hardware token MFA enrolled', { userId, enrollmentData });
  }

  private async enrollBiometric(
    userId: string,
    provider: MFAProvider,
    enrollmentData: Record<string, any>
  ): Promise<void> {
    // Register biometric data
    this.logger.info('Biometric MFA enrolled', { userId, enrollmentData });
  }

  async assessRisk(
    userId: string,
    sessionId: string,
    context: any
  ): Promise<RiskAssessment> {
    const factors: RiskFactor[] = [];
    let riskScore = 0;

    // Location-based risk
    if (context.location) {
      const isNewLocation = true; // Check against user's typical locations
      if (isNewLocation) {
        factors.push({
          type: 'location',
          severity: 'medium',
          description: 'Login from new location',
          value: context.location,
          weight: 20,
        });
        riskScore += 20;
      }
    }

    // Device-based risk
    if (context.deviceFingerprint) {
      const isNewDevice = !this.isTrustedDevice(userId, context.deviceFingerprint);
      if (isNewDevice) {
        factors.push({
          type: 'device',
          severity: 'high',
          description: 'Login from new device',
          value: context.deviceFingerprint,
          weight: 30,
        });
        riskScore += 30;
      }
    }

    // Time-based risk
    const currentHour = new Date().getHours();
    if (currentHour < 6 || currentHour > 22) {
      factors.push({
        type: 'time',
        severity: 'low',
        description: 'Login outside normal hours',
        value: currentHour,
        weight: 10,
      });
      riskScore += 10;
    }

    const riskLevel = riskScore < 20 ? 'low' : 
                      riskScore < 50 ? 'medium' : 
                      riskScore < 80 ? 'high' : 'critical';

    return {
      userId,
      sessionId,
      riskScore,
      riskLevel,
      factors,
      recommendedMFA: this.getRecommendedMFAForRisk(riskLevel),
      requireAdditionalVerification: riskLevel === 'high' || riskLevel === 'critical',
      calculatedAt: new Date(),
    };
  }

  private selectProvidersForRisk(
    userSettings: MFAUserSettings,
    riskAssessment: RiskAssessment
  ): string[] {
    const activeProviders = userSettings.enrolledProviders
      .filter(e => e.isActive)
      .map(e => e.providerId);

    switch (riskAssessment.riskLevel) {
      case 'low':
        return [userSettings.primaryProviderId].filter(id => activeProviders.includes(id));
      case 'medium':
        return [userSettings.primaryProviderId, ...userSettings.backupProviderIds.slice(0, 1)]
          .filter(id => activeProviders.includes(id));
      case 'high':
      case 'critical':
        return [userSettings.primaryProviderId, ...userSettings.backupProviderIds]
          .filter(id => activeProviders.includes(id));
      default:
        return [userSettings.primaryProviderId];
    }
  }

  private getRecommendedMFAForRisk(riskLevel: string): string[] {
    switch (riskLevel) {
      case 'low':
        return ['totp-default'];
      case 'medium':
        return ['totp-default', 'sms-default'];
      case 'high':
        return ['totp-default', 'sms-default', 'push-default'];
      case 'critical':
        return ['hardware_token', 'biometric', 'totp-default'];
      default:
        return ['totp-default'];
    }
  }

  private isTrustedDevice(userId: string, deviceFingerprint?: string): boolean {
    if (!deviceFingerprint) return false;

    const userSettings = this.userSettings.get(userId);
    if (!userSettings) return false;

    return userSettings.trustedDevices.some(device => 
      device.fingerprint === deviceFingerprint &&
      device.expiresAt > new Date()
    );
  }

  private generateChallengeId(): string {
    return `mfa_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private async sendChallenge(challenge: MFAChallenge, providerId: string): Promise<void> {
    const provider = this.providers.get(providerId);
    if (!provider) return;

    switch (provider.type) {
      case 'totp':
        // TOTP doesn't require sending, user uses their app
        break;
      case 'sms':
        await this.sendSMSCode(challenge);
        break;
      case 'email':
        await this.sendEmailCode(challenge);
        break;
      case 'push':
        await this.sendPushNotification(challenge);
        break;
    }
  }

  private async sendSMSCode(challenge: MFAChallenge): Promise<void> {
    // Generate and send SMS code
    const code = Math.floor(100000 + Math.random() * 900000).toString();
    challenge.metadata.code = code;
    this.logger.info('SMS code sent', { challengeId: challenge.challengeId });
  }

  private async sendEmailCode(challenge: MFAChallenge): Promise<void> {
    // Generate and send email code
    const code = Math.floor(100000 + Math.random() * 900000).toString();
    challenge.metadata.code = code;
    this.logger.info('Email code sent', { challengeId: challenge.challengeId });
  }

  private async sendPushNotification(challenge: MFAChallenge): Promise<void> {
    // Send push notification
    this.logger.info('Push notification sent', { challengeId: challenge.challengeId });
  }

  private async verifyChallengeCode(
    challenge: MFAChallenge,
    provider: MFAProvider,
    code: string,
    additionalData?: Record<string, any>
  ): Promise<boolean> {
    switch (provider.type) {
      case 'totp':
        return this.verifyTOTPCode(challenge, provider, code);
      case 'sms':
      case 'email':
        return challenge.metadata.code === code;
      case 'push':
        return additionalData?.approved === true;
      case 'hardware_token':
        return this.verifyHardwareToken(challenge, provider, code);
      case 'biometric':
        return this.verifyBiometric(challenge, provider, additionalData);
      default:
        return false;
    }
  }

  private verifyTOTPCode(challenge: MFAChallenge, provider: MFAProvider, code: string): boolean {
    const userSettings = this.userSettings.get(challenge.userId);
    if (!userSettings) return false;

    const enrollment = userSettings.enrolledProviders.find(e => e.providerId === provider.id);
    if (!enrollment?.secret) return false;

    const totpConfig = provider.config.totpConfig!;
    
    return speakeasy.totp.verify({
      secret: enrollment.secret,
      encoding: 'base32',
      token: code,
      window: totpConfig.window,
      step: totpConfig.period,
    });
  }

  private verifyHardwareToken(
    challenge: MFAChallenge,
    provider: MFAProvider,
    code: string
  ): boolean {
    // Verify hardware token code
    return true; // Simplified
  }

  private verifyBiometric(
    challenge: MFAChallenge,
    provider: MFAProvider,
    additionalData?: Record<string, any>
  ): boolean {
    // Verify biometric data
    return additionalData?.biometricVerified === true;
  }

  private startCleanupTimer(): void {
    setInterval(() => {
      const now = new Date();
      
      // Clean up expired challenges
      for (const [challengeId, challenge] of this.activeChallenges) {
        if (challenge.expiresAt < now) {
          this.activeChallenges.delete(challengeId);
        }
      }

      // Clean up expired trusted devices
      for (const [userId, userSettings] of this.userSettings) {
        userSettings.trustedDevices = userSettings.trustedDevices.filter(
          device => device.expiresAt > now
        );
      }
    }, 60000); // Every minute
  }
}
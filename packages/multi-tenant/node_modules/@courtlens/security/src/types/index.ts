// CourtLens Security Framework Types
// Comprehensive type definitions for authentication, authorization, and security

export interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: UserRole;
  organizationId: string;
  isActive: boolean;
  emailVerified: boolean;
  mfaEnabled: boolean;
  lastLogin?: Date;
  createdAt: Date;
  updatedAt: Date;
}

export enum UserRole {
  SUPER_ADMIN = 'super_admin',
  ORG_ADMIN = 'org_admin',
  PARTNER = 'partner',
  SENIOR_ASSOCIATE = 'senior_associate',
  ASSOCIATE = 'associate',
  PARALEGAL = 'paralegal',
  CLIENT = 'client',
  GUEST = 'guest'
}

export interface Organization {
  id: string;
  name: string;
  domain: string;
  subscriptionTier: SubscriptionTier;
  isActive: boolean;
  securitySettings: OrganizationSecuritySettings;
  createdAt: Date;
  updatedAt: Date;
}

export enum SubscriptionTier {
  BASIC = 'basic',
  PROFESSIONAL = 'professional',
  ENTERPRISE = 'enterprise',
  ENTERPRISE_PLUS = 'enterprise_plus'
}

export interface OrganizationSecuritySettings {
  enforcePasswordPolicy: boolean;
  requireMfa: boolean;
  sessionTimeoutMinutes: number;
  allowedIpRanges?: string[];
  enableAuditLogging: boolean;
  dataRetentionDays: number;
  encryptionLevel: EncryptionLevel;
}

export enum EncryptionLevel {
  STANDARD = 'standard',
  ENHANCED = 'enhanced',
  MAXIMUM = 'maximum'
}

// Authentication Types
export interface AuthToken {
  accessToken: string;
  refreshToken: string;
  tokenType: 'Bearer';
  expiresIn: number;
  scope: string[];
}

export interface MfaSetup {
  secret: string;
  qrCodeUrl: string;
  backupCodes: string[];
}

export interface AuthSession {
  sessionId: string;
  userId: string;
  organizationId: string;
  ipAddress: string;
  userAgent: string;
  issuedAt: Date;
  expiresAt: Date;
  lastActivity: Date;
  isActive: boolean;
}

// Authorization Types
export interface Permission {
  id: string;
  name: string;
  resource: string;
  action: string;
  conditions?: Record<string, any>;
}

export interface PermissionCheck {
  resource: string;
  action: string;
  conditions?: Record<string, any>;
}

export interface Role {
  id: string;
  name: string;
  description: string;
  permissions: Permission[];
  organizationId: string;
  isSystemRole: boolean;
}

export interface AccessControl {
  userId: string;
  resource: string;
  action: string;
  organizationId: string;
  conditions?: Record<string, any>;
}

// Security Event Types
export enum SecurityEventType {
  LOGIN_SUCCESS = 'login_success',
  LOGIN_FAILURE = 'login_failure',
  LOGOUT = 'logout',
  PASSWORD_CHANGE = 'password_change',
  MFA_ENABLED = 'mfa_enabled',
  MFA_DISABLED = 'mfa_disabled',
  ACCOUNT_LOCKED = 'account_locked',
  ACCOUNT_UNLOCKED = 'account_unlocked',
  PERMISSION_DENIED = 'permission_denied',
  DATA_ACCESS = 'data_access',
  DATA_MODIFICATION = 'data_modification',
  SECURITY_VIOLATION = 'security_violation',
  SUSPICIOUS_ACTIVITY = 'suspicious_activity'
}

export interface SecurityEvent {
  id: string;
  type: SecurityEventType;
  userId?: string;
  organizationId: string;
  ipAddress: string;
  userAgent: string;
  resource?: string;
  action?: string;
  details: Record<string, any>;
  riskLevel: RiskLevel;
  timestamp: Date;
}

export enum RiskLevel {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}

// Security Policy Types
export interface SecurityPolicy {
  id: string;
  name: string;
  description: string;
  organizationId: string;
  rules: SecurityRule[];
  isActive: boolean;
  priority: number;
  createdAt: Date;
  updatedAt: Date;
}

export interface SecurityRule {
  id: string;
  condition: string;
  action: SecurityAction;
  parameters: Record<string, any>;
}

export enum SecurityAction {
  ALLOW = 'allow',
  DENY = 'deny',
  REQUIRE_MFA = 'require_mfa',
  LOG_ONLY = 'log_only',
  QUARANTINE = 'quarantine',
  NOTIFY_ADMIN = 'notify_admin'
}

// Encryption Types
export interface EncryptionConfig {
  algorithm: string;
  keySize: number;
  ivSize: number;
  saltSize: number;
  iterations: number;
}

export interface EncryptedData {
  data: string;
  iv: string;
  salt: string;
  algorithm: string;
  keyId: string;
  level?: EncryptionLevel;
}

// Audit Types
export interface AuditLog {
  id: string;
  userId: string;
  organizationId: string;
  action: string;
  resource: string;
  oldValues?: Record<string, any>;
  newValues?: Record<string, any>;
  ipAddress: string;
  userAgent: string;
  timestamp: Date;
  success: boolean;
  errorMessage?: string;
}

// API Security Types
export interface ApiKey {
  id: string;
  name: string;
  keyHash: string;
  organizationId: string;
  userId: string;
  scopes: string[];
  isActive: boolean;
  lastUsed?: Date;
  expiresAt?: Date;
  createdAt: Date;
}

export interface RateLimitConfig {
  windowMs: number;
  maxRequests: number;
  skipSuccessfulRequests: boolean;
  skipFailedRequests: boolean;
  keyGenerator: (req: any) => string;
}

// Legal Domain Security Types
export interface DocumentSecurity {
  documentId: string;
  classification: DocumentClassification;
  accessLevel: AccessLevel;
  retentionPolicy: RetentionPolicy;
  encryptionRequired: boolean;
  auditRequired: boolean;
  restrictedCountries?: string[];
}

export enum DocumentClassification {
  PUBLIC = 'public',
  INTERNAL = 'internal',
  CONFIDENTIAL = 'confidential',
  RESTRICTED = 'restricted',
  TOP_SECRET = 'top_secret'
}

export enum AccessLevel {
  READ_ONLY = 'read_only',
  READ_WRITE = 'read_write',
  FULL_ACCESS = 'full_access',
  NO_ACCESS = 'no_access'
}

export interface RetentionPolicy {
  retentionPeriodDays: number;
  autoDelete: boolean;
  archiveRequired: boolean;
  legalHoldExempt: boolean;
}

// Compliance Types
export interface ComplianceFramework {
  id: string;
  name: string;
  version: string;
  requirements: ComplianceRequirement[];
  applicableRegions: string[];
}

export interface ComplianceRequirement {
  id: string;
  section: string;
  description: string;
  controls: ComplianceControl[];
  mandatory: boolean;
}

export interface ComplianceControl {
  id: string;
  name: string;
  description: string;
  implementationStatus: ImplementationStatus;
  lastAssessment?: Date;
  nextAssessment?: Date;
  responsible: string;
}

export enum ImplementationStatus {
  NOT_IMPLEMENTED = 'not_implemented',
  PARTIALLY_IMPLEMENTED = 'partially_implemented',
  IMPLEMENTED = 'implemented',
  NEEDS_REVIEW = 'needs_review'
}

// Security Configuration Types
export interface SecurityConfig {
  authentication: AuthenticationConfig;
  authorization: AuthorizationConfig;
  encryption: EncryptionConfig;
  monitoring: MonitoringConfig;
  compliance: ComplianceConfig;
}

export interface AuthenticationConfig {
  requireMfa: boolean;
  sessionTimeoutMinutes: number;
  maxLoginAttempts: number;
  lockoutDurationMinutes: number;
  passwordPolicy: PasswordPolicy;
}

export interface PasswordPolicy {
  minLength: number;
  requireUppercase: boolean;
  requireLowercase: boolean;
  requireNumbers: boolean;
  requireSpecialChars: boolean;
  maxAge: number;
  preventReuse: number;
}

export interface AuthorizationConfig {
  defaultRole: UserRole;
  inheritanceEnabled: boolean;
  cacheTimeout: number;
  strictMode: boolean;
}

export interface MonitoringConfig {
  enableRealTimeAlerts: boolean;
  alertThresholds: AlertThresholds;
  logLevel: LogLevel;
  retentionDays: number;
}

export interface AlertThresholds {
  failedLoginAttempts: number;
  suspiciousActivityScore: number;
  dataAccessVolumeThreshold: number;
  unusualLocationThreshold: number;
}

export enum LogLevel {
  DEBUG = 'debug',
  INFO = 'info',
  WARN = 'warn',
  ERROR = 'error',
  CRITICAL = 'critical'
}

export interface ComplianceConfig {
  frameworks: string[];
  automaticAssessment: boolean;
  reportingFrequency: ReportingFrequency;
  notificationEmail: string;
}

export enum ReportingFrequency {
  DAILY = 'daily',
  WEEKLY = 'weekly',
  MONTHLY = 'monthly',
  QUARTERLY = 'quarterly',
  ANNUALLY = 'annually'
}

// Error Types
export class SecurityError extends Error {
  public readonly code: string;
  public readonly statusCode: number;
  public readonly details?: Record<string, any>;

  constructor(message: string, code: string, statusCode: number = 500, details?: Record<string, any>) {
    super(message);
    this.name = 'SecurityError';
    this.code = code;
    this.statusCode = statusCode;
    this.details = details;
  }
}

export class AuthenticationError extends SecurityError {
  constructor(message: string, details?: Record<string, any>) {
    super(message, 'AUTHENTICATION_ERROR', 401, details);
    this.name = 'AuthenticationError';
  }
}

export class AuthorizationError extends SecurityError {
  constructor(message: string, details?: Record<string, any>) {
    super(message, 'AUTHORIZATION_ERROR', 403, details);
    this.name = 'AuthorizationError';
  }
}

export class ValidationError extends SecurityError {
  constructor(message: string, details?: Record<string, any>) {
    super(message, 'VALIDATION_ERROR', 400, details);
    this.name = 'ValidationError';
  }
}

export class EncryptionError extends SecurityError {
  constructor(message: string, details?: Record<string, any>) {
    super(message, 'ENCRYPTION_ERROR', 500, details);
    this.name = 'EncryptionError';
  }
}

// Request Context Types
export interface Permission {
  id: string;
  name: string;
  resource: string;
  action: string;
  conditions?: Record<string, any>;
}

export interface SecurityContext {
  user?: User;
  organization?: Organization;
  session?: AuthSession;
  permissions: Permission[];
  ipAddress: string;
  userAgent: string;
  requestId: string;
  timestamp: Date;
}
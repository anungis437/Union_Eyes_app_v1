/**
 * Advanced Authentication Service for CourtLens
 * 
 * TypeScript service that provides advanced Supabase Auth Pro features including
 * SSO integration, MFA setup, custom JWT claims, organization-based access control,
 * role-based permissions, and enhanced security features.
 * 
 * Features:
 * - Single Sign-On (SSO) with multiple providers
 * - Multi-Factor Authentication (MFA) with TOTP
 * - Custom JWT claims and session management
 * - Role-based access control (RBAC)
 * - Organization-based user management
 * - Security monitoring and audit logging
 * - Advanced session management
 * 
 * @module AuthenticationService
 */

import { createClient, SupabaseClient, AuthError, Session, User } from '@supabase/supabase-js';
// import { authenticator } from 'otplib'; // Temporarily commented out until dependency is available
import * as React from 'react';

const { useState, useCallback, useEffect, useContext, createContext } = React;

export type SSOProviderType = 'saml' | 'oidc' | 'oauth2' | 'ldap';

export type UserRole = 'owner' | 'admin' | 'attorney' | 'user' | 'guest';

export type SecurityEventType = 
  | 'login_success'
  | 'login_failed'
  | 'logout'
  | 'password_changed'
  | 'mfa_enabled'
  | 'mfa_disabled'
  | 'mfa_verified'
  | 'role_changed'
  | 'role_assigned'
  | 'role_removed'
  | 'permission_granted'
  | 'permission_revoked'
  | 'suspicious_activity'
  | 'account_locked'
  | 'account_unlocked';

export interface AuthUser extends User {
  organization_id?: string;
  role?: UserRole;
  mfa_enabled?: boolean;
  last_login_at?: string;
  session_timeout_minutes?: number;
}

export interface CustomJWTClaims {
  user_id: string;
  email: string;
  role: UserRole;
  organization_id: string;
  organization_name: string;
  subscription_tier: string;
  roles: string[];
  permissions: string[];
  mfa_enabled: boolean;
  last_login: string;
  session_timeout: number;
}

export interface SSOProvider {
  id: string;
  organization_id: string;
  provider_type: SSOProviderType;
  provider_name: string;
  config: Record<string, any>;
  metadata: Record<string, any>;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

export interface SSOUserMapping {
  id: string;
  user_id: string;
  sso_provider_id: string;
  external_user_id: string;
  external_email: string;
  external_attributes: Record<string, any>;
  first_login_at: string;
  last_login_at: string;
}

export interface Role {
  id: string;
  organization_id: string;
  name: string;
  description?: string;
  is_system_role: boolean;
  permissions: string[];
  parent_role_id?: string;
  created_at: string;
  updated_at: string;
}

export interface UserRoleAssignment {
  id: string;
  user_id: string;
  role_id: string;
  assigned_by?: string;
  assigned_at: string;
  expires_at?: string;
  is_active: boolean;
}

export interface UserSession {
  id: string;
  user_id: string;
  session_token: string;
  refresh_token?: string;
  ip_address?: string;
  user_agent?: string;
  location?: Record<string, any>;
  created_at: string;
  last_activity_at: string;
  expires_at: string;
  is_active: boolean;
  login_method: string;
  mfa_verified: boolean;
}

export interface SecurityEvent {
  id: string;
  user_id?: string;
  organization_id?: string;
  event_type: SecurityEventType;
  event_data: Record<string, any>;
  ip_address?: string;
  user_agent?: string;
  session_id?: string;
  risk_score: number;
  created_at: string;
}

export interface LoginSecurityCheck {
  is_blocked: boolean;
  block_reason?: string;
  failed_attempts: number;
  mfa_required: boolean;
}

export interface MFASetupResult {
  secret: string;
  qr_code_url: string;
  backup_codes: string[];
}

export interface AuthenticationOptions {
  requireMFA?: boolean;
  sessionTimeout?: number;
  rememberMe?: boolean;
  ipWhitelist?: string[];
}

export interface OrganizationAuthSettings {
  sso_enabled: boolean;
  sso_domain?: string;
  sso_provider?: string;
  mfa_required: boolean;
  password_policy: {
    min_length: number;
    require_uppercase: boolean;
    require_lowercase: boolean;
    require_numbers: boolean;
    require_symbols: boolean;
  };
  session_timeout_minutes: number;
  allowed_domains?: string[];
  security_settings: Record<string, any>;
}

export interface PasswordPolicy {
  min_length: number;
  require_uppercase: boolean;
  require_lowercase: boolean;
  require_numbers: boolean;
  require_symbols: boolean;
  max_age_days?: number;
  prevent_reuse?: number;
}

// ============================================================================
// AUTHENTICATION SERVICE CLASS
// ============================================================================

export class AuthenticationService {
  public supabase: SupabaseClient;
  private organizationId?: string;

  constructor(supabaseUrl: string, supabaseKey: string, organizationId?: string) {
    this.supabase = createClient(supabaseUrl, supabaseKey);
    this.organizationId = organizationId;
  }

  // ============================================================================
  // BASIC AUTHENTICATION
  // ============================================================================

  /**
   * Sign in with email and password with enhanced security checks
   */
  async signIn(
    email: string,
    password: string,
    options: AuthenticationOptions = {}
  ): Promise<{
    user: AuthUser | null;
    session: Session | null;
    error: AuthError | null;
    requiresMFA?: boolean;
  }> {
    try {
      // Check login security policies
      const securityCheck = await this.checkLoginSecurity(email);
      
      if (securityCheck.is_blocked) {
        return {
          user: null,
          session: null,
          error: new AuthError(`Login blocked: ${securityCheck.block_reason}`)
        };
      }

      // Attempt authentication
      const { data, error } = await this.supabase.auth.signInWithPassword({
        email,
        password
      });

      if (error) {
        // Log failed attempt
        await this.logFailedLoginAttempt(email);
        return { user: null, session: null, error };
      }

      // Check if MFA is required
      const user = data.user as AuthUser;
      if (securityCheck.mfa_required || user.mfa_enabled) {
        // Don't complete session until MFA is verified
        return {
          user,
          session: null,
          error: null,
          requiresMFA: true
        };
      }

      // Create enhanced session
      const session = await this.createEnhancedSession(
        user.id,
        data.session?.access_token || '',
        data.session?.refresh_token || '',
        options
      );

      return {
        user,
        session: data.session,
        error: null
      };

    } catch (error) {
      return {
        user: null,
        session: null,
        error: error as AuthError
      };
    }
  }

  /**
   * Sign in with SSO provider
   */
  async signInWithSSO(
    providerId: string,
    options: AuthenticationOptions = {}
  ): Promise<{
    url?: string;
    error: AuthError | null;
  }> {
    try {
      // Get SSO provider configuration
      const provider = await this.getSSOProvider(providerId);
      
      if (!provider || !provider.is_active) {
        throw new Error('SSO provider not found or inactive');
      }

      // Configure SSO redirect based on provider type
      const redirectTo = `${window.location.origin}/auth/callback`;
      
      const { data, error } = await this.supabase.auth.signInWithOAuth({
        provider: provider.provider_name as any,
        options: {
          redirectTo,
          scopes: 'email profile',
          queryParams: {
            organization_id: this.organizationId || '',
            sso_provider_id: providerId
          }
        }
      });

      return {
        url: data.url || undefined,
        error
      };

    } catch (error) {
      return {
        url: undefined,
        error: error as AuthError
      };
    }
  }

  /**
   * Handle SSO callback and user provisioning
   */
  async handleSSOCallback(
    externalUserId: string,
    email: string,
    ssoProviderId: string,
    externalAttributes: Record<string, any> = {}
  ): Promise<AuthUser | null> {
    try {
      // Provision or update SSO user
      const { data: userId, error } = await this.supabase.rpc('provision_sso_user', {
        p_email: email,
        p_organization_id: this.organizationId,
        p_sso_provider_id: ssoProviderId,
        p_external_user_id: externalUserId,
        p_external_attributes: externalAttributes
      });

      if (error) {
        throw error;
      }

      // Get user details
      const { data: user } = await this.supabase
        .from('users')
        .select('*')
        .eq('id', userId)
        .single();

      return user as AuthUser;

    } catch (error) {
      console.error('SSO callback error:', error);
      return null;
    }
  }

  /**
   * Sign out with session cleanup
   */
  async signOut(): Promise<{ error: AuthError | null }> {
    try {
      // Get current session
      const { data: session } = await this.supabase.auth.getSession();
      
      if (session?.session) {
        // Mark session as inactive
        await this.supabase
          .from('user_sessions')
          .update({ is_active: false })
          .eq('session_token', session.session.access_token);
          
        // Log security event
        await this.logSecurityEvent('logout', {
          session_id: session.session.access_token
        });
      }

      // Sign out from Supabase
      const { error } = await this.supabase.auth.signOut();
      
      return { error };

    } catch (error) {
      return { error: error as AuthError };
    }
  }

  // ============================================================================
  // MULTI-FACTOR AUTHENTICATION
  // ============================================================================

  /**
   * Set up MFA for user
   */
  async setupMFA(userId: string): Promise<MFASetupResult> {
    try {
      // Generate MFA secret
      const { data: secret, error } = await this.supabase.rpc('generate_mfa_secret', {
        p_user_id: userId
      });

      if (error) {
        throw error;
      }

      // Generate QR code URL for authenticator apps
      const user = await this.getCurrentUser();
      // TODO: Re-enable when otplib dependency is available
      const qrCodeUrl = `otpauth://totp/CourtLens:${user?.email || ''}?secret=${secret}&issuer=CourtLens`;
      // const qrCodeUrl = authenticator.keyuri(
      //   user?.email || '',
      //   'CourtLens',
      //   secret
      // );

      // Generate backup codes
      const backupCodes = Array.from({ length: 10 }, () => 
        Math.random().toString(36).substring(2, 8).toUpperCase()
      );

      // Store backup codes (encrypted)
      await this.supabase
        .from('user_mfa_backup_codes')
        .insert(
          backupCodes.map(code => ({
            user_id: userId,
            code_hash: this.hashBackupCode(code),
            created_at: new Date().toISOString()
          }))
        );

      return {
        secret,
        qr_code_url: qrCodeUrl,
        backup_codes: backupCodes
      };

    } catch (error) {
      throw new Error(`MFA setup failed: ${error}`);
    }
  }

  /**
   * Verify MFA token
   */
  async verifyMFA(
    userId: string,
    token: string,
    isBackupCode = false
  ): Promise<boolean> {
    try {
      if (isBackupCode) {
        return await this.verifyBackupCode(userId, token);
      }

      // Verify TOTP token
      const { data: isValid, error } = await this.supabase.rpc('verify_mfa_token', {
        p_user_id: userId,
        p_token: token
      });

      if (error) {
        throw error;
      }

      if (isValid) {
        // Log MFA success
        await this.logSecurityEvent('mfa_verified', {
          user_id: userId,
          method: 'totp'
        });
      }

      return isValid || false;

    } catch (error) {
      console.error('MFA verification error:', error);
      return false;
    }
  }

  /**
   * Disable MFA for user
   */
  async disableMFA(userId: string): Promise<boolean> {
    try {
      // Update user MFA settings
      const { error } = await this.supabase
        .from('users')
        .update({
          mfa_enabled: false,
          mfa_secret: null,
          updated_at: new Date().toISOString()
        })
        .eq('id', userId);

      if (error) {
        throw error;
      }

      // Remove backup codes
      await this.supabase
        .from('user_mfa_backup_codes')
        .delete()
        .eq('user_id', userId);

      // Log security event
      await this.logSecurityEvent('mfa_disabled', {
        user_id: userId
      });

      return true;

    } catch (error) {
      console.error('MFA disable error:', error);
      return false;
    }
  }

  // ============================================================================
  // ROLE-BASED ACCESS CONTROL
  // ============================================================================

  /**
   * Check if user has specific permission
   */
  async hasPermission(
    userId: string,
    permission: string,
    resourceType?: string,
    resourceId?: string
  ): Promise<boolean> {
    try {
      const { data: hasPermission, error } = await this.supabase.rpc('check_user_permission', {
        p_user_id: userId,
        p_permission: permission,
        p_resource_type: resourceType,
        p_resource_id: resourceId
      });

      if (error) {
        throw error;
      }

      return hasPermission || false;

    } catch (error) {
      console.error('Permission check error:', error);
      return false;
    }
  }

  /**
   * Get user roles
   */
  async getUserRoles(userId: string): Promise<Role[]> {
    try {
      const { data: roles, error } = await this.supabase
        .from('user_roles')
        .select(`
          role:roles(*)
        `)
        .eq('user_id', userId)
        .eq('is_active', true)
        .or('expires_at.is.null,expires_at.gt.now()');

      if (error) {
        throw error;
      }

      return (roles?.map((ur: any) => ur.role).filter(Boolean) as Role[]) || [];

    } catch (error) {
      console.error('Get user roles error:', error);
      return [];
    }
  }

  /**
   * Assign role to user
   */
  async assignRole(
    userId: string,
    roleId: string,
    assignedBy: string,
    expiresAt?: string
  ): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from('user_roles')
        .insert({
          user_id: userId,
          role_id: roleId,
          assigned_by: assignedBy,
          expires_at: expiresAt
        });

      if (error) {
        throw error;
      }

      // Log security event
      await this.logSecurityEvent('role_assigned', {
        user_id: userId,
        role_id: roleId,
        assigned_by: assignedBy
      });

      return true;

    } catch (error) {
      console.error('Role assignment error:', error);
      return false;
    }
  }

  /**
   * Remove role from user
   */
  async removeRole(userId: string, roleId: string): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from('user_roles')
        .update({ is_active: false })
        .eq('user_id', userId)
        .eq('role_id', roleId);

      if (error) {
        throw error;
      }

      // Log security event
      await this.logSecurityEvent('role_removed', {
        user_id: userId,
        role_id: roleId
      });

      return true;

    } catch (error) {
      console.error('Role removal error:', error);
      return false;
    }
  }

  // ============================================================================
  // SSO MANAGEMENT
  // ============================================================================

  /**
   * Get SSO providers for organization
   */
  async getSSOProviders(): Promise<SSOProvider[]> {
    if (!this.organizationId) {
      throw new Error('Organization ID required for SSO operations');
    }

    try {
      const { data: providers, error } = await this.supabase
        .from('sso_providers')
        .select('*')
        .eq('organization_id', this.organizationId)
        .eq('is_active', true)
        .order('created_at', { ascending: false });

      if (error) {
        throw error;
      }

      return providers || [];

    } catch (error) {
      console.error('Get SSO providers error:', error);
      return [];
    }
  }

  /**
   * Get specific SSO provider
   */
  async getSSOProvider(providerId: string): Promise<SSOProvider | null> {
    try {
      const { data: provider, error } = await this.supabase
        .from('sso_providers')
        .select('*')
        .eq('id', providerId)
        .single();

      if (error) {
        throw error;
      }

      return provider;

    } catch (error) {
      console.error('Get SSO provider error:', error);
      return null;
    }
  }

  /**
   * Create SSO provider configuration
   */
  async createSSOProvider(
    providerType: SSOProviderType,
    providerName: string,
    config: Record<string, any>,
    metadata: Record<string, any> = {}
  ): Promise<SSOProvider | null> {
    if (!this.organizationId) {
      throw new Error('Organization ID required for SSO operations');
    }

    try {
      const { data: provider, error } = await this.supabase
        .from('sso_providers')
        .insert({
          organization_id: this.organizationId,
          provider_type: providerType,
          provider_name: providerName,
          config,
          metadata
        })
        .select()
        .single();

      if (error) {
        throw error;
      }

      return provider;

    } catch (error) {
      console.error('Create SSO provider error:', error);
      return null;
    }
  }

  // ============================================================================
  // SESSION MANAGEMENT
  // ============================================================================

  /**
   * Create enhanced session with custom claims
   */
  async createEnhancedSession(
    userId: string,
    sessionToken: string,
    refreshToken: string,
    options: AuthenticationOptions = {}
  ): Promise<UserSession | null> {
    try {
      // Get client info
      const ipAddress = await this.getClientIP();
      const userAgent = navigator.userAgent;

      // Create session
      const { data: sessionId, error } = await this.supabase.rpc('create_user_session', {
        p_user_id: userId,
        p_session_token: sessionToken,
        p_refresh_token: refreshToken,
        p_ip_address: ipAddress,
        p_user_agent: userAgent,
        p_login_method: 'password',
        p_mfa_verified: false
      });

      if (error) {
        throw error;
      }

      // Get session details
      const { data: session } = await this.supabase
        .from('user_sessions')
        .select('*')
        .eq('id', sessionId)
        .single();

      return session;

    } catch (error) {
      console.error('Create enhanced session error:', error);
      return null;
    }
  }

  /**
   * Validate current session
   */
  async validateSession(sessionToken: string): Promise<{
    isValid: boolean;
    user?: AuthUser;
    claims?: CustomJWTClaims;
  }> {
    try {
      const { data: sessionData, error } = await this.supabase.rpc('validate_session', {
        p_session_token: sessionToken
      });

      if (error || !sessionData) {
        return { isValid: false };
      }

      // Get user details
      const { data: user } = await this.supabase
        .from('users')
        .select('*')
        .eq('id', sessionData.user_id)
        .single();

      return {
        isValid: true,
        user: user as AuthUser,
        claims: sessionData.claims as CustomJWTClaims
      };

    } catch (error) {
      console.error('Session validation error:', error);
      return { isValid: false };
    }
  }

  /**
   * Get active sessions for user
   */
  async getActiveSessions(userId: string): Promise<UserSession[]> {
    try {
      const { data: sessions, error } = await this.supabase
        .from('user_sessions')
        .select('*')
        .eq('user_id', userId)
        .eq('is_active', true)
        .gt('expires_at', new Date().toISOString())
        .order('last_activity_at', { ascending: false });

      if (error) {
        throw error;
      }

      return sessions || [];

    } catch (error) {
      console.error('Get active sessions error:', error);
      return [];
    }
  }

  /**
   * Revoke session
   */
  async revokeSession(sessionId: string): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from('user_sessions')
        .update({ is_active: false })
        .eq('id', sessionId);

      if (error) {
        throw error;
      }

      return true;

    } catch (error) {
      console.error('Revoke session error:', error);
      return false;
    }
  }

  // ============================================================================
  // SECURITY AND MONITORING
  // ============================================================================

  /**
   * Check login security policies
   */
  async checkLoginSecurity(email: string): Promise<LoginSecurityCheck> {
    try {
      const ipAddress = await this.getClientIP();
      
      const { data: securityCheck, error } = await this.supabase.rpc('check_login_security', {
        p_email: email,
        p_ip_address: ipAddress,
        p_organization_id: this.organizationId
      });

      if (error) {
        throw error;
      }

      return securityCheck || {
        is_blocked: false,
        failed_attempts: 0,
        mfa_required: false
      };

    } catch (error) {
      console.error('Security check error:', error);
      return {
        is_blocked: false,
        failed_attempts: 0,
        mfa_required: false
      };
    }
  }

  /**
   * Log security event
   */
  async logSecurityEvent(
    eventType: SecurityEventType,
    eventData: Record<string, any> = {},
    riskScore = 0
  ): Promise<void> {
    try {
      const user = await this.getCurrentUser();
      const ipAddress = await this.getClientIP();
      const userAgent = navigator.userAgent;

      await this.supabase
        .from('security_events')
        .insert({
          user_id: user?.id,
          organization_id: this.organizationId || user?.organization_id,
          event_type: eventType,
          event_data: eventData,
          ip_address: ipAddress,
          user_agent: userAgent,
          risk_score: riskScore
        });

    } catch (error) {
      console.error('Log security event error:', error);
    }
  }

  /**
   * Get security events for user
   */
  async getSecurityEvents(
    userId?: string,
    eventType?: SecurityEventType,
    limit = 50
  ): Promise<SecurityEvent[]> {
    try {
      let query = this.supabase
        .from('security_events')
        .select('*')
        .order('created_at', { ascending: false })
        .limit(limit);

      if (userId) {
        query = query.eq('user_id', userId);
      }

      if (eventType) {
        query = query.eq('event_type', eventType);
      }

      if (this.organizationId) {
        query = query.eq('organization_id', this.organizationId);
      }

      const { data: events, error } = await query;

      if (error) {
        throw error;
      }

      return events || [];

    } catch (error) {
      console.error('Get security events error:', error);
      return [];
    }
  }

  // ============================================================================
  // UTILITY METHODS
  // ============================================================================

  /**
   * Get current authenticated user
   */
  async getCurrentUser(): Promise<AuthUser | null> {
    try {
      const { data: { user } } = await this.supabase.auth.getUser();
      return user as AuthUser;
    } catch (error) {
      return null;
    }
  }

  /**
   * Get organization authentication settings
   */
  async getOrganizationAuthSettings(): Promise<OrganizationAuthSettings | null> {
    if (!this.organizationId) {
      return null;
    }

    try {
      const { data: org, error } = await this.supabase
        .from('organizations')
        .select(`
          sso_enabled,
          sso_domain,
          sso_provider,
          mfa_required,
          password_policy,
          session_timeout_minutes,
          allowed_domains,
          security_settings
        `)
        .eq('id', this.organizationId)
        .single();

      if (error) {
        throw error;
      }

      return org as OrganizationAuthSettings;

    } catch (error) {
      console.error('Get organization auth settings error:', error);
      return null;
    }
  }

  /**
   * Validate password against policy
   */
  validatePassword(password: string, policy: PasswordPolicy): {
    isValid: boolean;
    errors: string[];
  } {
    const errors: string[] = [];

    if (password.length < policy.min_length) {
      errors.push(`Password must be at least ${policy.min_length} characters long`);
    }

    if (policy.require_uppercase && !/[A-Z]/.test(password)) {
      errors.push('Password must contain at least one uppercase letter');
    }

    if (policy.require_lowercase && !/[a-z]/.test(password)) {
      errors.push('Password must contain at least one lowercase letter');
    }

    if (policy.require_numbers && !/\d/.test(password)) {
      errors.push('Password must contain at least one number');
    }

    if (policy.require_symbols && !/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
      errors.push('Password must contain at least one special character');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  // ============================================================================
  // PRIVATE HELPER METHODS
  // ============================================================================

  /**
   * Log failed login attempt
   */
  private async logFailedLoginAttempt(email: string): Promise<void> {
    try {
      const ipAddress = await this.getClientIP();
      const userAgent = navigator.userAgent;

      await this.supabase
        .from('failed_login_attempts')
        .insert({
          email,
          ip_address: ipAddress,
          user_agent: userAgent,
          organization_id: this.organizationId
        });

    } catch (error) {
      console.error('Log failed login attempt error:', error);
    }
  }

  /**
   * Verify backup code
   */
  private async verifyBackupCode(userId: string, code: string): Promise<boolean> {
    try {
      const codeHash = this.hashBackupCode(code);

      // Check if backup code exists and is unused
      const { data: backupCode, error } = await this.supabase
        .from('user_mfa_backup_codes')
        .select('*')
        .eq('user_id', userId)
        .eq('code_hash', codeHash)
        .eq('used', false)
        .single();

      if (error || !backupCode) {
        return false;
      }

      // Mark backup code as used
      await this.supabase
        .from('user_mfa_backup_codes')
        .update({ used: true, used_at: new Date().toISOString() })
        .eq('id', backupCode.id);

      // Log MFA success with backup code
      await this.logSecurityEvent('mfa_verified', {
        user_id: userId,
        method: 'backup_code'
      });

      return true;

    } catch (error) {
      console.error('Backup code verification error:', error);
      return false;
    }
  }

  /**
   * Hash backup code for storage
   */
  private hashBackupCode(code: string): string {
    // Simple hash for demo - use proper hashing in production
    return btoa(code).replace(/[^a-zA-Z0-9]/g, '');
  }

  /**
   * Get client IP address
   */
  private async getClientIP(): Promise<string> {
    try {
      // In a real implementation, you would get this from the server
      // For demo purposes, return localhost
      return '127.0.0.1';
    } catch (error) {
      return '0.0.0.0';
    }
  }
}

// ============================================================================
// FACTORY FUNCTION
// ============================================================================

/**
 * Create an AuthenticationService instance with environment configuration
 */
export function createAuthenticationService(organizationId?: string): AuthenticationService {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || process.env.SUPABASE_URL;
  const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

  if (!supabaseUrl || !supabaseKey) {
    throw new Error('Missing Supabase configuration. Please check environment variables.');
  }

  return new AuthenticationService(supabaseUrl, supabaseKey, organizationId);
}

// ============================================================================
// REACT HOOKS FOR AUTHENTICATION
// ============================================================================

/**
 * Authentication context for React apps
 */
interface AuthContextType {
  user: AuthUser | null;
  session: Session | null;
  loading: boolean;
  authService: AuthenticationService;
  signIn: (email: string, password: string, options?: AuthenticationOptions) => Promise<any>;
  signOut: () => Promise<void>;
  hasPermission: (permission: string, resourceType?: string, resourceId?: string) => Promise<boolean>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

/**
 * Authentication provider component
 */
export function AuthProvider({ 
  children, 
  organizationId 
}: { 
  children: React.ReactNode;
  organizationId?: string;
}) {
  const [authService] = useState(() => createAuthenticationService(organizationId));
  const [user, setUser] = useState<AuthUser | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Initialize auth state
    const initializeAuth = async () => {
      try {
        const currentUser = await authService.getCurrentUser();
        setUser(currentUser);
        
        // Get current session
        const { data: { session } } = await authService.supabase.auth.getSession();
        setSession(session);
      } catch (error) {
        console.error('Auth initialization error:', error);
      } finally {
        setLoading(false);
      }
    };

    initializeAuth();

    // Listen for auth changes
    const { data: { subscription } } = authService.supabase.auth.onAuthStateChange(
      async (event, session) => {
        setSession(session);
        setUser(session?.user as AuthUser || null);
        setLoading(false);
      }
    );

    return () => subscription.unsubscribe();
  }, [authService]);

  const signIn = useCallback(async (
    email: string, 
    password: string, 
    options?: AuthenticationOptions
  ) => {
    setLoading(true);
    try {
      const result = await authService.signIn(email, password, options);
      return result;
    } finally {
      setLoading(false);
    }
  }, [authService]);

  const signOut = useCallback(async () => {
    setLoading(true);
    try {
      await authService.signOut();
    } finally {
      setLoading(false);
    }
  }, [authService]);

  const hasPermission = useCallback(async (
    permission: string,
    resourceType?: string,
    resourceId?: string
  ) => {
    if (!user) return false;
    return authService.hasPermission(user.id, permission, resourceType, resourceId);
  }, [authService, user]);

  const contextValue: AuthContextType = {
    user,
    session,
    loading,
    authService,
    signIn,
    signOut,
    hasPermission
  };

  return React.createElement(
    AuthContext.Provider,
    { value: contextValue },
    children
  );
}

/**
 * Hook to use authentication context
 */
export function useAuth(): AuthContextType {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

/**
 * Hook for MFA management
 */
export function useMFA() {
  const { authService, user } = useAuth();
  const [isSettingUp, setIsSettingUp] = useState(false);

  const setupMFA = useCallback(async () => {
    if (!user) throw new Error('User not authenticated');
    
    setIsSettingUp(true);
    try {
      const result = await authService.setupMFA(user.id);
      return result;
    } finally {
      setIsSettingUp(false);
    }
  }, [authService, user]);

  const verifyMFA = useCallback(async (token: string, isBackupCode = false) => {
    if (!user) throw new Error('User not authenticated');
    return authService.verifyMFA(user.id, token, isBackupCode);
  }, [authService, user]);

  const disableMFA = useCallback(async () => {
    if (!user) throw new Error('User not authenticated');
    return authService.disableMFA(user.id);
  }, [authService, user]);

  return {
    setupMFA,
    verifyMFA,
    disableMFA,
    isSettingUp
  };
}

/**
 * Hook for SSO management
 */
export function useSSO() {
  const { authService } = useAuth();
  const [providers, setProviders] = useState<SSOProvider[]>([]);
  const [loading, setLoading] = useState(false);

  const loadProviders = useCallback(async () => {
    setLoading(true);
    try {
      const ssoProviders = await authService.getSSOProviders();
      setProviders(ssoProviders);
    } catch (error) {
      console.error('Load SSO providers error:', error);
    } finally {
      setLoading(false);
    }
  }, [authService]);

  const signInWithSSO = useCallback(async (providerId: string) => {
    return authService.signInWithSSO(providerId);
  }, [authService]);

  useEffect(() => {
    loadProviders();
  }, [loadProviders]);

  return {
    providers,
    loading,
    signInWithSSO,
    reloadProviders: loadProviders
  };
}